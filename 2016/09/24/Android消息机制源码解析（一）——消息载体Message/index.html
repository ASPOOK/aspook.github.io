<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Android消息机制源码解析（一）——消息载体Message"/>




  <meta name="keywords" content="Android消息机制源码解析, Message, ASPOOK" />










  <link rel="alternative" href="/default" title="ASPOOK" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://aspook.com/2016/09/24/Android消息机制源码解析（一）——消息载体Message/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />






  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> Android消息机制源码解析（一）——消息载体Message - ASPOOK </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">ASPOOK</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">ASPOOK</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Android消息机制源码解析（一）——消息载体Message
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-09-24
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Message_u5B9A_u4E49_u4E0E_u5E8F_u5217_u5316"><span class="toc-text">Message定义与序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Message_u4E3B_u8981_u5C5E_u6027_u5B57_u6BB5"><span class="toc-text">Message主要属性字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Message_u5BF9_u8C61_u7684_u521B_u5EFA"><span class="toc-text">Message对象的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Message_u7684_u76F8_u5173_u65B9_u6CD5"><span class="toc-text">Message的相关方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Message_u5BF9_u8C61_u7684_u56DE_u6536"><span class="toc-text">Message对象的回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5F02_u6B65_u6D88_u606F"><span class="toc-text">异步消息</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p>说到Android的消息机制，大家再熟悉不过了，几乎每个逻辑界面中都会涉及到，Activity的生命周期回调也是通过系统消息机制完成的，可见消息机制在Android中的重要性。在应用层，一般我们都是使用Handler来发送、处理消息，从工作线程切换到主线程来更新UI。往往开发者只跟Handler、Message打交道就能满足需求了，但它们背后的实现原理是怎样的呢？为了加深理解，深入学习Android设计理念，同时也希望给初学者带来一些帮助，下面会从源码角度来分析Android的消息机制，鉴于篇幅原因，大致分为如下四个小节：</p>
<ol>
<li>Andorid消息载体Message</li>
<li>Android消息执行者Handler</li>
<li>Android消息循环器Looper</li>
<li>Android消息队列MessageQueue</li>
</ol>
<p>直入正题，先来看Android消息载体Message。</p>
<h3 id="Message_u5B9A_u4E49_u4E0E_u5E8F_u5217_u5316"><a href="#Message_u5B9A_u4E49_u4E0E_u5E8F_u5217_u5316" class="headerlink" title="Message定义与序列化"></a>Message定义与序列化</h3><p>大家都知道Handler发送的是消息，这里的消息对应的正是Message对象，来看一下源码中Message的定义与实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span></span>&#123;</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先可以看到Message实现了Parcelable接口，那么接下来就必然会实现序列化需要的几个方法，序列化部分代码不需要过多解释，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Message&gt; CREATOR</span><br><span class="line">        = <span class="keyword">new</span> Parcelable.Creator&lt;Message&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">createFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        msg.readFromParcel(source);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Message[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message[size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't marshal callbacks across processes."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dest.writeInt(what);</span><br><span class="line">    dest.writeInt(arg1);</span><br><span class="line">    dest.writeInt(arg2);</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Parcelable p = (Parcelable)obj;</span><br><span class="line">            dest.writeInt(<span class="number">1</span>);</span><br><span class="line">            dest.writeParcelable(p, flags);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't marshal non-Parcelable objects across processes."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dest.writeInt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dest.writeLong(when);</span><br><span class="line">    dest.writeBundle(data);</span><br><span class="line">    Messenger.writeMessengerOrNullToParcel(replyTo, dest);</span><br><span class="line">    dest.writeInt(sendingUid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">    what = source.readInt();</span><br><span class="line">    arg1 = source.readInt();</span><br><span class="line">    arg2 = source.readInt();</span><br><span class="line">    <span class="keyword">if</span> (source.readInt() != <span class="number">0</span>) &#123;</span><br><span class="line">        obj = source.readParcelable(getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    when = source.readLong();</span><br><span class="line">    data = source.readBundle();</span><br><span class="line">    replyTo = Messenger.readMessengerOrNullFromParcel(source);</span><br><span class="line">    sendingUid = source.readInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Message_u4E3B_u8981_u5C5E_u6027_u5B57_u6BB5"><a href="#Message_u4E3B_u8981_u5C5E_u6027_u5B57_u6BB5" class="headerlink" title="Message主要属性字段"></a>Message主要属性字段</h3><p>下面重量级的嘉宾开始登场了，之所以把Message称为消息的载体，是因为Message是对消息内容的一个封装，根据平时的开发经验，大家知道Message可以传递一些数据，比如整型、Bundle以及Object，那么Message为什么拥有这种能力呢？来看下Message的几个重要属性字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> what;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg1; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg2;</span><br><span class="line"><span class="keyword">public</span> Object obj;</span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">long</span> when;</span><br><span class="line"><span class="comment">/*package*/</span> Bundle data;</span><br><span class="line"><span class="comment">/*package*/</span> Handler target;</span><br><span class="line"><span class="comment">/*package*/</span> Runnable callback;</span><br></pre></td></tr></table></figure>
<p>相信大家对前边几个字段非常熟悉，what是开发者自定义的一个整型标识，作用就是接收者（接收者就是Handler了）收到消息时可以知道此消息的来源与用途；有时候一个消息仅需要简单传递一些轻量级的整数，此时arg1和arg2就可以派上用场了，从而不必使用Bundle，可以节省开销；Message还可以利用Object来传递任意数据，但在用于进程间通讯时，如object实现了Parceable则必须保证不为空；当然最常用的是通过Bundle来传递数据了，即上面第6个字段；when用来存储消息何时执行；target实际上是一个Handler,表示该消息是由谁发送的；此外Message还有一个callback字段，本质上是一个Runnable，用来支持发送Runnable类型的消息，如Handler中的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数Runnable最终被赋给消息的上述callback字段。</p>
<p>Android中的Message对象是按链表结构存储的，这样就可以利用消息池，从而减少对象的创建，提高性能，具体有如下相关字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sometimes we store linked lists of these things</span></span><br><span class="line"><span class="comment">/*package*/</span> Message next;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> gCheckRecycle = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>从字段名称很容易理解，sPool可以理解为消息链表的头部，next指向下一条消息，其中默认消息池初始值为0，最大容量为50；gCheckRecycle是一个用来辅助回收消息的辅助变量。</p>
<p>此外，Message还有如下两个字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Optional Messenger where replies to this message can be sent.  The</span><br><span class="line"> * semantics of exactly how this is used are up to the sender and</span><br><span class="line"> * receiver.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> Messenger replyTo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Optional field indicating the uid that sent the message.  This is</span><br><span class="line"> * only valid for messages posted by a &#123;<span class="doctag">@link</span> Messenger&#125;; otherwise,</span><br><span class="line"> * it will be -1.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> sendingUid = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这两个字段是用来进程间通讯的，这里就不再展开。</p>
<h3 id="Message_u5BF9_u8C61_u7684_u521B_u5EFA"><a href="#Message_u5BF9_u8C61_u7684_u521B_u5EFA" class="headerlink" title="Message对象的创建"></a>Message对象的创建</h3><p>Message的主要属性字段都介绍完了，那么如何创建一个Message呢？尽管Message提供了public的无参构造函数，但是并不建议通过构造函数创建Message对象。很多无经验的开发者往往会new一个Message，这是不可取的，应该特别注意。Message类为我们提供了obtain()及多个同名方法来从消息池中获取一个Message，这样就可以利用消息池中回收的对象，避免重新创建对象，以节省开销。来看一下obtain()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Return a new Message instance from the global pool. Allows us to</span><br><span class="line"> * avoid allocating new objects in many cases.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;</span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，sPoolSync是用来保证线程同步的，上述代码仅在消息池中没有可用对象时才通过无参构造方法创建对象，否则就从消息池中返回一个Message对象。obtain()其他同名方法原理也一样，只不过会将参数赋值给获取到的Message各个字段（最初提到的what、arg1、arg2、obj、target等属性字段），如带Handler参数的obtain()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h)</span> </span>&#123;</span><br><span class="line">    Message m = obtain();</span><br><span class="line">    m.target = h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如带有Handler、what、obj三个参数的obtain()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what, Object obj)</span> </span>&#123;</span><br><span class="line">    Message m = obtain();</span><br><span class="line">    m.target = h;</span><br><span class="line">    m.what = what;</span><br><span class="line">    m.obj = obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他类似，就不再一一列举。</p>
<p>分析到这里，事先提一下，除了使用Message类的obtain()相关方法获取消息对象之外，也可以使用Handler类提供的obtainMessage()系列方法，其内部实现则是调用了Message的obtain()系列方法，等第二节讲到Handler时会详细说明。</p>
<h3 id="Message_u7684_u76F8_u5173_u65B9_u6CD5"><a href="#Message_u7684_u76F8_u5173_u65B9_u6CD5" class="headerlink" title="Message的相关方法"></a>Message的相关方法</h3><p>Message类提供了几个set方法，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Handler target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果obtain()方法中没有传递Handler参数，则可以使用上述方法设置，明确该消息由谁来发送和接收。指定消息的Handler后，还有一个sendToTarget():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Sends this Message to the Handler specified by &#123;<span class="doctag">@link</span> #getTarget&#125;.</span><br><span class="line"> * Throws a null pointer exception if this field has not been set.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendToTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    target.sendMessage(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释已经写的很清楚了，如果一个消息未指定Handler，则调用此方法会报空指针。我们在开发时需要发送一个消息，往往会这样写：</p>
<p><code>Message message = Message.obtain(mHandler, what, obj);</code></p>
<p><code>message.sendToTarget();</code></p>
<p>sendToTarget()实际上会调用Handler中发送消息的方法，最终会将消息添加到一个队列中，当然发送消息也可以直接使用Handler的sendMessage系列方法，这些内容在后面会详细介绍。</p>
<p>如果需要使用Bundle来发送消息，那么当封装好Bundle后，可以利用以下方法将Bundle保存到消息中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Bundle data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样Message类还提供了一系列获取对象属性的方法，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Return the targeted delivery time of this message, in milliseconds.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getWhen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> when;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法返回消息的执行时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Handler <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法返回发送、接收消息的Handler对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Runnable <span class="title">getCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法返回Runnable对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bundle <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> Bundle();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法返回一个Bundle,如果为空则会创建一个新的对象返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bundle <span class="title">peekData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法则不管Bundle是否为空，直接返回。</p>
<h3 id="Message_u5BF9_u8C61_u7684_u56DE_u6536"><a href="#Message_u5BF9_u8C61_u7684_u56DE_u6536" class="headerlink" title="Message对象的回收"></a>Message对象的回收</h3><p>来再看一下消息回收的源码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Recycles a Message that may be in-use.</span><br><span class="line"> * Used internally by the MessageQueue and Looper when disposing of queued Messages.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">    <span class="comment">// Clear out all other details.</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = -<span class="number">1</span>;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较容易理解，就是消息的各个属性置为初始值，同时消息池数量在未超限时加1。</p>
<h3 id="u5F02_u6B65_u6D88_u606F"><a href="#u5F02_u6B65_u6D88_u606F" class="headerlink" title="异步消息"></a>异步消息</h3><p>最后简单说一下异步消息，一般情况下发送的消息都是同步的，在某些情况下可能会用到异步消息，比如View的刷新。异步消息顾名思义，它不会受同步消息的顺序限制，因此可能引发不可预知的情况，所以建议慎用。如果需要将某个消息设置为异步执行，可调用如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsynchronous</span><span class="params">(<span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        flags |= FLAG_ASYNCHRONOUS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flags &amp;= ~FLAG_ASYNCHRONOUS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中flag是一个int型的标识字段，如果想判断某个消息是否为异步消息，调用如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAsynchronous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (flags &amp; FLAG_ASYNCHRONOUS) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Message源码比较简单，逻辑也很清楚，总结一下，主要是Message的一些重要的属性字段、Message的链表特性以及如何利用obtain()系列方法高效创建一个Message对象等。Android消息的载体Message我们已经彻底搞清楚了，那么这些构造好的消息又是如何发送出去的呢，它们又是如何被接收和处理的？请看《Android消息机制源码解析（二）——消息执行者Handler》。</p>
<p>本文最初于2015年12月13日发布于个人<a href="http://blog.csdn.net/ahence/article/details/50287817" target="_blank" rel="external">CSDN博客</a>。</p>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://aspook.com">AN</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://aspook.com/2016/09/24/Android消息机制源码解析（一）——消息载体Message/">http://aspook.com/2016/09/24/Android消息机制源码解析（一）——消息载体Message/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/Android消息机制源码解析/">Android消息机制源码解析</a>
            
              <a href="/tags/Message/">Message</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2016/09/24/Android消息机制源码解析（二）——消息执行者Handler/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Android消息机制源码解析（二）——消息执行者Handler</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2016/09/08/Java内存分配策略——《深入理解Java虚拟机》笔记/">
        <span class="next-text nav-default">Java内存分配策略——《深入理解Java虚拟机》笔记</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">AN</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  



    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Bundle源码解析"/>




  <meta name="keywords" content="Bundle, 源码解析, ASPOOK" />










  <link rel="alternative" href="/default" title="ASPOOK" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://aspook.com/2016/07/05/Bundle源码解析/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />






  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> Bundle源码解析 - ASPOOK </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">ASPOOK</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">ASPOOK</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Bundle源码解析
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-07-05
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bundle_u7684_u6982_u5FF5_u7406_u89E3"><span class="toc-text">Bundle的概念理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bundle_u6E90_u7801_u5206_u6790"><span class="toc-text">Bundle源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bundle_u7684_u51E0_u4E2A_u516C_u6709_u6784_u9020_u65B9_u6CD5"><span class="toc-text">Bundle的几个公有构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bundle_u7684put_u4E0Eget_u65B9_u6CD5_u65CF"><span class="toc-text">Bundle的put与get方法族</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bundle_u5B58_u53D6_u6570_u636E_u7684_u5177_u4F53_u5B9E_u73B0"><span class="toc-text">Bundle存取数据的具体实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u5C0F_u7ED3"><span class="toc-text">小结</span></a></li></ol></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p>本文最初于2016-05-18发布于个人<a href="http://blog.csdn.net/ahence/article/details/51443722" target="_blank" rel="external">CSDN博客</a>。</p>
<h3 id="Bundle_u7684_u6982_u5FF5_u7406_u89E3"><a href="#Bundle_u7684_u6982_u5FF5_u7406_u89E3" class="headerlink" title="Bundle的概念理解"></a>Bundle的概念理解</h3><p>Bundle对于Android开发者来说肯定非常眼熟，它经常出现在以下场合：</p>
<ol>
<li>Activity状态数据的保存与恢复涉及到的两个回调：<code>void onSaveInstanceState (Bundle outState)</code>、<code>void onCreate (Bundle savedInstanceState)</code></li>
<li>Fragment的setArguments方法：<code>void setArguments (Bundle args)</code></li>
<li>消息机制中的Message的setData方法：<code>void setData (Bundle data)</code></li>
<li>其他场景不再列举</li>
</ol>
<p>Bundle从字面上解释为“一捆、一批、一包”，结合上述几个应用场合，可以知道Bundle是用来传递数据的，我们暂将Bundle理解为Android中用来传递数据的一个容器。官方文档对Bundle的说明如下：</p>
<blockquote>
<p>A mapping from String values to various Parcelable types.</p>
</blockquote>
<p>官方意为Bundle封装了String值到各种Parcelable类型数据的映射，可见跟我们上述理解是吻合的。</p>
<h3 id="Bundle_u6E90_u7801_u5206_u6790"><a href="#Bundle_u6E90_u7801_u5206_u6790" class="headerlink" title="Bundle源码分析"></a>Bundle源码分析</h3><p>知道了Bundle的主要作用，再来看源码就容易理解了。</p>
<p>Bundle位于<code>android.os</code>包中，是一个final类，这就注定了Bundle不能被继承。Bundle继承自BaseBundle并实现了Cloneable和Parcelable两个接口，因此对Bundle源码的分析会结合着对BaseBundle源码进行分析。由于实现了Cloneable和Parcelable接口，因此以下几个重载是必不可少的：</p>
<ul>
<li><code>public Object clone()</code></li>
<li><code>public int describeContents()</code></li>
<li><code>public void writeToParcel(Parcel parcel, int flags)</code></li>
<li><code>public void readFromParcel(Parcel parcel)</code></li>
<li><code>public static final Parcelable.Creator&lt;Bundle&gt; CREATOR = new Parcelable.Creator&lt;Bundle&gt;()</code> </li>
</ul>
<p>以上代码无需过多解释。</p>
<h4 id="Bundle_u7684_u51E0_u4E2A_u516C_u6709_u6784_u9020_u65B9_u6CD5"><a href="#Bundle_u7684_u51E0_u4E2A_u516C_u6709_u6784_u9020_u65B9_u6CD5" class="headerlink" title="Bundle的几个公有构造方法"></a>Bundle的几个公有构造方法</h4><table>
<thead>
<tr>
<th>公有构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public Bundle()</td>
<td>Constructs a new, empty Bundle</td>
</tr>
<tr>
<td>public Bundle(ClassLoader loader)</td>
<td>Constructs a new, empty Bundle that uses a specific ClassLoader for instantiating Parcelable and Serializable objects.</td>
</tr>
<tr>
<td>public Bundle(int capacity)</td>
<td>Constructs a new, empty Bundle sized to hold the given number of elements.</td>
</tr>
<tr>
<td>public Bundle(Bundle b)</td>
<td>Constructs a Bundle containing a copy of the mappings from the given Bundle.</td>
</tr>
<tr>
<td>public Bundle(PersistableBundle b)</td>
<td>Constructs a Bundle containing a copy of the mappings from the given PersistableBundle.</td>
</tr>
</tbody>
</table>
<p>第5个构造函数中的PersistableBundle也是继承自BaseBundle的，Bundle还提供了一个静态方法，用来返回只包含一个键值对的Bundle对象，具体源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bundle <span class="title">forPair</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">    Bundle b = <span class="keyword">new</span> Bundle(<span class="number">1</span>);</span><br><span class="line">    b.putString(key, value);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Bundle_u7684put_u4E0Eget_u65B9_u6CD5_u65CF"><a href="#Bundle_u7684put_u4E0Eget_u65B9_u6CD5_u65CF" class="headerlink" title="Bundle的put与get方法族"></a>Bundle的put与get方法族</h4><p>Bundle的功能是用来保存数据，那么必然提供了一系列存取数据的方法，这些方法太多了，几乎能够存取任何类型的数据，具体整理为下表：</p>
<table>
<thead>
<tr>
<th>相关保存方法</th>
<th>相关读取方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>public void putBoolean(String key, boolean value)</td>
<td>public boolean getBoolean(String key)</td>
</tr>
<tr>
<td>public void putByte(String key, byte value)</td>
<td>public byte getByte(String key)</td>
</tr>
<tr>
<td>public void putChar(String key, char value)</td>
<td>public char getChar(String key)</td>
</tr>
<tr>
<td>public void putShort(String key, short value)</td>
<td>public short getShort(String key)</td>
</tr>
<tr>
<td>public void putFloat(String key, float value)</td>
<td>public float getFloat(String key)</td>
</tr>
<tr>
<td>public void putCharSequence(String key, CharSequence value)</td>
<td>public CharSequence getCharSequence(String key)</td>
</tr>
<tr>
<td>public void putParcelable(String key, Parcelable value)</td>
<td>public <t extends="" parcelable=""> T getParcelable(String key)</t></td>
</tr>
<tr>
<td>public void putSize(String key, Size value)</td>
<td>public Size getSize(String key)</td>
</tr>
<tr>
<td>public void putSizeF(String key, SizeF value)</td>
<td>public SizeF getSizeF(String key)</td>
</tr>
<tr>
<td>public void putParcelableArray(String key, Parcelable[] value)</td>
<td>public Parcelable[] getParcelableArray(String key)</td>
</tr>
<tr>
<td>public void putParcelableArrayList(String key, ArrayList&lt;? extends Parcelable&gt; value)</td>
<td>public <t extends="" parcelable=""> ArrayList<t> getParcelableArrayList(String key)</t></t></td>
</tr>
<tr>
<td>public void putSparseParcelableArray(String key, SparseArray&lt;? extends Parcelable&gt; value)</td>
<td>public <t extends="" parcelable=""> SparseArray<t> getSparseParcelableArray(String key)</t></t></td>
</tr>
<tr>
<td>public void putIntegerArrayList(String key, ArrayList<integer> value)</integer></td>
<td>public ArrayList<integer> getIntegerArrayList(String key)</integer></td>
</tr>
<tr>
<td>public void putStringArrayList(String key, ArrayList<string> value)</string></td>
<td>public ArrayList<string> getStringArrayList(String key)</string></td>
</tr>
<tr>
<td>public void putCharSequenceArrayList(String key, ArrayList<charsequence> value)</charsequence></td>
<td>public ArrayList<charsequence> getCharSequenceArrayList(String key)</charsequence></td>
</tr>
<tr>
<td>public void putSerializable(String key, Serializable value)</td>
<td>public Serializable getSerializable(String key)</td>
</tr>
<tr>
<td>public void putBooleanArray(String key, boolean[] value)</td>
<td>public boolean[] getBooleanArray(String key)</td>
</tr>
<tr>
<td>public void putByteArray(String key, byte[] value)</td>
<td>public byte[] getByteArray(String key)</td>
</tr>
<tr>
<td>public void putShortArray(String key, short[] value)</td>
<td>public short[] getShortArray(String key)</td>
</tr>
<tr>
<td>public void putCharArray(String key, char[] value)</td>
<td>public char[] getCharArray(String key)</td>
</tr>
<tr>
<td>public void putFloatArray(String key, float[] value)</td>
<td>public float[] getFloatArray(String key)</td>
</tr>
<tr>
<td>public void putCharSequenceArray(String key, CharSequence[] value)</td>
<td>public CharSequence[] getCharSequenceArray(String key)</td>
</tr>
<tr>
<td>public void putBundle(String key, Bundle value)</td>
<td>public Bundle getBundle(String key)</td>
</tr>
<tr>
<td>public void putBinder(String key, IBinder value)</td>
<td>public IBinder getBinder(String key)</td>
</tr>
</tbody>
</table>
<p>除了上述存取数据涉及到的方法外，Bundle还提供了一个clear方法：<code>public void clear()</code>，该方法可用于移除Bundle中的所有数据。</p>
<p>Bundle之所以能以键值对的方式存储数据，实质上是因为它内部维护了一个ArrayMap，具体定义是在其父类BaseBundle中：</p>
<blockquote>
<p>ArrayMap&lt;String, ObjectmMap = null;</p>
</blockquote>
<p>ArrayMap比HashMap更加高效、更加节省内存，它的初始化是在Bundle的构造方法中实现的，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BaseBundle(ClassLoader loader, <span class="keyword">int</span> capacity) &#123;</span><br><span class="line">    mMap = capacity &gt; <span class="number">0</span> ?</span><br><span class="line">            <span class="keyword">new</span> ArrayMap&lt;String, Object&gt;(capacity) : <span class="keyword">new</span> ArrayMap&lt;String, Object&gt;();</span><br><span class="line">    mClassLoader = loader == <span class="keyword">null</span> ? getClass().getClassLoader() : loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外还可以发现，存储数据用的key都是String类型，值为各种数据类型，甚至可以存储Bundle、Binder等，如果ArrayMap中存在相同的key，则会替换掉之前的对应值。每一个put方法都对应一个get方法，对于基本数据类型还可以设置缺省值（上述表中未列出对应方法）。具体的存取则是在其父类BaseBundle中实现的，下面就以布尔类型数据为例来分析一下。</p>
<h4 id="Bundle_u5B58_u53D6_u6570_u636E_u7684_u5177_u4F53_u5B9E_u73B0"><a href="#Bundle_u5B58_u53D6_u6570_u636E_u7684_u5177_u4F53_u5B9E_u73B0" class="headerlink" title="Bundle存取数据的具体实现"></a>Bundle存取数据的具体实现</h4><p>布尔数据的存储源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Inserts a Boolean value into the mapping of this Bundle, replacing</span><br><span class="line"> * any existing value for the given key.  Either key or value may be null.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> key a String, or null</span><br><span class="line"> * <span class="doctag">@param</span> value a Boolean, or null</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putBoolean</span><span class="params">(String key, <span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">    unparcel();</span><br><span class="line">    mMap.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的mMap就是ArrayMap了，存储数据就是把键值对保存到ArrayMap里。</p>
<p>布尔类型数据的读取源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns the value associated with the given key, or false if</span><br><span class="line"> * no mapping of the desired type exists for the given key.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> key a String</span><br><span class="line"> * <span class="doctag">@return</span> a boolean value</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    unparcel();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"Getting boolean in "</span>+ Integer.toHexString(System.identityHashCode(<span class="keyword">this</span>)));</span><br><span class="line">    <span class="keyword">return</span> getBoolean(key, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getBoolean(String key, boolean defaultValue)的具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns the value associated with the given key, or defaultValue if</span><br><span class="line"> * no mapping of the desired type exists for the given key.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> key a String</span><br><span class="line"> * <span class="doctag">@param</span> defaultValue Value to return if key does not exist</span><br><span class="line"> * <span class="doctag">@return</span> a boolean value</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(String key, <span class="keyword">boolean</span> defaultValue)</span> </span>&#123;</span><br><span class="line">    unparcel();</span><br><span class="line">    Object o = mMap.get(key);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Boolean) o;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">        typeWarning(key, o, <span class="string">"Boolean"</span>, defaultValue, e);</span><br><span class="line">        <span class="keyword">return</span> defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据读取的逻辑也很简单，就是通过key从ArrayMap里读出保存的数据，并转换成对应的类型返回，当没找到数据或发生类型转换异常时返回缺省值。</p>
<p>注意到这里出现了一个方法：<code>unparcel()</code>，它的具体源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * If the underlying data are stored as a Parcel, unparcel them</span><br><span class="line"> * using the currently assigned class loader.</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* package */</span> <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unparcel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mParcelledData == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(<span class="keyword">this</span>))</span><br><span class="line">                + <span class="string">": no parcelled data"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mParcelledData == EMPTY_PARCEL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(<span class="keyword">this</span>))</span><br><span class="line">                + <span class="string">": empty"</span>);</span><br><span class="line">        <span class="keyword">if</span> (mMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mMap = <span class="keyword">new</span> ArrayMap&lt;String, Object&gt;(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMap.erase();</span><br><span class="line">        &#125;</span><br><span class="line">        mParcelledData = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> N = mParcelledData.readInt();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(<span class="keyword">this</span>))</span><br><span class="line">            + <span class="string">": reading "</span> + N + <span class="string">" maps"</span>);</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mMap = <span class="keyword">new</span> ArrayMap&lt;String, Object&gt;(N);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mMap.erase();</span><br><span class="line">        mMap.ensureCapacity(N);</span><br><span class="line">    &#125;</span><br><span class="line">    mParcelledData.readArrayMapInternal(mMap, N, mClassLoader);</span><br><span class="line">    mParcelledData.recycle();</span><br><span class="line">    mParcelledData = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(<span class="keyword">this</span>)) + <span class="string">" final map: "</span> + mMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先来看下BaseBundle中mParcelledData的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * If mParcelledData is non-null, then mMap will be null and the</span><br><span class="line"> * data are stored as a Parcel containing a Bundle.  When the data</span><br><span class="line"> * are unparcelled, mParcelledData willbe set to null.</span><br><span class="line"> */</span></span><br><span class="line">Parcel mParcelledData = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>在大部分情况下mParcelledData都是null，因此unparcel()直接返回。当使用构造函数<code>public Bundle(Bundle b)</code>创建Bundle时，会给mParcelledData赋值，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Constructs a Bundle containing a copy of the mappings from the given</span><br><span class="line"> * Bundle.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> b a Bundle to be copied.</span><br><span class="line"> */</span></span><br><span class="line">BaseBundle(BaseBundle b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b.mParcelledData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b.mParcelledData == EMPTY_PARCEL) &#123;</span><br><span class="line">            mParcelledData = EMPTY_PARCEL;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mParcelledData = Parcel.obtain();</span><br><span class="line">            mParcelledData.appendFrom(b.mParcelledData, <span class="number">0</span>, b.mParcelledData.dataSize());</span><br><span class="line">            mParcelledData.setDataPosition(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mParcelledData = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b.mMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mMap = <span class="keyword">new</span> ArrayMap&lt;String, Object&gt;(b.mMap);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mMap = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mClassLoader = b.mClassLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码片段可以知道mParcelledData的取值有3种情况：</p>
<ul>
<li>mParcelledData = EMPTY_PARCEL</li>
<li>mParcelledData = Parcel.obtain()</li>
<li>mParcelledData = null</li>
</ul>
<p>在<code>unparcel()</code>方法中就对上述几种情况做了不同的处理，当mParcelledData为null时，直接返回；当mParcelledData为EMPTY_PARCEL时，会创建一个容量为1的ArrayMap对象；当mParcelledData为Parcel.obtain()时，则会将里面的数据读出，并创建一个ArrayMap，并将数据存储到ArrayMap对象里面，同时将mParcelledData回收并置为null，具体是由以下代码片段实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N = mParcelledData.readInt();</span><br><span class="line"><span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(<span class="keyword">this</span>))</span><br><span class="line">        + <span class="string">": reading "</span> + N + <span class="string">" maps"</span>);</span><br><span class="line"><span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">    mMap = <span class="keyword">new</span> ArrayMap&lt;String, Object&gt;(N);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mMap.erase();</span><br><span class="line">    mMap.ensureCapacity(N);</span><br><span class="line">&#125;</span><br><span class="line">mParcelledData.readArrayMapInternal(mMap, N, mClassLoader);</span><br><span class="line">mParcelledData.recycle();</span><br><span class="line">mParcelledData = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>上面只是以布尔类型的数据为例分析了Bundle的存取过程，其他数据类型的存取原理相同，就不再赘述。</p>
<h4 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h4><p>到此，Bundle的源码分析基本就结束了，其实Bundle比较简单，只是一个数据容器，不像Activity等有复杂的生命周期。对于开发者来说，只需要了解Bundle的功能、使用场景并掌握常用的数据存取方法即可。</p>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://aspook.com">AN</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://aspook.com/2016/07/05/Bundle源码解析/">http://aspook.com/2016/07/05/Bundle源码解析/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/Bundle/">Bundle</a>
            
              <a href="/tags/源码解析/">源码解析</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2016/07/05/二叉树的构建及各种遍历方式/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">二叉树的构建及各种遍历方式</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2016/07/03/如何构建安全的Android应用/">
        <span class="next-text nav-default">如何构建安全的Android应用</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">AN</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  



    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>

<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="请不要灰心，你也会有人妒忌"><title>Bundle源码解析 | Aspook</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Bundle源码解析</h1><a id="logo" href="/.">Aspook</a><p class="description">Serendipity</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Bundle源码解析</h1><div class="post-meta">Jul 5, 2016<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/07/05/Bundle源码解析/" href="/2016/07/05/Bundle源码解析/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>本文最初于2016-05-18发布于个人<a href="http://blog.csdn.net/ahence/article/details/51443722" target="_blank" rel="external">CSDN博客</a>。</p>
<h3 id="Bundle_u7684_u6982_u5FF5_u7406_u89E3"><a href="#Bundle_u7684_u6982_u5FF5_u7406_u89E3" class="headerlink" title="Bundle的概念理解"></a>Bundle的概念理解</h3><p>Bundle对于Android开发者来说肯定非常眼熟，它经常出现在以下场合：</p>
<ol>
<li>Activity状态数据的保存与恢复涉及到的两个回调：<code>void onSaveInstanceState (Bundle outState)</code>、<code>void onCreate (Bundle savedInstanceState)</code></li>
<li>Fragment的setArguments方法：<code>void setArguments (Bundle args)</code></li>
<li>消息机制中的Message的setData方法：<code>void setData (Bundle data)</code></li>
<li>其他场景不再列举</li>
</ol>
<p>Bundle从字面上解释为“一捆、一批、一包”，结合上述几个应用场合，可以知道Bundle是用来传递数据的，我们暂将Bundle理解为Android中用来传递数据的一个容器。官方文档对Bundle的说明如下：</p>
<blockquote>
<p>A mapping from String values to various Parcelable types.</p>
</blockquote>
<p>官方意为Bundle封装了String值到各种Parcelable类型数据的映射，可见跟我们上述理解是吻合的。</p>
<h3 id="Bundle_u6E90_u7801_u5206_u6790"><a href="#Bundle_u6E90_u7801_u5206_u6790" class="headerlink" title="Bundle源码分析"></a>Bundle源码分析</h3><p>知道了Bundle的主要作用，再来看源码就容易理解了。</p>
<p>Bundle位于<code>android.os</code>包中，是一个final类，这就注定了Bundle不能被继承。Bundle继承自BaseBundle并实现了Cloneable和Parcelable两个接口，因此对Bundle源码的分析会结合着对BaseBundle源码进行分析。由于实现了Cloneable和Parcelable接口，因此以下几个重载是必不可少的：</p>
<ul>
<li><code>public Object clone()</code></li>
<li><code>public int describeContents()</code></li>
<li><code>public void writeToParcel(Parcel parcel, int flags)</code></li>
<li><code>public void readFromParcel(Parcel parcel)</code></li>
<li><code>public static final Parcelable.Creator&lt;Bundle&gt; CREATOR = new Parcelable.Creator&lt;Bundle&gt;()</code> </li>
</ul>
<p>以上代码无需过多解释。</p>
<h4 id="Bundle_u7684_u51E0_u4E2A_u516C_u6709_u6784_u9020_u65B9_u6CD5"><a href="#Bundle_u7684_u51E0_u4E2A_u516C_u6709_u6784_u9020_u65B9_u6CD5" class="headerlink" title="Bundle的几个公有构造方法"></a>Bundle的几个公有构造方法</h4><table>
<thead>
<tr>
<th>公有构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public Bundle()</td>
<td>Constructs a new, empty Bundle</td>
</tr>
<tr>
<td>public Bundle(ClassLoader loader)</td>
<td>Constructs a new, empty Bundle that uses a specific ClassLoader for instantiating Parcelable and Serializable objects.</td>
</tr>
<tr>
<td>public Bundle(int capacity)</td>
<td>Constructs a new, empty Bundle sized to hold the given number of elements.</td>
</tr>
<tr>
<td>public Bundle(Bundle b)</td>
<td>Constructs a Bundle containing a copy of the mappings from the given Bundle.</td>
</tr>
<tr>
<td>public Bundle(PersistableBundle b)</td>
<td>Constructs a Bundle containing a copy of the mappings from the given PersistableBundle.</td>
</tr>
</tbody>
</table>
<p>第5个构造函数中的PersistableBundle也是继承自BaseBundle的，Bundle还提供了一个静态方法，用来返回只包含一个键值对的Bundle对象，具体源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bundle <span class="title">forPair</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">    Bundle b = <span class="keyword">new</span> Bundle(<span class="number">1</span>);</span><br><span class="line">    b.putString(key, value);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Bundle_u7684put_u4E0Eget_u65B9_u6CD5_u65CF"><a href="#Bundle_u7684put_u4E0Eget_u65B9_u6CD5_u65CF" class="headerlink" title="Bundle的put与get方法族"></a>Bundle的put与get方法族</h4><p>Bundle的功能是用来保存数据，那么必然提供了一系列存取数据的方法，这些方法太多了，几乎能够存取任何类型的数据，具体整理为下表：</p>
<table>
<thead>
<tr>
<th>相关保存方法</th>
<th>相关读取方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>public void putBoolean(String key, boolean value)</td>
<td>public boolean getBoolean(String key)</td>
</tr>
<tr>
<td>public void putByte(String key, byte value)</td>
<td>public byte getByte(String key)</td>
</tr>
<tr>
<td>public void putChar(String key, char value)</td>
<td>public char getChar(String key)</td>
</tr>
<tr>
<td>public void putShort(String key, short value)</td>
<td>public short getShort(String key)</td>
</tr>
<tr>
<td>public void putFloat(String key, float value)</td>
<td>public float getFloat(String key)</td>
</tr>
<tr>
<td>public void putCharSequence(String key, CharSequence value)</td>
<td>public CharSequence getCharSequence(String key)</td>
</tr>
<tr>
<td>public void putParcelable(String key, Parcelable value)</td>
<td>public <t extends="" parcelable=""> T getParcelable(String key)</t></td>
</tr>
<tr>
<td>public void putSize(String key, Size value)</td>
<td>public Size getSize(String key)</td>
</tr>
<tr>
<td>public void putSizeF(String key, SizeF value)</td>
<td>public SizeF getSizeF(String key)</td>
</tr>
<tr>
<td>public void putParcelableArray(String key, Parcelable[] value)</td>
<td>public Parcelable[] getParcelableArray(String key)</td>
</tr>
<tr>
<td>public void putParcelableArrayList(String key, ArrayList&lt;? extends Parcelable&gt; value)</td>
<td>public <t extends="" parcelable=""> ArrayList<t> getParcelableArrayList(String key)</t></t></td>
</tr>
<tr>
<td>public void putSparseParcelableArray(String key, SparseArray&lt;? extends Parcelable&gt; value)</td>
<td>public <t extends="" parcelable=""> SparseArray<t> getSparseParcelableArray(String key)</t></t></td>
</tr>
<tr>
<td>public void putIntegerArrayList(String key, ArrayList<integer> value)</integer></td>
<td>public ArrayList<integer> getIntegerArrayList(String key)</integer></td>
</tr>
<tr>
<td>public void putStringArrayList(String key, ArrayList<string> value)</string></td>
<td>public ArrayList<string> getStringArrayList(String key)</string></td>
</tr>
<tr>
<td>public void putCharSequenceArrayList(String key, ArrayList<charsequence> value)</charsequence></td>
<td>public ArrayList<charsequence> getCharSequenceArrayList(String key)</charsequence></td>
</tr>
<tr>
<td>public void putSerializable(String key, Serializable value)</td>
<td>public Serializable getSerializable(String key)</td>
</tr>
<tr>
<td>public void putBooleanArray(String key, boolean[] value)</td>
<td>public boolean[] getBooleanArray(String key)</td>
</tr>
<tr>
<td>public void putByteArray(String key, byte[] value)</td>
<td>public byte[] getByteArray(String key)</td>
</tr>
<tr>
<td>public void putShortArray(String key, short[] value)</td>
<td>public short[] getShortArray(String key)</td>
</tr>
<tr>
<td>public void putCharArray(String key, char[] value)</td>
<td>public char[] getCharArray(String key)</td>
</tr>
<tr>
<td>public void putFloatArray(String key, float[] value)</td>
<td>public float[] getFloatArray(String key)</td>
</tr>
<tr>
<td>public void putCharSequenceArray(String key, CharSequence[] value)</td>
<td>public CharSequence[] getCharSequenceArray(String key)</td>
</tr>
<tr>
<td>public void putBundle(String key, Bundle value)</td>
<td>public Bundle getBundle(String key)</td>
</tr>
<tr>
<td>public void putBinder(String key, IBinder value)</td>
<td>public IBinder getBinder(String key)</td>
</tr>
</tbody>
</table>
<p>除了上述存取数据涉及到的方法外，Bundle还提供了一个clear方法：<code>public void clear()</code>，该方法可用于移除Bundle中的所有数据。</p>
<p>Bundle之所以能以键值对的方式存储数据，实质上是因为它内部维护了一个ArrayMap，具体定义是在其父类BaseBundle中：</p>
<blockquote>
<p>ArrayMap&lt;String, ObjectmMap = null;</p>
</blockquote>
<p>ArrayMap比HashMap更加高效、更加节省内存，它的初始化是在Bundle的构造方法中实现的，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BaseBundle(ClassLoader loader, <span class="keyword">int</span> capacity) &#123;</span><br><span class="line">    mMap = capacity &gt; <span class="number">0</span> ?</span><br><span class="line">            <span class="keyword">new</span> ArrayMap&lt;String, Object&gt;(capacity) : <span class="keyword">new</span> ArrayMap&lt;String, Object&gt;();</span><br><span class="line">    mClassLoader = loader == <span class="keyword">null</span> ? getClass().getClassLoader() : loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外还可以发现，存储数据用的key都是String类型，值为各种数据类型，甚至可以存储Bundle、Binder等，如果ArrayMap中存在相同的key，则会替换掉之前的对应值。每一个put方法都对应一个get方法，对于基本数据类型还可以设置缺省值（上述表中未列出对应方法）。具体的存取则是在其父类BaseBundle中实现的，下面就以布尔类型数据为例来分析一下。</p>
<h4 id="Bundle_u5B58_u53D6_u6570_u636E_u7684_u5177_u4F53_u5B9E_u73B0"><a href="#Bundle_u5B58_u53D6_u6570_u636E_u7684_u5177_u4F53_u5B9E_u73B0" class="headerlink" title="Bundle存取数据的具体实现"></a>Bundle存取数据的具体实现</h4><p>布尔数据的存储源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Inserts a Boolean value into the mapping of this Bundle, replacing</span><br><span class="line"> * any existing value for the given key.  Either key or value may be null.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> key a String, or null</span><br><span class="line"> * <span class="doctag">@param</span> value a Boolean, or null</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putBoolean</span><span class="params">(String key, <span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">    unparcel();</span><br><span class="line">    mMap.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的mMap就是ArrayMap了，存储数据就是把键值对保存到ArrayMap里。</p>
<p>布尔类型数据的读取源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns the value associated with the given key, or false if</span><br><span class="line"> * no mapping of the desired type exists for the given key.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> key a String</span><br><span class="line"> * <span class="doctag">@return</span> a boolean value</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    unparcel();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"Getting boolean in "</span>+ Integer.toHexString(System.identityHashCode(<span class="keyword">this</span>)));</span><br><span class="line">    <span class="keyword">return</span> getBoolean(key, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getBoolean(String key, boolean defaultValue)的具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns the value associated with the given key, or defaultValue if</span><br><span class="line"> * no mapping of the desired type exists for the given key.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> key a String</span><br><span class="line"> * <span class="doctag">@param</span> defaultValue Value to return if key does not exist</span><br><span class="line"> * <span class="doctag">@return</span> a boolean value</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(String key, <span class="keyword">boolean</span> defaultValue)</span> </span>&#123;</span><br><span class="line">    unparcel();</span><br><span class="line">    Object o = mMap.get(key);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Boolean) o;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">        typeWarning(key, o, <span class="string">"Boolean"</span>, defaultValue, e);</span><br><span class="line">        <span class="keyword">return</span> defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据读取的逻辑也很简单，就是通过key从ArrayMap里读出保存的数据，并转换成对应的类型返回，当没找到数据或发生类型转换异常时返回缺省值。</p>
<p>注意到这里出现了一个方法：<code>unparcel()</code>，它的具体源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * If the underlying data are stored as a Parcel, unparcel them</span><br><span class="line"> * using the currently assigned class loader.</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* package */</span> <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unparcel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mParcelledData == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(<span class="keyword">this</span>))</span><br><span class="line">                + <span class="string">": no parcelled data"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mParcelledData == EMPTY_PARCEL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(<span class="keyword">this</span>))</span><br><span class="line">                + <span class="string">": empty"</span>);</span><br><span class="line">        <span class="keyword">if</span> (mMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mMap = <span class="keyword">new</span> ArrayMap&lt;String, Object&gt;(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMap.erase();</span><br><span class="line">        &#125;</span><br><span class="line">        mParcelledData = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> N = mParcelledData.readInt();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(<span class="keyword">this</span>))</span><br><span class="line">            + <span class="string">": reading "</span> + N + <span class="string">" maps"</span>);</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mMap = <span class="keyword">new</span> ArrayMap&lt;String, Object&gt;(N);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mMap.erase();</span><br><span class="line">        mMap.ensureCapacity(N);</span><br><span class="line">    &#125;</span><br><span class="line">    mParcelledData.readArrayMapInternal(mMap, N, mClassLoader);</span><br><span class="line">    mParcelledData.recycle();</span><br><span class="line">    mParcelledData = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(<span class="keyword">this</span>)) + <span class="string">" final map: "</span> + mMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先来看下BaseBundle中mParcelledData的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * If mParcelledData is non-null, then mMap will be null and the</span><br><span class="line"> * data are stored as a Parcel containing a Bundle.  When the data</span><br><span class="line"> * are unparcelled, mParcelledData willbe set to null.</span><br><span class="line"> */</span></span><br><span class="line">Parcel mParcelledData = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>在大部分情况下mParcelledData都是null，因此unparcel()直接返回。当使用构造函数<code>public Bundle(Bundle b)</code>创建Bundle时，会给mParcelledData赋值，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Constructs a Bundle containing a copy of the mappings from the given</span><br><span class="line"> * Bundle.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> b a Bundle to be copied.</span><br><span class="line"> */</span></span><br><span class="line">BaseBundle(BaseBundle b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b.mParcelledData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b.mParcelledData == EMPTY_PARCEL) &#123;</span><br><span class="line">            mParcelledData = EMPTY_PARCEL;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mParcelledData = Parcel.obtain();</span><br><span class="line">            mParcelledData.appendFrom(b.mParcelledData, <span class="number">0</span>, b.mParcelledData.dataSize());</span><br><span class="line">            mParcelledData.setDataPosition(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mParcelledData = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b.mMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mMap = <span class="keyword">new</span> ArrayMap&lt;String, Object&gt;(b.mMap);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mMap = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mClassLoader = b.mClassLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码片段可以知道mParcelledData的取值有3种情况：</p>
<ul>
<li>mParcelledData = EMPTY_PARCEL</li>
<li>mParcelledData = Parcel.obtain()</li>
<li>mParcelledData = null</li>
</ul>
<p>在<code>unparcel()</code>方法中就对上述几种情况做了不同的处理，当mParcelledData为null时，直接返回；当mParcelledData为EMPTY_PARCEL时，会创建一个容量为1的ArrayMap对象；当mParcelledData为Parcel.obtain()时，则会将里面的数据读出，并创建一个ArrayMap，并将数据存储到ArrayMap对象里面，同时将mParcelledData回收并置为null，具体是由以下代码片段实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N = mParcelledData.readInt();</span><br><span class="line"><span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(<span class="keyword">this</span>))</span><br><span class="line">        + <span class="string">": reading "</span> + N + <span class="string">" maps"</span>);</span><br><span class="line"><span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">    mMap = <span class="keyword">new</span> ArrayMap&lt;String, Object&gt;(N);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mMap.erase();</span><br><span class="line">    mMap.ensureCapacity(N);</span><br><span class="line">&#125;</span><br><span class="line">mParcelledData.readArrayMapInternal(mMap, N, mClassLoader);</span><br><span class="line">mParcelledData.recycle();</span><br><span class="line">mParcelledData = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>上面只是以布尔类型的数据为例分析了Bundle的存取过程，其他数据类型的存取原理相同，就不再赘述。</p>
<h4 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h4><p>到此，Bundle的源码分析基本就结束了，其实Bundle比较简单，只是一个数据容器，不像Activity等有复杂的生命周期。对于开发者来说，只需要了解Bundle的功能、使用场景并掌握常用的数据存取方法即可。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://aspook.com/2016/07/05/Bundle源码解析/" data-id="cj094r0kx004vwj5sc2b460yi" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Bundle/">Bundle</a><a href="/tags/源码解析/">源码解析</a></div><div class="post-nav"><a href="/2016/07/05/二叉树的构建及各种遍历方式/" class="pre">二叉树的构建及各种遍历方式</a><a href="/2016/07/03/如何构建安全的Android应用/" class="next">如何构建安全的Android应用</a></div><div id="disqus_thread"><script>var disqus_shortname = 'aspook';
var disqus_identifier = '2016/07/05/Bundle源码解析/';
var disqus_title = 'Bundle源码解析';
var disqus_url = 'http://aspook.com/2016/07/05/Bundle源码解析/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//aspook.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://aspook.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithms/">Algorithms</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/GIS/">GIS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈/">杂谈</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/life/" style="font-size: 15px;">life</a> <a href="/tags/APK瘦身/" style="font-size: 15px;">APK瘦身</a> <a href="/tags/微信支付/" style="font-size: 15px;">微信支付</a> <a href="/tags/微信wap支付/" style="font-size: 15px;">微信wap支付</a> <a href="/tags/微信网页支付/" style="font-size: 15px;">微信网页支付</a> <a href="/tags/诗词/" style="font-size: 15px;">诗词</a> <a href="/tags/历史/" style="font-size: 15px;">历史</a> <a href="/tags/Web地图/" style="font-size: 15px;">Web地图</a> <a href="/tags/矢量渲染/" style="font-size: 15px;">矢量渲染</a> <a href="/tags/切片地图/" style="font-size: 15px;">切片地图</a> <a href="/tags/栅格地图/" style="font-size: 15px;">栅格地图</a> <a href="/tags/养花/" style="font-size: 15px;">养花</a> <a href="/tags/读书/" style="font-size: 15px;">读书</a> <a href="/tags/Java泛型/" style="font-size: 15px;">Java泛型</a> <a href="/tags/clone/" style="font-size: 15px;">clone</a> <a href="/tags/对象克隆/" style="font-size: 15px;">对象克隆</a> <a href="/tags/Android线程/" style="font-size: 15px;">Android线程</a> <a href="/tags/线程通信/" style="font-size: 15px;">线程通信</a> <a href="/tags/AsyncTask/" style="font-size: 15px;">AsyncTask</a> <a href="/tags/工具类/" style="font-size: 15px;">工具类</a> <a href="/tags/公有构造函数/" style="font-size: 15px;">公有构造函数</a> <a href="/tags/诗歌/" style="font-size: 15px;">诗歌</a> <a href="/tags/65536/" style="font-size: 15px;">65536</a> <a href="/tags/64K-method/" style="font-size: 15px;">64K method</a> <a href="/tags/App安全/" style="font-size: 15px;">App安全</a> <a href="/tags/Intent/" style="font-size: 15px;">Intent</a> <a href="/tags/垃圾收集算法/" style="font-size: 15px;">垃圾收集算法</a> <a href="/tags/在南下的火车上/" style="font-size: 15px;">在南下的火车上</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/第三方框架/" style="font-size: 15px;">第三方框架</a> <a href="/tags/Android适配/" style="font-size: 15px;">Android适配</a> <a href="/tags/人生信条/" style="font-size: 15px;">人生信条</a> <a href="/tags/Context/" style="font-size: 15px;">Context</a> <a href="/tags/二叉树/" style="font-size: 15px;">二叉树</a> <a href="/tags/二叉树遍历/" style="font-size: 15px;">二叉树遍历</a> <a href="/tags/深度优先遍历/" style="font-size: 15px;">深度优先遍历</a> <a href="/tags/广度优先遍历/" style="font-size: 15px;">广度优先遍历</a> <a href="/tags/非递归实现/" style="font-size: 15px;">非递归实现</a> <a href="/tags/如何看待与学习新技术/" style="font-size: 15px;">如何看待与学习新技术</a> <a href="/tags/Android架构设计/" style="font-size: 15px;">Android架构设计</a> <a href="/tags/AndroidManifest/" style="font-size: 15px;">AndroidManifest</a> <a href="/tags/activity-alias/" style="font-size: 15px;">activity-alias</a> <a href="/tags/瓦片地图/" style="font-size: 15px;">瓦片地图</a> <a href="/tags/Messenger/" style="font-size: 15px;">Messenger</a> <a href="/tags/进程间通信/" style="font-size: 15px;">进程间通信</a> <a href="/tags/LRU/" style="font-size: 15px;">LRU</a> <a href="/tags/类加载器/" style="font-size: 15px;">类加载器</a> <a href="/tags/Java内存模型/" style="font-size: 15px;">Java内存模型</a> <a href="/tags/JVM内存模型/" style="font-size: 15px;">JVM内存模型</a> <a href="/tags/Java内存分配/" style="font-size: 15px;">Java内存分配</a> <a href="/tags/Bundle/" style="font-size: 15px;">Bundle</a> <a href="/tags/源码解析/" style="font-size: 15px;">源码解析</a> <a href="/tags/内存优化/" style="font-size: 15px;">内存优化</a> <a href="/tags/高性能编码/" style="font-size: 15px;">高性能编码</a> <a href="/tags/AIDL/" style="font-size: 15px;">AIDL</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Android消息机制源码解析/" style="font-size: 15px;">Android消息机制源码解析</a> <a href="/tags/MessageQueue/" style="font-size: 15px;">MessageQueue</a> <a href="/tags/Handler/" style="font-size: 15px;">Handler</a> <a href="/tags/Looper/" style="font-size: 15px;">Looper</a> <a href="/tags/Message/" style="font-size: 15px;">Message</a> <a href="/tags/Android文件存储/" style="font-size: 15px;">Android文件存储</a> <a href="/tags/内部存储/" style="font-size: 15px;">内部存储</a> <a href="/tags/外部存储/" style="font-size: 15px;">外部存储</a> <a href="/tags/微信分享/" style="font-size: 15px;">微信分享</a> <a href="/tags/分享闭环/" style="font-size: 15px;">分享闭环</a> <a href="/tags/Android书籍推荐/" style="font-size: 15px;">Android书籍推荐</a> <a href="/tags/App生命周期/" style="font-size: 15px;">App生命周期</a> <a href="/tags/Broadcast/" style="font-size: 15px;">Broadcast</a> <a href="/tags/Android广播/" style="font-size: 15px;">Android广播</a> <a href="/tags/Android布局性能优化/" style="font-size: 15px;">Android布局性能优化</a> <a href="/tags/Android图片缓存/" style="font-size: 15px;">Android图片缓存</a> <a href="/tags/Window/" style="font-size: 15px;">Window</a> <a href="/tags/Android-Studio/" style="font-size: 15px;">Android Studio</a> <a href="/tags/Instant-Run/" style="font-size: 15px;">Instant Run</a> <a href="/tags/Instrumentation/" style="font-size: 15px;">Instrumentation</a> <a href="/tags/activity启动流程/" style="font-size: 15px;">activity启动流程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/03/07/Java类加载器及Android类加载器基础/">Java类加载器及Android类加载器基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/25/一种Android应用架构设计分享/">一种Android应用架构设计分享</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/10/Android-Instrumentation源码分析（附Activity启动流程）/">Android Instrumentation源码分析（附Activity启动流程）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/19/面对五花八门的新技术，如何看待与学习/">面对五花八门的新技术，如何看待与学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/19/App内存占用优化/">App内存占用优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/19/Android高性能编码最佳实践/">Android高性能编码最佳实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/19/Android布局性能优化指南/">Android布局性能优化指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/15/APK瘦身指南/">APK瘦身指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/27/如何配置方法数超过64K的应用/">如何配置方法数超过64K的应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/25/关于日益泛滥的Android第三方框架/">关于日益泛滥的Android第三方框架</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//aspook.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.csdn.net/ahence" title="aspook" target="_blank">aspook</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Aspook.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
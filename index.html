<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="请不要灰心，你也会有人妒忌"/>













  <link rel="alternative" href="/default" title="ASPOOK" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://aspook.com/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />






  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> ASPOOK </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">ASPOOK</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">ASPOOK</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/07/Java类加载器及Android类加载器基础/">Java类加载器及Android类加载器基础</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-03-07
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h3 id="u5F15_u5B50"><a href="#u5F15_u5B50" class="headerlink" title="引子"></a>引子</h3><p>Android插件化与热更新技术日渐成熟，当你研究这些技术时会发现类加载器在其中占据重要地位。Java语言天生就有灵活性、动态性，支持运行期间动态组装程序，而这一切的基础就是类加载器。</p>
<h3 id="Java_u4E2D_u7684_u7C7B_u52A0_u8F7D_u5668"><a href="#Java_u4E2D_u7684_u7C7B_u52A0_u8F7D_u5668" class="headerlink" title="Java中的类加载器"></a>Java中的类加载器</h3><h4 id="Java_u7075_u6D3B_u6027_u548C_u52A8_u6001_u6027_u7684_u539F_u56E0"><a href="#Java_u7075_u6D3B_u6027_u548C_u52A8_u6001_u6027_u7684_u539F_u56E0" class="headerlink" title="Java灵活性和动态性的原因"></a>Java灵活性和动态性的原因</h4><p>Java源代码被编译器编译成字节码，即从.java文件编译为.class文件，而.class文件就是通过类加载器加载到虚拟机内存中的。</p>
<p>虚拟机的类加载（Class Loading）过程分为加载、链接（验证、准备、解析）、初始化、使用、卸载等过程。这里仅考虑加载这个阶段，在此阶段虚拟机的工作有以下几点：</p>
<ol>
<li>通过一个类的全限定名来获取该类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p>注意看第1条，虚拟机规范只是说来获取一个类的二进制字节流，但并没有说从哪里获取，怎样获取，这也就意味着Class文件可以来自磁盘、ZIP文件、JAR文件、数据库、甚至来自网络或者在程序运行时动态生成。上述各种来源的Class文件都是由类加载器（Class Loader）来加载的，也正因为如此，Java才拥有高度的灵活性和动态性。</p>
<h4 id="Java_u4E2D_u7684_u51E0_u79CD_u7C7B_u52A0_u8F7D_u5668"><a href="#Java_u4E2D_u7684_u51E0_u79CD_u7C7B_u52A0_u8F7D_u5668" class="headerlink" title="Java中的几种类加载器"></a>Java中的几种类加载器</h4><p>Java中的类加载器至少有三种：</p>
<ul>
<li>启动类加载器——该加载器一般由C或C++实现（如HotSpot用C++实现，其实也有虚拟机是用Java实现的），它是作为虚拟机不可分割的一部分而存在。该加载器负责加载jre/lib中的系统类，如通常从rt.jar中进行加载。启动类加载器由于属于虚拟机的一部分，因此无法被Java程序直接引用，所以例如String.class.getClassLoader()将会返回null。</li>
<li>扩展类加载器——该加载器由Java语言实现，继承自java.lang.ClassLoader，独立于虚拟机外部，负责加载jre/lib/ext目录下的文件，如果对扩展类加载器调用getParent()也会返回null。</li>
<li>系统类加载器（或叫应用类加载器）——该加载器由Java语言实现，继承自java.lang.ClassLoader，独立于虚拟机外部，负责加载应用程序类。如果应用程序中没有自定义的类加载器，那么此加载器就是默认的类加载器。</li>
</ul>
<p>此外，用户还可以继承ClassLoader类来自定义类加载器，这样就可以在向虚拟机传递字节码之前进行需求定制了。</p>
<p>注意：对于任意一个Java类，它在虚拟机里的唯一性是由其类本身及其类加载器共同决定的。如果两个类来自同一个Class文件，在同一个虚拟机中，但是被不同的ClassLoader所加载，那么这两个类在虚拟机中也是不相等的。</p>
<h4 id="u7C7B_u52A0_u8F7D_u5668_u7684_u53CC_u4EB2_u59D4_u6D3E_u6A21_u578B"><a href="#u7C7B_u52A0_u8F7D_u5668_u7684_u53CC_u4EB2_u59D4_u6D3E_u6A21_u578B" class="headerlink" title="类加载器的双亲委派模型"></a>类加载器的双亲委派模型</h4><p>先来看下Java中的类加载器层次关系：</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/image/java_classloader.jpg" alt=""></p>
<p>上述层次关系称为类加载器的双亲委派模型，它是在JDK 1.2中引入的，其实它并非强制性的约束，而是推荐我们使用的一种类加载机制，可以看到除了顶部的启动类加载器之外，其他加载器都有一个父类加载器。</p>
<p>双亲委派模型的工作流程：当一个类收到加载类的请求时，它自己先不进行加载，而是把该请求委派为父类加载器去完成，父类加载器也是如此，直到将加载类的需求传给顶层的启动类加载器；只有当父类加载器无法完成加载时（在自己的搜索范围中没有找到该类），子加载器才尝试自己去完成类加载，如果加载不了，则会抛出ClassNotFoundException异常。</p>
<p>有一点需要注意：如果扩展类加载器收到请求去加载一个类，它会先委托启动类加载器去加载，如果启动类加载器加载不了，则尝试自己加载。如果扩展类加载器也无法加载，则直接抛出ClassNotFoundException异常而结束，并不会再交给下一层的应用类加载器去加载。</p>
<p>说明了双亲委派模型的原理后，再来看下其源码实现，代码逻辑很简单，也证实了上述讲到的双亲委派模型的工作流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 首先判断该类是否已经被加载过，如果已加载过就直接返回</span></span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没有被加载，就委托给父加载器处理或者给启动类加载器处理</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果存在父类加载器，就委派给父类加载器加载  </span></span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果不存在父类加载器，就检查是否由启动类加载器加载  </span></span><br><span class="line">                <span class="comment">// 通过调用native方法 findBootstrapClass0(String name)  </span></span><br><span class="line">                c = findBootstrapClass0(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 如果父加载器和启动类加载器都不能完成加载任务，自身才尝试去加载</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u53CC_u4EB2_u59D4_u6D3E_u6A21_u578B_u7684_u610F_u4E49"><a href="#u53CC_u4EB2_u59D4_u6D3E_u6A21_u578B_u7684_u610F_u4E49" class="headerlink" title="双亲委派模型的意义"></a>双亲委派模型的意义</h4><p>使用双亲委派模型来组织各种类加载器，使之遵循了一定的优先级层次，从而能保证Java运行环境的稳定与条理性。例如java.lang.Object类是所有类的基类，并且根据双亲委派模型它是由启动类加载器加载的，如果我们也自定义了一个java.lang.Object类（只是假如，其实虚拟机会对java.lang开头的自定义类抛异常）并放在应用程序的ClassPath中去加载，那么应用中就会出现多个Object类，从而会导致Java类型体系混乱而无法正常运行。</p>
<p>另一个好处是避免类的二次加载。从上述loadClass源码中可知，先判断该类是否被加载过，如果已被加载过则直接返回该类。当一个类加载器委托父类加载时也是执行此逻辑，从而保证某些类只被加载一次。</p>
<h4 id="u81EA_u5B9A_u4E49_u7C7B_u52A0_u8F7D_u5668"><a href="#u81EA_u5B9A_u4E49_u7C7B_u52A0_u8F7D_u5668" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><p>由于自定义类加载器通常继承ClassLoader，来看下ClassLoader的几个主要方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载指定完整名称的二进制字节流，不建议子类加载器重写，否则可能会破坏双亲委派模型</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载指定完整名称的二进制字节流，不建议子类加载器重写，否则可能会破坏双亲委派模型</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被loadClass方法调用去加载指定名称类，官方建议子类加载器重写该方法</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法将二进制字节流转换为Class,一般在findClass方法中读取到对应字节码后调用，由于是final方法，故不可继承，其功能具体由虚拟机实现，Java层不需要关心</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len) <span class="keyword">throws</span> ClassFormatError&#123; … &#125;</span><br></pre></td></tr></table></figure>
<p>上述几个方法的说明可参考注释。</p>
<p>为了遵循双亲委派模型，当自定义类加载器时，官方建议我们仅仅重写findClass()方法，而不要重写loadClass()方法，否则就有可能破坏双亲委派模型。当然前面也说了，双亲委派模型并非强制约束，如有特别需要，也可以自行确定类的加载规则。一个典型的自定义类加载器如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 获取类的字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ……</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可知类加载器的各个方法的执行顺序为：loadClass—&gt;findClass—&gt;defineClass。</p>
<h3 id="Android_u4E2D_u7684_u7C7B_u52A0_u8F7D_u5668"><a href="#Android_u4E2D_u7684_u7C7B_u52A0_u8F7D_u5668" class="headerlink" title="Android中的类加载器"></a>Android中的类加载器</h3><p>Android应用通常是使用Java来开发的，也是运行在虚拟机Dalvik或ART上。虽然Android的虚拟机跟标准的Java虚拟机是不同的，但是类的加载机制都是类似的，即理论上Android也可以像Java程序一样，灵活地动态加载，如今大量的Android插件化、热更新框架都利用了此技术。</p>
<h4 id="Android_u4E2D_u7684_u51E0_u79CD_u7C7B_u52A0_u8F7D_u5668"><a href="#Android_u4E2D_u7684_u51E0_u79CD_u7C7B_u52A0_u8F7D_u5668" class="headerlink" title="Android中的几种类加载器"></a>Android中的几种类加载器</h4><p>在一个Android工程的Application中加入几行日志来打印下，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aspook.androidnotes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">        ClassLoader loader = getClassLoader();</span><br><span class="line">        <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.d(<span class="string">"ABC"</span>, <span class="string">"classLoader :"</span> + loader);</span><br><span class="line">            <span class="keyword">while</span> (loader.getParent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                loader = loader.getParent();</span><br><span class="line">                Log.d(<span class="string">"ABC"</span>, <span class="string">"classLoader :"</span> + loader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Android Studio中启动App后，依次输出3条Log如下：</p>
<blockquote>
<p>classLoader :dalvik.system.PathClassLoader[DexPathList[[zip file “/data/app/com.aspook.androidnotes-2/base.apk”],nativeLibraryDirectories=[/data/app/com.aspook.androidnotes-2/lib/arm64, /vendor/lib64, /system/lib64]]]<br>classLoader :com.android.tools.fd.runtime.IncrementalClassLoader@3faf711<br>classLoader :java.lang.BootClassLoader@d913983</p>
</blockquote>
<p>这里出现了3种ClassLoader，分别是：dalvik.system.PathClassLoader、com.android.tools.fd.runtime.IncrementalClassLoader、java.lang.BootClassLoader。第二个类加载器是用于Instant Run的，如果关闭Android Studio的Instant Run功能，再运行App则只会输出两种ClassLoader。</p>
<p>通过查看dalvik.system包下的源码，发现还有一种ClassLoader叫做DexClassLoader，稍后会介绍其用途。</p>
<h5 id="PathClassLoader"><a href="#PathClassLoader" class="headerlink" title="PathClassLoader"></a>PathClassLoader</h5><p>其官方说明如下：</p>
<blockquote>
<p>Provides a simple <code>ClassLoader</code> implementation that operates on a list of files and directories in the local file system, but does not attempt to load classes from the network. Android uses this class for its system class loader and for its application class loader(s).</p>
</blockquote>
<p>PathClassLoader是ClassLoader的简单实现且只能加载本地的列表文件或目录，在Android中也就是已安装好的APK，它不能加载来自网络的类。Android中的系统类加载器与应用类加载器都是PathClassLoader。</p>
<p>先来看其源码（7.0）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dalvik.system;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dalvik.system.BaseDexClassLoader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述源码可知其仅仅提供了两个构造方法，其中各参数的具体含义如下：</p>
<p>dexPath：包含dex文件的JAR/ZIP/APK文件的路径</p>
<p>librarySearchPath：native library文件的路径</p>
<p>parent：父类加载器</p>
<p>再来看BaseDexClassLoader的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dalvik.system;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> URL <span class="title">findResource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Enumeration&lt;URL&gt; <span class="title">findResources</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Package <span class="title">getPackage</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BaseDexClassLoader构造方法中有一个新的参数为optimizedDirectory，它表示优化后的dex文件要写入的路径，此处可以为null。</p>
<p>BaseDexClassLoader继承自java.lang.ClassLoader，它跟纯Java环境下的java.lang.ClassLoader还是有些不同的，虽然双亲委派的加载机制类似。</p>
<p>结合最初的Log输出可知，PathClassLoader只能加载”/data/app/com.aspook.androidnotes-2/base.apk”中的类，也就是已安装到手机中的APK，因此PathClassLoader作为默认的应用类加载器。</p>
<h5 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h5><p>其官方说明如下：</p>
<blockquote>
<p>A class loader that loads classes from <code>.jar</code> and <code>.apk</code> files containing a <code>classes.dex</code> entry. This can be used to execute code not installed as part of an application.</p>
</blockquote>
<p>DexClassLoader可以从包含dex文件的JAR或APK中来加载类，而这些代码源允许不必是安装应用的一部分，因此可用于动态加载。</p>
<p>先来看下DexClassLoader的源码（7.0）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dalvik.system;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dalvik.system.BaseDexClassLoader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它同样继承自BaseDexClassLoader，是java.lang.ClassLoader的子类，因此DexClassLoader与PathClassLoader都默认遵循双亲委派模型。</p>
<p>DexClassLoader构造方法中的参数，我们前文都已经提及，注意的一点是optimizedDirectory参数在这里不能为null。</p>
<p>与PathClassLoader不同，DexClassLoader则打破了PathClassLoader的局限，它可以加载已安装应用之外的APK、JAR或ZIP中的dex文件，通常建议使用如下路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File dexOutputDir = context.getCodeCacheDir();</span><br></pre></td></tr></table></figure>
<p>不建议使用外部存储，因为外部存储没有提供足够的访问权限控制，容易引发代码注入攻击。</p>
<p>因此，Android中实现动态插件通常是自定义继承自DexClassLoader的类加载器；如果插件为已安装的APK，则可以使用PathClassLoader。</p>
<h5 id="BootClassLoader"><a href="#BootClassLoader" class="headerlink" title="BootClassLoader"></a>BootClassLoader</h5><p>BootClassLoader直接继承自java.lang.ClassLoader，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BootClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BootClassLoader instance;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@FindBugsSuppressWarnings</span>(<span class="string">"DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> BootClassLoader <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> BootClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BootClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> Class.classForName(name, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> URL <span class="title">findResource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> VMClassLoader.getResource(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Enumeration&lt;URL&gt; <span class="title">findResources</span><span class="params">(String resName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.enumeration(VMClassLoader.getResources(resName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Package <span class="title">getPackage</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; !name.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                Package pack = <span class="keyword">super</span>.getPackage(name);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pack == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pack = definePackage(name, <span class="string">"Unknown"</span>, <span class="string">"0.0"</span>, <span class="string">"Unknown"</span>, <span class="string">"Unknown"</span>, <span class="string">"0.0"</span>,</span><br><span class="line">                            <span class="string">"Unknown"</span>, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> pack;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> URL <span class="title">getResource</span><span class="params">(String resName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findResource(resName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String className, <span class="keyword">boolean</span> resolve)</span><br><span class="line">           <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = findClass(className);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;URL&gt; <span class="title">getResources</span><span class="params">(String resName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findResources(resName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常在自定义类加载器时，都需要在构造方法中传入一个父加载器，而BootClassLoader的构造方法如下，没有传入parent，而是传入一个null：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BootClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此调用BootClassLoader的getParent方法时返回值为null。</p>
<p>BootClassLoader用来加载系统框架级别的类，例如Context.class.getClassLoader()与ListView.class.getClassLoader()的返回值类型均为BootClassLoader。</p>
<h5 id="u7CFB_u7EDF_u7C7B_u52A0_u8F7D_u5668"><a href="#u7CFB_u7EDF_u7C7B_u52A0_u8F7D_u5668" class="headerlink" title="系统类加载器"></a>系统类加载器</h5><p>当调用<code>ClassLoader.getSystemClassLoader()</code>这句代码时，会输出如下结果：</p>
<blockquote>
<p>dalvik.system.PathClassLoader[DexPathList[[directory “.”],nativeLibraryDirectories=[/vendor/lib64, /system/lib64]]]</p>
</blockquote>
<p>发现系统类加载器也是dalvik.system.PathClassLoader，与最初应用的类加载器（也是dalvik.system.PathClassLoader）不同的是DexPathList的路径不同。</p>
<p>跟踪一下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SystemClassLoader.loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ClassLoader loader = ClassLoader.createSystemClassLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Encapsulates the set of parallel capable loader types.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ClassLoader <span class="title">createSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String classPath = System.getProperty(<span class="string">"java.class.path"</span>, <span class="string">"."</span>);</span><br><span class="line">    String librarySearchPath = System.getProperty(<span class="string">"java.library.path"</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String[] paths = classPath.split(":");</span></span><br><span class="line">    <span class="comment">// URL[] urls = new URL[paths.length];</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; paths.length; i++) &#123;</span></span><br><span class="line">    <span class="comment">// try &#123;</span></span><br><span class="line">    <span class="comment">// urls[i] = new URL("file://" + paths[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// catch (Exception ex) &#123;</span></span><br><span class="line">    <span class="comment">// ex.printStackTrace();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// return new java.net.URLClassLoader(urls, null);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO Make this a java.net.URLClassLoader once we have those?</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而System.getProperty(“java.class.path”)返回值为“.”，似乎可以解释系统类加载器的DexPathList的路径了。</p>
<h4 id="Android_u4E2D_u7C7B_u52A0_u8F7D_u5668_u7684_u5C42_u6B21_u7ED3_u6784"><a href="#Android_u4E2D_u7C7B_u52A0_u8F7D_u5668_u7684_u5C42_u6B21_u7ED3_u6784" class="headerlink" title="Android中类加载器的层次结构"></a>Android中类加载器的层次结构</h4><p>与Java中类加载器的层次结构类似，具体如下图：</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/image/android_classloader.jpg" alt=""></p>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>本文简单介绍了类加载器的基本概念，罗列了Java及Android中常用的类加载器，并对各种类加载器的特点及功能做了说明，另外对类加载器的双亲委派机制做了详细讲解，对于Android插件化及热更新技术则不在本文的讨论之内，后续会继续分享。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/02/25/一种Android应用架构设计分享/">一种Android应用架构设计分享</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-02-25
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>技术发展日新月异，业界各种Android客户端架构设计，五花八门，但我们不能简单地说哪种架构更好，因为脱离业务谈架构是没有任何意义的，适合业务的才是好架构。而架构也不是一成不变的，随着业务的发展，也许当初设计的架构已不足以支撑目前的业务，那么就需要改变之前的架构。接下来将分享下我们Android客户端的架构设计，在App的某个业务发展阶段或许有一些参考意义。</p>
<h3 id="u5206_u5C42_u5316_u4E0E_u6A21_u5757_u5316"><a href="#u5206_u5C42_u5316_u4E0E_u6A21_u5757_u5316" class="headerlink" title="分层化与模块化"></a>分层化与模块化</h3><p>分层化与模块化应该是任何软件开发的共识。</p>
<h4 id="u5206_u5C42_u5316"><a href="#u5206_u5C42_u5316" class="headerlink" title="分层化"></a>分层化</h4><p>在Android应用开发中通常可以分为如下几层：</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/image/layer_module.jpg" alt=""></p>
<ul>
<li><p>SDK层：主要是Android SDK及第三方的SDK（可能基于Android SDK或为独立的SDK），这些SDK为上层框架提供核心功能的支持。</p>
</li>
<li><p>基础框架层：这里所谓的基础框架，指多数App都必需的基础功能，是具体业务逻辑实现的基础。主要有网络请求功能、图片加载与缓存功能、SQLite数据库管理功能、Log管理功能等，当然根据对业务逻辑支持的不同，基础框架层的功能支持也不一定相同，上述几个应该是大部分App都要支持的，当然Crash监控与常用工具类也可归为该层次。</p>
<p>具体到每个基础框架的实现则没有任何限制，如网络功能可以使用Volley、OkHttp或者自己封装实现网络请求逻辑；对于图片管理功能则可以使用Glide、Fresco、Picasso，亦或自己实现……总之每个基础框架都要遵循一定的实现原则，保持功能模块的独立性，与具体业务解耦并对外提供良好的交互接口。</p>
</li>
<li><p>业务逻辑层：如果把App架构比作高层建筑，那么上述两层就是地基。地基打好之后，就可以在上面任意发挥了，至于如何发挥，那就必须结合实际的业务需求，不同的应用往往有不同的业务功能模块。</p>
<p>另一方面，业务功能模块也并非完全是并列的级别，有一些业务逻辑也是可以抽象出来的，作为通用的功能模块，比如登录、分享、扫描、统计等，其他的业务模块可能会调用到这些功能。</p>
</li>
</ul>
<p>这里需要注意的是SDK层与基础框架层并不是一成不变的，但它们的变化周期往往是比较长的，一般来说当基础功能不能满足最上层的业务逻辑时，就需要对其做扩展。由于基础框架层的功能模块已经是功能级别的粒度划分，因此扩展往往是模块级别的扩展，通常是新增基础功能框架而不是修改原有基础功能框架，这也符合“开放-闭合”原则。</p>
<h4 id="u6A21_u5757_u5316"><a href="#u6A21_u5757_u5316" class="headerlink" title="模块化"></a>模块化</h4><p>至于模块化，对于分层化来说则是更细粒度的划分，即将每一层细分为不同的模块，各功能模块尽可能遵循“高内聚、低耦合”的原则，功能模块之间仅提供必要的交互接口。</p>
<p>对于基础框架层，由上图可见，往往是根据功能来划分。这里的基础框架层细分为网络支持功能、图片库、日志系统、数据库支持等模块，如果不足以支撑业务发展，可能会新增其他基础功能模块。</p>
<p>而业务逻辑层则主要由业务需求来决定，如分为扫描功能、电商、快递查询等模块。业务逻辑层的模块化还有一种驱动因素，那就是通用功能的封装，这一点大家应该都有体会，随着App业务逻辑的增加，不同业务功能之间可能会用到相同的功能，如用户登录、分享功能等，我们不希望在每个需要的地方都复写一遍相关代码，于是就需要把通用功能抽取成独立于具体业务需求的模块，如登录模块、分享模块，在模块内部实现通用的业务逻辑，同时对外暴露调用接口，不同的业务只需调用通用模块即可。</p>
<h3 id="u4E1A_u52A1_u6570_u636E_u6D41_u7A0B_u8BBE_u8BA1"><a href="#u4E1A_u52A1_u6570_u636E_u6D41_u7A0B_u8BBE_u8BA1" class="headerlink" title="业务数据流程设计"></a>业务数据流程设计</h3><p>由于业务逻辑、数据处理逻辑或网络框架的不同，相信各家应用都有自己的一套数据请求流程。最直接的就是从Activity或Fragment中调用网络请求的方法，然后通过回调将结果返回到Activity或Fragment中，虽然流程最清晰，但这种方式存在几个严重的问题：</p>
<ul>
<li>网络数据直接返回到Activity或Fragment中，后续需要对数据进行解析、过滤、转换、缓存等操作，这些工作将会大大加重Activity或Fragment的负担。</li>
<li>Activity或Fragment的代码量猛增，逻辑繁杂（不仅包含了View的逻辑还包含了数据处理的逻辑）</li>
<li>从整个应用的角度来看，每个页面甚至每个接口都需要重复上述相同的冗余工作，完全可以抽象出来。</li>
</ul>
<p>上述设计思路是需要摒弃的，结合自身业务及架构演化，我们没有跟风MVP、MVVM，而是设计了下面一套业务数据请求流程：</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/image/DataReq.jpg" alt=""></p>
<p>首先，视图层通常表现为Activity或Fragment，并由视图层发起数据请求，与上述不同，视图层并不直接跟网络框架打交道，而是先将数据请求发送到数据代理层DataAgent。需要注意到是，视图层与数据代理层之间没有采用直接通信的方式，而是插入了一个消息调度器MessageScheduler中转。这样做的好处是将视图层与数据代理层解耦，视图层无需关注数据代理层的具体实现，有了MessageScheduler，视图层所要做的就是发出一个数据请求的消息而已，然后就可以静静等待一个回复消息，该回复消息会附带最终需要的数据对象，这样在视图层就免除了数据处理的逻辑，拿到结果直接展示到UI上即可。使用这种方式，一般来讲Activity或Fragment三五百行代码即可搞定，UI逻辑或接口逻辑（如一个页面有多个接口）比较复杂的代码量基本也能控制在1000行左右，逻辑非常清爽。</p>
<p>消息调度器将视图层的请求消息转发到数据代理层后，DataAgent解析出数据请求类型DataType（该类型对应着具体数据对象模型）、必要参数（接口参数、是否需要缓存结果、分页页码等），然后再执行具体的操作：</p>
<ul>
<li>如果要取缓存的数据，则DataAgent直接向缓存模块发送请求。缓存的数据可以是初始JSON数据，也可以是解析处理后得到的数据对象Model，可根据具体需求配置。如果从缓存中取到的是JSON，则DataAgent先要解析处理得到对应Model；如果从缓存中取到的是Model，则不做处理，然后将Model封装发回到消息调度器，再由MessageScheduler分发给具体的请求者，如Activity或Fragment。</li>
<li>由于Android的数据来源有多种，如果数据来自持久化存储，如SQLite或File等，仍然统一由DataAgent来跟它们通信，获取数据并加工后通过MessageScheduler发回视图层。</li>
<li>最常见的是从服务器获取数据，此种场景下，DataAgent将与网络框架交互，将从MessageScheduler中获取的参数提供给网络框架构造请求url。至于网络框架使用Volley或OkHttp或者其他都没关系，网络框架负责向Server请求数据，数据通常以JSON格式返回。DataAgent收到返回的JSON数据后，根据DataType将JSON数据校验后抛给解析器，解析器会将JSON解析为视图层需要的Model。当然数据解析过程可能伴随数据的过滤、转换等逻辑。另外需要注意的是，还需要根据视图层需求对数据进行是否缓存的操作，可选择缓存JSON还是Model。经过一系列操作，得到最终Model后，DataAgent将其通过MessageScheduler发回视图层。</li>
</ul>
<p>当然，由于数据请求流程是耗时的，因此上述步骤都是走的线程池，这点上图中并未注明。</p>
<h3 id="u6570_u636E_u4EE3_u7406_u5C42"><a href="#u6570_u636E_u4EE3_u7406_u5C42" class="headerlink" title="数据代理层"></a>数据代理层</h3><p>DataAgent在上文中已简单提及，它的主要作用是对数据的一系列操作，包括实际的数据请求、数据解析处理、数据缓存等逻辑。下图为从服务端接口获取JSON数据并处理的流程：</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/image/DataAgent.jpg" alt=""></p>
<p>从上图可知，DataAgent的大致工作流程为：</p>
<ol>
<li>DataAgent将真正的数据请求发送给各数据源，数据源可能为缓存、SQLite或文件，但通常是从服务端获取数据，因此DataAgent会将数据请求发到网络框架层，然后等待数据返回。</li>
<li>由于数据源不同，返回数据也可能不同，这里简化为两种：原始JSON或Model。</li>
<li>DataAgent拿到数据后，则开始数据处理流程。以从网络请求的JSON数据为例，先对返回的JSON进行数据校验，检查数据的有效性与正确性，如果数据校验通过，接下来根据需求来决定要不要写入缓存，然后再进行数据加工（如精度处理、数据拼接、数据裁剪等），最后进行数据解析得到视图层需要的Model。如果数据校验没有通过，则尝试从缓存中读取，从缓存中读取后也需要校验（检查数据的时效性、有效性、正确性），校验通过后同样进行数据处理、解析等流程。如果缓存中读取得到的就是Model，那么则可以省略数据处理和解析的流程。得到最终的Model后，DataAgent将其包装发送给MessageScheduler。另外DataAgent还要具有一定的容错功能，因为任何数据源都无法保证能够返回合法的数据，如果不对数据错误进行容错处理，那么就可能无法解析为对应的Model，从而导致视图层无数据甚至异常。如果接口及缓存都无法返回正确的数据，DataAgent需要做特殊处理，以保证视图层能给用户以反馈。</li>
</ol>
<h3 id="u4E1A_u52A1_u89C6_u56FE_u903B_u8F91"><a href="#u4E1A_u52A1_u89C6_u56FE_u903B_u8F91" class="headerlink" title="业务视图逻辑"></a>业务视图逻辑</h3><p>虽然不同的业务页面有不同的视图逻辑，这里以一个应用中最常见的页面为例来说明，假设该页面有一个列表。大家都知道ListView（此处为泛指，可能大家都在用RecyclerView了）的工作方式，它需要ViewHolder来填充视图，需要Adapter来填充数据，如果每个需要ListView的界面都维护各自的一套ViewHolder及Adapter，那么页面逻辑又将变得臃肿。</p>
<p>我们在实践中是这样做的：</p>
<ul>
<li>封装一个Adapter公共处理类，提供多种构造函数，其中有一个type参数，用来标明需要使用哪个ViewHolder。</li>
<li>封装一个ViewHolder抽象类，定义数据设置的逻辑，并交由具体的ViewHolder实现。</li>
<li>构建一个叫做ViewHolderFactory的类，顾名思义该类主要作用是用来构建ViewHolder，它主要提供两个方法<code>createViewHolder（）</code>与<code>createConvertView（）</code>，其中<code>createConvertView（）</code>是个中间方法，用于生成ViewHolder。</li>
<li>在Adapter的getView方法中，根据上述type参数，获取具体的ViewHolder实现，调用设置数据的逻辑。</li>
</ul>
<p>经过上述封装之后，视图层只需要向Adapter公共处理类传入一个type参数即可得到对应的Adapter；等数据返回到视图层后，再将数据传给Adapter公共处理类，其他什么都不用管，就可以展示列表数据了。原本需要很多代码实现的逻辑从视图层抽离之后，视图层只需要几行代码就能够完成一个列表展示了。</p>
<h3 id="Hybrid_u6846_u67B6"><a href="#Hybrid_u6846_u67B6" class="headerlink" title="Hybrid框架"></a>Hybrid框架</h3><p>自Android诞生以来，就有Native App与Web App之争，这两种开发方式虽然各有优缺点，但Native App一直占据上风。近一两年来，移动应用中的Web页面越来越多，而纯Native的应用则相对越来越少。但是纯Web App由于其渲染效率、性能问题、对硬件的调用限制导致其也并未广泛地应用。于是一种折中的方案成为主流，即Hybrid App。</p>
<p>所谓Hybrid App，即混合开发方式，部分功能使用Native开发，部分功能使用H5开发。为了充分利用Web开发的优点并避开其缺点，并非所有业务功能都适合使用Web方式来开发。在我们的应用中，主要将H5用于以下方面：</p>
<ul>
<li>节日活动或游戏页、秒杀或团购页等具有时效性的页面。</li>
<li>使用说明、公告等偏展示、少交互的页面。</li>
<li>经常更新、交互较少且不涉及硬件调用的页面或模块，如电商商品首页展示、积分兑换模块。</li>
</ul>
<p>截止到目前，我们App中的Web页所占比重是上升的，大概占到所有功能的25%左右。使用Web开发的优势非常明显，可以支持多变的UI视图效果、节省开发人力（Android、iOS共用）、Bug的在线修复而不用App发版等。</p>
<p>为了满足App的Web页面需求，于是我们在基础框架层扩展了一个Hybrid功能模块。该框架主要是自行封装了Android原生的WebView控件，且分为不同层级的封装，可根据需要灵活使用，核心功能及特性如下：</p>
<ul>
<li>支持完整的Web页面，即整个页面的内容全部是H5实现，外部容器为Activity或Fragment。</li>
<li>支持局部的Web页面，即部分页面的内容是H5实现，可单独使用自定义的WebView或者嵌入Fragment使用。</li>
<li>定义了一套较为完整的交互协议，支持Native与JS的互相调用，典型的场景如H5页面点击跳转Native功能页面（支持传参）、JS唤起Native对话框或Toast等，同时Java也能调用JS函数。基于此套交互协议，基本能够满足日常App中Web开发需求。</li>
<li>避免了JS注入漏洞。</li>
<li>支持同一个Web页面中Http与Https混合的场景。</li>
<li>向业务逻辑层暴露接口，可根据需求定制WebViewClient与WebChromeClient。</li>
<li>对外提供接口，可根据需求控制缩放、Cookie管理、缓存管理、硬件加速等。</li>
<li>经过试验与摸索，兼容多种Android设备及版本。</li>
</ul>
<p>虽然后来出现了React Native，但由于学习成本及其Android版本的局限性，结合我们自己团队的人力资源原因，我们尚未在应用中正式使用。目前仍然以Hybrid开发为主，且其在整个应用中的比重越来越大，因此Hybrid框架是我们架构中重要的一个组成部分。</p>
<h3 id="u6D88_u606F_u8C03_u5EA6_u4E2D_u5FC3"><a href="#u6D88_u606F_u8C03_u5EA6_u4E2D_u5FC3" class="headerlink" title="消息调度中心"></a>消息调度中心</h3><p>前面业务数据流程的设计中，在视图层与数据代理层之间插入了一个消息调度器——MessageScheduler，MessageScheduler主要功能就是管理消息及消息调度。</p>
<p>MessageScheduler核心原理是维护了一个哈希表，当收到视图层的数据请求时就使用唯一的key将发起者保存到哈希表中，以便稍后收到DataAgent的返回数据后，能够找到发起者。存储好消息发起者的信息后，即向DataAgent发送数据请求，多个数据请求是可以并行的，主要在于线程池的线程数控制机制。DataAgent返回数据之后，MessageScheduler根据唯一key找到初始的请求者，同样利用消息机制将请求结果返回给视图层，同时在哈希表中清除该元素。其示意图如下：</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/image/MessageScheduler.jpg" alt=""></p>
<h3 id="u6D88_u606F_u5206_u53D1_u5668"><a href="#u6D88_u606F_u5206_u53D1_u5668" class="headerlink" title="消息分发器"></a>消息分发器</h3><p>既然有了消息调度机制，就需要消息分发器MessageDispatcher，来负责发送消息。</p>
<p>MessageDispatcher本质上是利用了Android的消息机制来对业务需求进行封装和扩展。看过Android Framework层源码就会发现其实Android框架本身就有很多地方使用了消息机制来进行通信，Android消息机制可以在模块页面间、线程间通信，甚至可以在进程间使用Messenger通信（Messenger方式是利用了消息机制，当然还有其他进程间通信方式）。</p>
<p>MessageDispatcher功能比较简单，支持两种方式：</p>
<ul>
<li>点对点的通信，如两个页面之间，通信目标唯一，如上文提到的从视图层发送数据请求消息到消息调度器。</li>
<li>点对面的通信，类似于广播，也有点像EventBus，一条消息发出，凡是注册（或叫订阅）过的页面都能收到通知；也可以进一步通过Tag控制达到一对一发送。</li>
</ul>
<p>其示意图如下：</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/image/MessageDispatcher.jpg" alt=""></p>
<h3 id="u6A21_u5757_u8DEF_u7531_u4E2D_u5FC3"><a href="#u6A21_u5757_u8DEF_u7531_u4E2D_u5FC3" class="headerlink" title="模块路由中心"></a>模块路由中心</h3><p>一个完整的应用中，免不了模块之间、功能页面之间的跳转。当然在需要的地方通过Intent可以实现跳转，但这不是一个好的方案，很明显不同模块或页面之间的耦合度增加了。而我们的原则是模块和页面之间尽可能解耦，于是设计了一个模块路由（Module Routing）中心，App中所有的页面跳转均由其控制。</p>
<p>模块路由的核心原理是给功能页面进行唯一编码，编码的逻辑可以跟随产品版本定义到应用中，并保证兼容之前版本。这样就可以在应用的任何地方只需要向模块路由中心发送对应模块页面的编码即可，由模块路由负责打开目标页面。</p>
<p>以下几点需要注意：</p>
<ul>
<li>整个应用中的功能页编码都必须保证唯一</li>
<li>如打开某些功能页面除了具体编码外，还可能需要额外参数。如打开商品详情页，除了知道商品详情页的编码外，还需要商品ID，模块路由需要对附加参数提供支持。</li>
<li>模块路由支持打开Web页面，即Hybrid页面也支持上述特定编码，所以在Web页面上点击跳转Native页面使用的协议也是由模块路由支持的。</li>
</ul>
<p>使用模块路由的好处有：</p>
<ul>
<li>大量减少应用中的跳转Intent</li>
<li>模块之间、页面之间解耦</li>
<li>适配变化，统一管理，修改方便</li>
</ul>
<h3 id="u5176_u4ED6"><a href="#u5176_u4ED6" class="headerlink" title="其他"></a>其他</h3><h4 id="u65E5_u5FD7_u7CFB_u7EDF"><a href="#u65E5_u5FD7_u7CFB_u7EDF" class="headerlink" title="日志系统"></a>日志系统</h4><p>在开发过程中，甚至运行过程中，日志都是很重要的一部分。当然Android提供了Log相关的API，但不建议这一行那一行地零星使用，否则如果想统一控制Tag或关闭Log时非常麻烦。建议对Log API进行简单封装或者使用现有第三方Log库，将Log功能独立出来，提供统一的调用接口、级别控制、开关控制，这样既方便调试也方便管理，同时也能为整个应用代码的清晰做出一点贡献。</p>
<h4 id="u7EBF_u4E0A_u5D29_u6E83_u76D1_u63A7"><a href="#u7EBF_u4E0A_u5D29_u6E83_u76D1_u63A7" class="headerlink" title="线上崩溃监控"></a>线上崩溃监控</h4><p>对线上应用的Crash监控是提高应用稳定性、优化应用性能的一个重要方法。我们构建了一个小型的全局监控系统，主要由以下功能特性：</p>
<ul>
<li>对用户不可见，用户无感知</li>
<li>全局注册即可开启监控</li>
<li>捕捉线上崩溃，保存到本地文件</li>
<li>线上崩溃信息按一定策略上传服务器，上传后同时删除本地文件</li>
<li>崩溃信息主要包括Android设备信息（如手机型号、系统版本等）、App版本号、异常信息等</li>
</ul>
<p>服务器收到上传的线上崩溃信息后，也按一定策略通过邮件方式通知到开发者，以便开发者及时修复异常。线上崩溃监测系统虽然小而简单，但作用非常重要，利用线上崩溃反馈可以有效地提高应用的稳定性，建议在应用设计中务必给它留出一个位置。</p>
<h4 id="u7EDF_u8BA1_u7CFB_u7EDF"><a href="#u7EDF_u8BA1_u7CFB_u7EDF" class="headerlink" title="统计系统"></a>统计系统</h4><p>相信大部分应用都有统计分析后台，可以统计应用的日活、PV、UV或其他用户行为，也可能有一部分应用是使用的第三方统计功能，如友盟等。结合公司BI部门的统计需求，我们客户端自行设计了一套统计方案，用于Android与iOS两个客户端。之所以不用第三方统计，主要是因为我们无法根据需求自由定制且数据不在自家服务器，另一方面也有些许数据泄露的风险。</p>
<p>基于客户端的统计系统主要包括三个方面的功能：</p>
<ul>
<li>数据采集</li>
<li>数据存储</li>
<li>数据上传</li>
</ul>
<p>对于数据采集，主要针对统计部门的需求，如采集设备信息、定位信息、App启动时间次数、PV、UV、甚至用户行为，如点击、切换Tab、页面流向跟踪等。</p>
<p>为了避免每次采集完数据后就即时上传，因此需要数据存储，将采集的统计数据暂存到本地，一般使用SQLite。然后采用一定策略进行上传，如数据累积到50条或者应用切换到后台时进行上传。</p>
<p>对于数据上传，除了上传时机的选择策略外，还要遵循一定的结构字段，该结构可以根据数据统计部门的需求来定义。数据上传的流程同样可以使用之前的数据请求框架，只不过返回值可能为一个成功提示而已。</p>
<p>基于上述功能，我们自定义的统计功能模块提供了方便的调用接口，并支持灵活扩展，目前可以完美支持日常的统计需求，调用也非常简单，只需要在需要统计的地方插入一行代码即可。</p>
<h4 id="u57DF_u540D_u52AB_u6301_u5E94_u5BF9_u7B56_u7565"><a href="#u57DF_u540D_u52AB_u6301_u5E94_u5BF9_u7B56_u7565" class="headerlink" title="域名劫持应对策略"></a>域名劫持应对策略</h4><p>最近遇到域名劫持的问题，真是头疼，另一方面也说明我们的流量引起运营商注意了。目前主流的有几下几种方案：</p>
<ul>
<li>向运营商投诉。此方法非常被动且效果不佳，完全掌控在运营商手中。</li>
<li>使用httpDNS。此方法使用http的方式直接获取最优IP，绕过localDNS的解析，可谓彻底解决了域名劫持。</li>
<li>先使用域名尝试，域名失败后再使用IP尝试。此方案属于容灾方案，并不能避免域名劫持。</li>
</ul>
<p>理论上讲第二种是最佳方案，但由于httpDNS为第三方服务，也无法保证效果，外加上付费及接入成本等因素，我们暂时采用了第三种容灾方案，主要实施逻辑如下：</p>
<ol>
<li>应用预先内置IP。</li>
<li>每次启动应用时获取最新IP，并保存到应用本地。</li>
<li>请求数据时，先使用域名走正常的逻辑，一旦遇到疑似劫持的问题后，使用本地的IP进行直连尝试。</li>
</ol>
<p>上述步骤其实是有漏洞的，比如启动时获取最新IP的接口如果被劫持了，那么就无法获取最新IP，假如刚好同时服务器IP也改变了，因此预先内置的IP已经失效，此时就彻底没办法了。不过上述两个条件同时满足的概率比较小，因此可以使用该方案解决很大一部分域名劫持问题。另外从服务端获取的IP，如果有多个的话，还需要增加一些策略，即考虑到负载均衡、访问速度、稳定性、网络运营商等因素，如何确定客户端拿到的哪一个是最优IP，当然这点可以优化，但首先能保证用户看到页面数据或许更加重要。</p>
<p>上述应对域名劫持的策略本身并不能独立成一个模块，我们把它集成为网络框架的扩展。</p>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>上文提到的是我们Android应用架构中的核心部分，可能你发现并没有什么花哨的、潮流的玩意儿，没有MVP，没有RxAndroid，没有插件化，也没有热修复……但就是这样它仍然支撑起了上亿的用户量。世上没有完美的架构，只有符合自身业务的架构，上述架构还有很多缺点，我们也在有选择、有步骤地重构，而随着业务需求的扩展，架构也会不断演化，最后希望本文能给大家带来一点参考意义。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/02/10/Android-Instrumentation源码分析（附Activity启动流程）/">Android Instrumentation源码分析（附Activity启动流程）</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-02-10
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h3 id="Instrumentation_u6982_u5FF5"><a href="#Instrumentation_u6982_u5FF5" class="headerlink" title="Instrumentation概念"></a>Instrumentation概念</h3><h4 id="u5B98_u65B9_u8BF4_u660E"><a href="#u5B98_u65B9_u8BF4_u660E" class="headerlink" title="官方说明"></a>官方说明</h4><p>Instrumentation类位于android.app包中，继承自java.lang.Object，一些测试用类如InstrumentationTestRunner或MultiDexTestRunner直接或间接继承自该类。官方对于该类的解释如下：</p>
<blockquote>
<p>Base class for implementing application instrumentation code. When running with instrumentation turned on, this class will be instantiated for you before any of the application code, allowing you to monitor all of the interaction the system has with the application. An Instrumentation implementation is described to the system through an AndroidManifest.xml’s instrumentation tag.</p>
</blockquote>
<p>大意是当instrumentation开启的话，它会在应用程序的任何组件创建之前初始化，可以用来监控系统与应用的所有交互。系统可以根据AndroidManifest.xml中的 instrumentation 标签来实现instrumentation。</p>
<h4 id="u5728AndroidManifest-xml_u4E2D_u7684_u58F0_u660E_u65B9_u5F0F_u53CA_u5C5E_u6027_u89E3_u91CA"><a href="#u5728AndroidManifest-xml_u4E2D_u7684_u58F0_u660E_u65B9_u5F0F_u53CA_u5C5E_u6027_u89E3_u91CA" class="headerlink" title="在AndroidManifest.xml中的声明方式及属性解释"></a>在AndroidManifest.xml中的声明方式及属性解释</h4><p>语法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">instrumentation</span> <span class="attribute">android:functionalTest</span>=<span class="value">["true"</span> | "<span class="attribute">false</span>"]</span><br><span class="line">                 <span class="attribute">android:handleProfiling</span>=<span class="value">["true"</span> | "<span class="attribute">false</span>"]</span><br><span class="line">                 <span class="attribute">android:icon</span>=<span class="value">"drawable resource"</span></span><br><span class="line">                 <span class="attribute">android:label</span>=<span class="value">"string resource"</span></span><br><span class="line">                 <span class="attribute">android:name</span>=<span class="value">"string"</span></span><br><span class="line">                 <span class="attribute">android:targetPackage</span>=<span class="value">"string"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>父元素：</p>
<p>manifest</p>
<p>描述：</p>
<p>声明一个Instrumentation类，可以用来监控应用与系统之间的交互。Instrumentation类的对象会在应用的所有组件创建之前初始化。</p>
<p>属性介绍：</p>
<p><code>android:functionalTest</code> </p>
<p>指定Instrumentation类是否作为一个功能性的测试来运行，如果为true，则是；如果为false，则不是，默认值为false。    </p>
<p><code>android:handleProfiling</code></p>
<p>指定Instrumentation对象是否开启和关闭分析功能。如果设置为true，那么由Instrumentation对象来决定何时启动、停止分析；如果设置为false，则分析功能会在Instrumentation对象整个运行期间启用。如果设置为true，可以使Instrumentation对象针对一组特定的操作来进行分析，默认值为false。</p>
<p><code>android:icon</code>        </p>
<p>Instrumentation类呈现给用户的图标，这个属性必须设置为一个Drawable资源的引用。</p>
<p><code>android:label</code>        </p>
<p>用户可读的Instrumentation类的标签，这个标签可以被设置为原生字符串或者字符串资源的引用。 </p>
<p><code>android:name</code>       </p>
<p>Instrumentation子类的名称，它应当是完整的类名（如，“com.example.project.StringInstrumentation”）。然而，还有一种简写方式，如果这个名称的第一个字符是英文句号，那么它将追加到manifest元素指定的包名的后面。</p>
<p>它没有默认值，必须要设置。    </p>
<p><code>android:targetPackage</code>        </p>
<p>Instrumentation对象将要运行的应用。这个应用由在它的manifest文件中由manifest元素指定的包名来确定。</p>
<h3 id="Instrumentation_u6E90_u7801_u5206_u6790"><a href="#Instrumentation_u6E90_u7801_u5206_u6790" class="headerlink" title="Instrumentation源码分析"></a>Instrumentation源码分析</h3><h4 id="u6784_u9020_u51FD_u6570"><a href="#u6784_u9020_u51FD_u6570" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Instrumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Instrumentation_u751F_u547D_u5468_u671F_u76F8_u5173_u7684_u65B9_u6CD5"><a href="#Instrumentation_u751F_u547D_u5468_u671F_u76F8_u5173_u7684_u65B9_u6CD5" class="headerlink" title="Instrumentation生命周期相关的方法"></a>Instrumentation生命周期相关的方法</h4><p>首先是onCreate方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Called when the instrumentation is starting, before any application code</span><br><span class="line"> * has been loaded.  Usually this will be implemented to simply call</span><br><span class="line"> * &#123;<span class="doctag">@link</span> #start&#125; to begin the instrumentation thread, which will then</span><br><span class="line"> * continue execution in &#123;<span class="doctag">@link</span> #onStart&#125;.</span><br><span class="line"> * </span><br><span class="line"> * &lt;p&gt;If you do not need your own thread -- that is you are writing your</span><br><span class="line"> * instrumentation to be completely asynchronous (returning to the event</span><br><span class="line"> * loop so that the application can run), you can simply begin your</span><br><span class="line"> * instrumentation here, for example call &#123;<span class="doctag">@link</span> Context#startActivity&#125; to</span><br><span class="line"> * begin the appropriate first activity of the application. </span><br><span class="line"> *  </span><br><span class="line"> * <span class="doctag">@param</span> arguments Any additional arguments that were supplied when the </span><br><span class="line"> *                  instrumentation was started.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle arguments)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当启动一个instrumentation时会调用上述onCreate方法，它会在所有应用程序代码加载完成之前启动。在Instrumentation源码中，它是一个空方法，因此会在其实现类中重写，如在InstrumentationTestRunner中就重写了onCreate，并在最后调用了start()方法。</p>
<p>start方法会启动一个新的线程用来执行instrumentation，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Create and start a new thread in which to run instrumentation.  This new</span><br><span class="line"> * thread will call to &#123;<span class="doctag">@link</span> #onStart&#125; where you can implement the</span><br><span class="line"> * instrumentation.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRunner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Instrumentation already started"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mRunner = <span class="keyword">new</span> InstrumentationThread(<span class="string">"Instr: "</span> + getClass().getName());</span><br><span class="line">    mRunner.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中mRunner是InstrumentationThread的一个实例，表示Instrumentation所在的线程，该线程启动后会执行onStart()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentationThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstrumentationThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Process.setThreadPriority(Process.THREAD_PRIORITY_URGENT_DISPLAY);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Exception setting priority of instrumentation thread "</span></span><br><span class="line">                    + Process.myTid(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mAutomaticPerformanceSnapshots) &#123;</span><br><span class="line">            startPerformanceSnapshot();</span><br><span class="line">        &#125;</span><br><span class="line">        onStart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看onStart方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Method where the instrumentation thread enters execution.  This allows</span><br><span class="line"> * you to run your instrumentation code in a separate thread than the</span><br><span class="line"> * application, so that it can perform blocking operation such as</span><br><span class="line"> * &#123;<span class="doctag">@link</span> #sendKeySync&#125; or &#123;<span class="doctag">@link</span> #startActivitySync&#125;.</span><br><span class="line"> * </span><br><span class="line"> * &lt;p&gt;You will typically want to call finish() when this function is done,</span><br><span class="line"> * to end your instrumentation.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在onStart()里面可以具体实现instrumentation的逻辑，但在Instrumentation中它也是个空方法，需要重写该方法，从而可以测试一些阻塞性的操作，当功能完成时可以调用finish()方法来结束instrumentation，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Terminate instrumentation of the application.  This will cause the</span><br><span class="line"> * application process to exit, removing this instrumentation from the next</span><br><span class="line"> * time the application is started. </span><br><span class="line"> *  </span><br><span class="line"> * <span class="doctag">@param</span> resultCode Overall success/failure of instrumentation. </span><br><span class="line"> * <span class="doctag">@param</span> results Any results to send back to the code that started the </span><br><span class="line"> *                instrumentation.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(<span class="keyword">int</span> resultCode, Bundle results)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAutomaticPerformanceSnapshots) &#123;</span><br><span class="line">        endPerformanceSnapshot();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPerfMetrics != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (results == <span class="keyword">null</span>) &#123;</span><br><span class="line">            results = <span class="keyword">new</span> Bundle();</span><br><span class="line">        &#125;</span><br><span class="line">        results.putAll(mPerfMetrics);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((mUiAutomation != <span class="keyword">null</span>) &amp;&amp; !mUiAutomation.isDestroyed()) &#123;</span><br><span class="line">        mUiAutomation.disconnect();</span><br><span class="line">        mUiAutomation = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mThread.finishInstrumentation(resultCode, results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>finish方法会终止应用程序的instrumentation，同时应用进程退出，下次该应用再次启动时会移除该instrumentation。</p>
<p>最后是onDestroy方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Called when the instrumented application is stopping, after all of the</span><br><span class="line"> * normal application cleanup has occurred.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法当应用程序停止检测，且所有应用被清理之后才会执行。</p>
<h4 id="u83B7_u53D6Context_u7684_u4E24_u4E2A_u65B9_u6CD5"><a href="#u83B7_u53D6Context_u7684_u4E24_u4E2A_u65B9_u6CD5" class="headerlink" title="获取Context的两个方法"></a>获取Context的两个方法</h4><p>第一个是获取instrumentation所在包的上下文对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Return the Context of this instrumentation's package.  Note that this is</span><br><span class="line"> * often different than the Context of the application being</span><br><span class="line"> * instrumentated, since the instrumentation code often lives is a</span><br><span class="line"> * different package than that of the application it is running against.</span><br><span class="line"> * See &#123;<span class="doctag">@link</span> #getTargetContext&#125; to retrieve a Context for the target</span><br><span class="line"> * application.</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@return</span> The instrumentation's package context.</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@see</span> #getTargetContext</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Context <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mInstrContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个是获取被检测的应用的上下文对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Return a Context for the target application being instrumented.  Note</span><br><span class="line"> * that this is often different than the Context of the instrumentation</span><br><span class="line"> * code, since the instrumentation code often lives is a different package</span><br><span class="line"> * than that of the application it is running against. See</span><br><span class="line"> * &#123;<span class="doctag">@link</span> #getContext&#125; to retrieve a Context for the instrumentation code.</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@return</span> A Context in the target application.</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@see</span> #getContext</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Context <span class="title">getTargetContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mAppContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么会有上面两个不同的Context呢？是因为instrumentation的代码经常运行在另一个包（或者叫进程）中，而被检测的应用是另一个进程。</p>
<h4 id="u63A7_u5236_u6027_u80FD_u5206_u6790_u7684_u51E0_u4E2A_u65B9_u6CD5"><a href="#u63A7_u5236_u6027_u80FD_u5206_u6790_u7684_u51E0_u4E2A_u65B9_u6CD5" class="headerlink" title="控制性能分析的几个方法"></a>控制性能分析的几个方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Check whether this instrumentation was started with profiling enabled.</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@return</span> Returns true if profiling was enabled when starting, else false.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isProfiling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mThread.isProfiling();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * This method will start profiling if isProfiling() returns true. You should</span><br><span class="line"> * only call this method if you set the handleProfiling attribute in the </span><br><span class="line"> * manifest file for this Instrumentation to true.  </span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProfiling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThread.isProfiling()) &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(mThread.getProfileFilePath());</span><br><span class="line">        file.getParentFile().mkdirs();</span><br><span class="line">        Debug.startMethodTracing(file.toString(), <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Stops profiling if isProfiling() returns true.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopProfiling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThread.isProfiling()) &#123;</span><br><span class="line">        Debug.stopMethodTracing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAutomaticPerformanceSnapshots</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mAutomaticPerformanceSnapshots = <span class="keyword">true</span>;</span><br><span class="line">    mPerformanceCollector = <span class="keyword">new</span> PerformanceCollector();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startPerformanceSnapshot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isProfiling()) &#123;</span><br><span class="line">        mPerformanceCollector.beginSnapshot(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endPerformanceSnapshot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isProfiling()) &#123;</span><br><span class="line">        mPerfMetrics = mPerformanceCollector.endSnapshot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面几个方法比较简单，通过注释即可理解其用途。</p>
<h4 id="u4E24_u4E2A_u6BD4_u8F83_u91CD_u8981_u7684_u5185_u90E8_u7C7B"><a href="#u4E24_u4E2A_u6BD4_u8F83_u91CD_u8981_u7684_u5185_u90E8_u7C7B" class="headerlink" title="两个比较重要的内部类"></a>两个比较重要的内部类</h4><h5 id="Instrumentation-ActivityResult"><a href="#Instrumentation-ActivityResult" class="headerlink" title="Instrumentation.ActivityResult"></a>Instrumentation.ActivityResult</h5><p>该类大家应该很熟悉，我们经常使用startActivityForResult，这个类就是用来封装从第二个Activity返回的结果的，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Description of a Activity execution result to return to the original</span><br><span class="line"> * activity.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityResult</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Create a new activity result.  See &#123;<span class="doctag">@link</span> Activity#setResult&#125; for </span><br><span class="line">     * more information. </span><br><span class="line">     *  </span><br><span class="line">     * <span class="doctag">@param</span> resultCode The result code to propagate back to the</span><br><span class="line">     * originating activity, often RESULT_CANCELED or RESULT_OK</span><br><span class="line">     * <span class="doctag">@param</span> resultData The data to propagate back to the originating</span><br><span class="line">     * activity.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ActivityResult</span><span class="params">(<span class="keyword">int</span> resultCode, Intent resultData)</span> </span>&#123;</span><br><span class="line">        mResultCode = resultCode;</span><br><span class="line">        mResultData = resultData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Retrieve the result code contained in this result.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getResultCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mResultCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Retrieve the data contained in this result.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Intent <span class="title">getResultData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mResultData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mResultCode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Intent mResultData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该类非常简单，维护了一个整型的resultCode以及一个Intent类型的resultData，可以结合常用的onActivityResult回调来印证一下。</p>
<h5 id="Instrumentation-ActivityMonitor"><a href="#Instrumentation-ActivityMonitor" class="headerlink" title="Instrumentation.ActivityMonitor"></a>Instrumentation.ActivityMonitor</h5><p>该类官方注释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Information about a particular kind of Intent that is being monitored.</span><br><span class="line"> * An instance of this class is added to the </span><br><span class="line"> * current instrumentation through &#123;<span class="doctag">@link</span> #addMonitor&#125;; after being added, </span><br><span class="line"> * when a new activity is being started the monitor will be checked and, if </span><br><span class="line"> * matching, its hit count updated and (optionally) the call stopped and a </span><br><span class="line"> * canned result returned.</span><br><span class="line"> * </span><br><span class="line"> * &lt;p&gt;An ActivityMonitor can also be used to look for the creation of an</span><br><span class="line"> * activity, through the &#123;<span class="doctag">@link</span> #waitForActivity&#125; method.  This will return</span><br><span class="line"> * after a matching activity has been created with that activity object.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityMonitor</span> </span>&#123;</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从注释可知ActivityMonitor可以用来监控某个特定Intent的信息，可以通过Instrumentation.addMonitor方法来添加ActivityMonitor的实例。当一个新的Activity被启动时，会匹配Instrumentation中的ActivityMonitory实例列表，如果匹配，就会累加命中计数器。ActivityMonitor也可以被用于获取新创建的Activity，通过waitForActivity方法，可以返回一个匹配IntentFilter的Activity对象。</p>
<h6 id="u6210_u5458_u53D8_u91CF"><a href="#u6210_u5458_u53D8_u91CF" class="headerlink" title="成员变量"></a>成员变量</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IntentFilter mWhich;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String mClass;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ActivityResult mResult;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mBlock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// This is protected by 'Instrumentation.this.mSync'.</span></span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">int</span> mHits = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is protected by 'this'.</span></span><br><span class="line"><span class="comment">/*package*/</span> Activity mLastActivity = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<h6 id="u6784_u9020_u51FD_u6570-1"><a href="#u6784_u9020_u51FD_u6570-1" class="headerlink" title="构造函数"></a>构造函数</h6><p>ActivityMonitor有两种构造方法，其一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Create a new ActivityMonitor that looks for a particular kind of </span><br><span class="line"> * intent to be started.</span><br><span class="line"> *  </span><br><span class="line"> * <span class="doctag">@param</span> which The set of intents this monitor is responsible for.</span><br><span class="line"> * <span class="doctag">@param</span> result A canned result to return if the monitor is hit; can </span><br><span class="line"> *               be null.</span><br><span class="line"> * <span class="doctag">@param</span> block Controls whether the monitor should block the activity </span><br><span class="line"> *              start (returning its canned result) or let the call</span><br><span class="line"> *              proceed.</span><br><span class="line"> *  </span><br><span class="line"> * <span class="doctag">@see</span> Instrumentation#addMonitor </span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActivityMonitor</span><span class="params">(</span><br><span class="line">    IntentFilter which, ActivityResult result, <span class="keyword">boolean</span> block)</span> </span>&#123;</span><br><span class="line">    mWhich = which;</span><br><span class="line">    mClass = <span class="keyword">null</span>;</span><br><span class="line">    mResult = result;</span><br><span class="line">    mBlock = block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Create a new ActivityMonitor that looks for a specific activity </span><br><span class="line"> * class to be started. </span><br><span class="line"> *  </span><br><span class="line"> * <span class="doctag">@param</span> cls The activity class this monitor is responsible for.</span><br><span class="line"> * <span class="doctag">@param</span> result A canned result to return if the monitor is hit; can </span><br><span class="line"> *               be null.</span><br><span class="line"> * <span class="doctag">@param</span> block Controls whether the monitor should block the activity </span><br><span class="line"> *              start (returning its canned result) or let the call</span><br><span class="line"> *              proceed.</span><br><span class="line"> *  </span><br><span class="line"> * <span class="doctag">@see</span> Instrumentation#addMonitor </span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActivityMonitor</span><span class="params">(</span><br><span class="line">    String cls, ActivityResult result, <span class="keyword">boolean</span> block)</span> </span>&#123;</span><br><span class="line">    mWhich = <span class="keyword">null</span>;</span><br><span class="line">    mClass = cls;</span><br><span class="line">    mResult = result;</span><br><span class="line">    mBlock = block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较上面两个构造方法可知，只有一个参数不同：一个需要IntentFilter，而另一个需要Activity的类名。</p>
<h6 id="waitForActivity_u65B9_u6CD5"><a href="#waitForActivity_u65B9_u6CD5" class="headerlink" title="waitForActivity方法"></a>waitForActivity方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Block until an Activity is created that matches this monitor, </span><br><span class="line"> * returning the resulting activity. </span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@return</span> Activity</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Activity <span class="title">waitForActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (mLastActivity == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Activity res = mLastActivity;</span><br><span class="line">        mLastActivity = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从注释可知，该方法会阻塞直到有匹配该ActivityMonitor的Activity创建完成，最后将该Activity返回。</p>
<h6 id="waitForActivityWithTimeout_u65B9_u6CD5"><a href="#waitForActivityWithTimeout_u65B9_u6CD5" class="headerlink" title="waitForActivityWithTimeout方法"></a>waitForActivityWithTimeout方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Block until an Activity is created that matches this monitor, </span><br><span class="line"> * returning the resulting activity or till the timeOut period expires.</span><br><span class="line"> * If the timeOut expires before the activity is started, return null. </span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> timeOut Time to wait in milliseconds before the activity is created.</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@return</span> Activity</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Activity <span class="title">waitForActivityWithTimeout</span><span class="params">(<span class="keyword">long</span> timeOut)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mLastActivity == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait(timeOut);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mLastActivity == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Activity res = mLastActivity;</span><br><span class="line">            mLastActivity = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法则会有超时限制，超市之后将返回null。</p>
<h6 id="match_u65B9_u6CD5"><a href="#match_u65B9_u6CD5" class="headerlink" title="match方法"></a>match方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(Context who,</span><br><span class="line">                    Activity activity,</span><br><span class="line">                    Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mWhich != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; mWhich.match(who.getContentResolver(), intent,</span><br><span class="line">                            <span class="keyword">true</span>, <span class="string">"Instrumentation"</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String cls = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cls = activity.getClass().getName();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (intent.getComponent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cls = intent.getComponent().getClassName();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cls == <span class="keyword">null</span> || !mClass.equals(cls)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mLastActivity = activity;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法顾名思义，它会在启动Activity时调用。从代码中可知，它先回根据IntentFilter判断是否匹配，然后再根据Activity的类名进行判断。</p>
<h4 id="u4E00_u7CFB_u5217_u64CD_u4F5C_u4E8B_u4EF6_u65B9_u6CD5"><a href="#u4E00_u7CFB_u5217_u64CD_u4F5C_u4E8B_u4EF6_u65B9_u6CD5" class="headerlink" title="一系列操作事件方法"></a>一系列操作事件方法</h4><ul>
<li><code>public boolean invokeMenuActionSync(Activity targetActivity, int id, int flag)</code></li>
<li><code>public boolean invokeContextMenuAction(Activity targetActivity, int id, int flag)</code></li>
<li><code>public void sendStringSync(String text)</code></li>
<li><code>public void sendKeySync(KeyEvent event)</code></li>
<li><code>public void sendKeyDownUpSync(int key)</code></li>
<li><code>public void sendCharacterSync(int keyCode)</code></li>
<li><code>public void sendPointerSync(MotionEvent event)</code></li>
<li><code>public void sendTrackballEventSync(MotionEvent event)</code></li>
</ul>
<p>上述方法主要用于辅助测试，根据方法名及注释即可理解，不做赘述。</p>
<h4 id="ActivityMonitor_u76F8_u5173_u7684_u65B9_u6CD5"><a href="#ActivityMonitor_u76F8_u5173_u7684_u65B9_u6CD5" class="headerlink" title="ActivityMonitor相关的方法"></a>ActivityMonitor相关的方法</h4><p>以下3个方法时用来将ActivityMonitor对象添加到一个ActivityMonitor列表中，具体实现为ArrayList。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMonitor</span><span class="params">(ActivityMonitor monitor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mActivityMonitors == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mActivityMonitors = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        &#125;</span><br><span class="line">        mActivityMonitors.add(monitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityMonitor <span class="title">addMonitor</span><span class="params">(</span><br><span class="line">    IntentFilter filter, ActivityResult result, <span class="keyword">boolean</span> block)</span> </span>&#123;</span><br><span class="line">    ActivityMonitor am = <span class="keyword">new</span> ActivityMonitor(filter, result, block);</span><br><span class="line">    addMonitor(am);</span><br><span class="line">    <span class="keyword">return</span> am;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityMonitor <span class="title">addMonitor</span><span class="params">(</span><br><span class="line">    String cls, ActivityResult result, <span class="keyword">boolean</span> block)</span> </span>&#123;</span><br><span class="line">    ActivityMonitor am = <span class="keyword">new</span> ActivityMonitor(cls, result, block);</span><br><span class="line">    addMonitor(am);</span><br><span class="line">    <span class="keyword">return</span> am;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面方法用来检查ActivityMonitor是否匹配：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkMonitorHit</span><span class="params">(ActivityMonitor monitor, <span class="keyword">int</span> minHits)</span> </span>&#123;</span><br><span class="line">    waitForIdleSync();</span><br><span class="line">    <span class="keyword">synchronized</span> (mSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (monitor.getHits() &lt; minHits) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mActivityMonitors.remove(monitor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来个方法用来返回匹配的Activity：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">waitForMonitor</span><span class="params">(ActivityMonitor monitor)</span> </span>&#123;</span><br><span class="line">    Activity activity = monitor.waitForActivity();</span><br><span class="line">    <span class="keyword">synchronized</span> (mSync) &#123;</span><br><span class="line">        mActivityMonitors.remove(monitor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">waitForMonitorWithTimeout</span><span class="params">(ActivityMonitor monitor, <span class="keyword">long</span> timeOut)</span> </span>&#123;</span><br><span class="line">    Activity activity = monitor.waitForActivityWithTimeout(timeOut);</span><br><span class="line">    <span class="keyword">synchronized</span> (mSync) &#123;</span><br><span class="line">        mActivityMonitors.remove(monitor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是删除ActivityMonitor的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Remove an &#123;<span class="doctag">@link</span> ActivityMonitor&#125; that was previously added with </span><br><span class="line"> * &#123;<span class="doctag">@link</span> #addMonitor&#125;.</span><br><span class="line"> *  </span><br><span class="line"> * <span class="doctag">@param</span> monitor The monitor to remove.</span><br><span class="line"> *  </span><br><span class="line"> * <span class="doctag">@see</span> #addMonitor </span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMonitor</span><span class="params">(ActivityMonitor monitor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mSync) &#123;</span><br><span class="line">        mActivityMonitors.remove(monitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Activity_u542F_u52A8_u6D41_u7A0B_uFF08Application_u7684_u521B_u5EFA_uFF09"><a href="#Activity_u542F_u52A8_u6D41_u7A0B_uFF08Application_u7684_u521B_u5EFA_uFF09" class="headerlink" title="Activity启动流程（Application的创建）"></a>Activity启动流程（Application的创建）</h4><p>如果你在阅读Instrumentation的源码时发现了关于创建Application和Activity的方法，请不要惊讶，是否瞬间感觉这个类相当重要。我们都知道，每个App都只有一个Application实例，如果在源码中跟踪过Activity的启动过程，也许还记得Application的最终创建就是位于Instrumentation中的。</p>
<p>我们大概浏览一下源码中启动一个Activity的流程，以Activity A启动Activity B为例：</p>
<p>1.startActivity方法有多种重载形式，但最终都会走到startActivityForResult，源码位于Activity.java中，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode,</span><br><span class="line">        @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Instrumentation.ActivityResult ar =</span><br><span class="line">            mInstrumentation.execStartActivity(</span><br><span class="line">                <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                intent, requestCode, options);</span><br><span class="line">        <span class="keyword">if</span> (ar != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mMainThread.sendActivityResult(</span><br><span class="line">                mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                ar.getResultData());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If this start is requesting a result, we can avoid making</span></span><br><span class="line">            <span class="comment">// the activity visible until the result is received.  Setting</span></span><br><span class="line">            <span class="comment">// this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span></span><br><span class="line">            <span class="comment">// activity hidden during this time, to avoid flickering.</span></span><br><span class="line">            <span class="comment">// This can only be done when a result is requested because</span></span><br><span class="line">            <span class="comment">// that guarantees we will get information back when the</span></span><br><span class="line">            <span class="comment">// activity is finished, no matter what happens to it.</span></span><br><span class="line">            mStartedActivity = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cancelInputsAndStartExitTransition(options);</span><br><span class="line">        <span class="comment">// TODO Consider clearing/flushing other event sources and events for child windows.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode, options);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Note we want to go through this method for compatibility with</span></span><br><span class="line">            <span class="comment">// existing applications that may have overridden it.</span></span><br><span class="line">            mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到此段代码中已经有了Instrumentation，对应代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Instrumentation.ActivityResult ar =</span><br><span class="line">    mInstrumentation.execStartActivity(</span><br><span class="line">        <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">        intent, requestCode, options);</span><br></pre></td></tr></table></figure>
<p>我们先来看Activity.java中的mInstrumentation是何时初始化的，然后再看上述方法的具体实现。</p>
<p>经搜索发现mInstrumentation是在Activity的attach方法中赋值的，具体代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mInstrumentation = instr;</span><br></pre></td></tr></table></figure>
<p>那么Activity的attach方法时何时调用的呢？这里先放一放，稍后会提到。</p>
<p>2.接着来看<code>mInstrumentation.execStartActivity(    this, mMainThread.getApplicationThread(), mToken, this,    intent, requestCode, options);</code>的具体实现，代码位于Instrumentation.java中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span><br><span class="line">        Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">        Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">    Uri referrer = target != <span class="keyword">null</span> ? target.onProvideReferrer() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (referrer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent.putExtra(Intent.EXTRA_REFERRER, referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mActivityMonitors != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mSync) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mActivityMonitors.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> ActivityMonitor am = mActivityMonitors.get(i);</span><br><span class="line">                <span class="keyword">if</span> (am.match(who, <span class="keyword">null</span>, intent)) &#123;</span><br><span class="line">                    am.mHits++;</span><br><span class="line">                    <span class="keyword">if</span> (am.isBlocking()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> requestCode &gt;= <span class="number">0</span> ? am.getResult() : <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData();</span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        <span class="keyword">int</span> result = ActivityManagerNative.getDefault()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                    requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码不难看出Activity的真正启动逻辑是由下面几句完成的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = ActivityManagerNative.getDefault()</span><br><span class="line">    .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">            intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">            token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">            requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">checkStartActivityResult(result, intent);</span><br></pre></td></tr></table></figure>
<p>其中最后一句<code>checkStartActivityResult(result, intent);</code>是用来检查Activity的启动情况，我们经常忘记在AndroidManifest.xml注册Activity，从而会报异常：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; have you declared <span class="keyword">this</span> activity in your AndroidManifest.xml?</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这句异常就是在<code>checkStartActivityResult(result, intent);</code>中实现的。</p>
<p>言归正传，上述代码中是由<code>ActivityManagerNative.getDefault()</code>来启动Activity的，<code>ActivityManagerNative.getDefault()</code>返回一个IActivityManager对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Retrieve the system's default/global activity manager.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gDefault.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道ActivityManagerNative继承自Binder并实现了IActivityManager接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerNative</span> <span class="keyword">extends</span> <span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">IActivityManager</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在IActivityManager接口中定义了上述启动Activity的方法，但没有实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startActivities</span><span class="params">(IApplicationThread caller, String callingPackage,</span><br><span class="line">        Intent[] intents, String[] resolvedTypes, IBinder resultTo,</span><br><span class="line">        Bundle options, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br></pre></td></tr></table></figure>
<p>其具体实现是在ActivityManagerService中，ActivityManagerService源码路径为：</p>
<blockquote>
<p>/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p>
</blockquote>
<p>可以看到ActivityManagerService继承自ActivityManagerNative：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerService</span> <span class="keyword">extends</span> <span class="title">ActivityManagerNative</span> <span class="keyword">implements</span> <span class="title">Watchdog</span>.<span class="title">Monitor</span>, <span class="title">BatteryStatsImpl</span>.<span class="title">BatteryCallback</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>3.现在逻辑已经到了ActivityManagerService中，找到对应的启动Activity的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivities</span><span class="params">(IApplicationThread caller, String callingPackage,</span><br><span class="line">                                 Intent[] intents, String[] resolvedTypes, IBinder resultTo, Bundle options,</span><br><span class="line">                                 <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startActivities"</span>);</span><br><span class="line">    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,</span><br><span class="line">            <span class="keyword">false</span>, ALLOW_FULL_ONLY, <span class="string">"startActivity"</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Switch to user app stacks here.</span></span><br><span class="line">    <span class="keyword">int</span> ret = mStackSupervisor.startActivities(caller, -<span class="number">1</span>, callingPackage, intents,</span><br><span class="line">            resolvedTypes, resultTo, options, userId);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析上述代码发现启动逻辑又转移到了ActivityStackSupervisor中。ActivityStackSupervisor源码路径为：</p>
<blockquote>
<p>/frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</p>
</blockquote>
<p>由于代码片段比较长，下面仅罗列主要流程：</p>
<p>ActivityStackSupervisor—&gt;startActivities()</p>
<p>ActivityStackSupervisor—&gt;startActivityLocked()</p>
<p>ActivityStackSupervisor—&gt;startActivityUncheckedLocked()</p>
<p>ActivityStack—&gt;startActivityLocked()</p>
<p>ActivityStackSupervisor—&gt;resumeTopActivitiesLocked()</p>
<p>ActivityStack—&gt;resumeTopActivityLocked()</p>
<p>ActivityStack—&gt;resumeTopActivityInnerLocked()</p>
<p>ActivityStackSupervisor—&gt;startSpecificActivityLocked()</p>
<p>ActivityStackSupervisor—&gt;realStartActivityLocked()</p>
<p>其中ActivityStack源码路径为：</p>
<blockquote>
<p>/frameworks/base/services/core/java/com/android/server/am/ActivityStack.java</p>
</blockquote>
<p>4.在ActivityStackSupervisor的realStartActivityLocked()方法中，有这样一段关键代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.thread.scheduleLaunchActivity(<span class="keyword">new</span> Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, <span class="keyword">new</span> Configuration(mService.mConfiguration), r.compat, r.launchedFromPackage, r.task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</span><br></pre></td></tr></table></figure>
<p>其中app.thread类型为IApplicationThread，IApplicationThread的声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * System private API for communicating with the application.  This is given to</span><br><span class="line"> * the activity manager by an application  when it starts up, for the activity</span><br><span class="line"> * manager to tell the application about things it needs to do.</span><br><span class="line"> *</span><br><span class="line"> * &#123;<span class="doctag">@hide</span>&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IApplicationThread</span> <span class="keyword">extends</span> <span class="title">IInterface</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>IApplicationThread接口定义了上述启动Activity的方法，但接口中没有实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(Intent intent, IBinder token, <span class="keyword">int</span> ident,</span><br><span class="line">        ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span><br><span class="line">        CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">        <span class="keyword">int</span> procState, Bundle state, PersistableBundle persistentState,</span><br><span class="line">        List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span><br><span class="line">        <span class="keyword">boolean</span> notResumed, <span class="keyword">boolean</span> isForward, ProfilerInfo profilerInfo)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br></pre></td></tr></table></figure>
<p>接下来需要找到IApplicationThread接口的实现者，我们想到ActivityThread中有一个叫做ApplicationThread的内部类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">ApplicationThreadNative</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>ApplicationThread继承自ApplicationThreadNative，而ApplicationThreadNative继承自Binder并实现了IApplicationThread接口，所以ApplicationThread就是IApplicationThread的具体实现者。</p>
<p>5.于是Activity的启动流程又变为：</p>
<p>ActivityThread.ApplicationThread—&gt;scheduleLaunchActivity()，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(Intent intent, IBinder token, <span class="keyword">int</span> ident,</span><br><span class="line">        ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span><br><span class="line">        CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">        <span class="keyword">int</span> procState, Bundle state, PersistableBundle persistentState,</span><br><span class="line">        List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span><br><span class="line">        <span class="keyword">boolean</span> notResumed, <span class="keyword">boolean</span> isForward, ProfilerInfo profilerInfo)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    updateProcessState(procState, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord();</span><br><span class="line"></span><br><span class="line">    r.token = token;</span><br><span class="line">    r.ident = ident;</span><br><span class="line">    r.intent = intent;</span><br><span class="line">    r.referrer = referrer;</span><br><span class="line">    r.voiceInteractor = voiceInteractor;</span><br><span class="line">    r.activityInfo = info;</span><br><span class="line">    r.compatInfo = compatInfo;</span><br><span class="line">    r.state = state;</span><br><span class="line">    r.persistentState = persistentState;</span><br><span class="line"></span><br><span class="line">    r.pendingResults = pendingResults;</span><br><span class="line">    r.pendingIntents = pendingNewIntents;</span><br><span class="line"></span><br><span class="line">    r.startsNotResumed = notResumed;</span><br><span class="line">    r.isForward = isForward;</span><br><span class="line"></span><br><span class="line">    r.profilerInfo = profilerInfo;</span><br><span class="line"></span><br><span class="line">    r.overrideConfig = overrideConfig;</span><br><span class="line">    updatePendingConfiguration(curConfig);</span><br><span class="line"></span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码很简单，就是发送了一个LAUNCH_ACTIVITY的消息给名为H的handler处理，接下来看消息处理逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);</span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line"></span><br><span class="line">    r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">            r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">    handleLaunchActivity(r, <span class="keyword">null</span>, <span class="string">"LAUNCH_ACTIVITY"</span>);</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>6.启动逻辑变为</p>
<p>ActivityThread—&gt;handleLaunchActivity()</p>
<p>接着看handleLaunchActivity(r, null, “LAUNCH_ACTIVITY”)的具体实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If we are getting ready to gc after going to the background, well</span></span><br><span class="line">    <span class="comment">// we are back active so skip it.</span></span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.profilerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mProfiler.setProfiler(r.profilerInfo);</span><br><span class="line">        mProfiler.startProfiling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure we are running with the most recent config.</span></span><br><span class="line">    handleConfigurationChanged(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">        TAG, <span class="string">"Handling launch of "</span> + r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize before creating the activity</span></span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line"></span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.createdConfig = <span class="keyword">new</span> Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        Bundle oldState = r.state;</span><br><span class="line">        handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward,</span><br><span class="line">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123;</span><br><span class="line">            <span class="comment">// The activity manager actually wants this one to start out paused, because it</span></span><br><span class="line">            <span class="comment">// needs to be visible but isn't in the foreground. We accomplish this by going</span></span><br><span class="line">            <span class="comment">// through the normal startup (because activities expect to go through onResume()</span></span><br><span class="line">            <span class="comment">// the first time they run, before their window is displayed), and then pausing it.</span></span><br><span class="line">            <span class="comment">// However, in this case we do -not- need to do the full pause cycle (of freezing</span></span><br><span class="line">            <span class="comment">// and such) because the activity manager assumes it can just retain the current</span></span><br><span class="line">            <span class="comment">// state it has.</span></span><br><span class="line">            performPauseActivityIfNeeded(r, reason);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We need to keep around the original state, in case we need to be created again.</span></span><br><span class="line">            <span class="comment">// But we only do this for pre-Honeycomb apps, which always save their state when</span></span><br><span class="line">            <span class="comment">// pausing, so we can not have them save their state when restarting from a paused</span></span><br><span class="line">            <span class="comment">// state. For HC and later, we want to (and can) let the state be saved as the</span></span><br><span class="line">            <span class="comment">// normal part of stopping the activity.</span></span><br><span class="line">            <span class="keyword">if</span> (r.isPreHoneycomb()) &#123;</span><br><span class="line">                r.state = oldState;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If there was an error, for any reason, tell the activity manager to stop us.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManagerNative.getDefault()</span><br><span class="line">                .finishActivity(r.token, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</span><br><span class="line">                        Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中一行关键代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Activity a = performLaunchActivity(r, customIntent);</span><br></pre></td></tr></table></figure>
<p>接着看ActivityThread—&gt;performLaunchActivity()的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// System.out.println("##### [" + System.currentTimeMillis() + "] ActivityThread.performLaunchActivity(" + r + ")");</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从ActivityClientRecord中得到待启动的Activity组件的信息</span></span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ComponentName component = r.intent.getComponent();</span><br><span class="line">    <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = r.intent.resolveActivity(</span><br><span class="line">            mInitialApplication.getPackageManager());</span><br><span class="line">        r.intent.setComponent(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = <span class="keyword">new</span> ComponentName(r.activityInfo.packageName,</span><br><span class="line">                r.activityInfo.targetActivity);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 通过Instrumentation的newActivity方法来创建Activity对象</span></span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to instantiate activity "</span> + component</span><br><span class="line">                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建Application</span></span><br><span class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Performing launch of "</span> + r);</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">                TAG, r + <span class="string">": app="</span> + app</span><br><span class="line">                + <span class="string">", appName="</span> + app.getPackageName()</span><br><span class="line">                + <span class="string">", pkg="</span> + r.packageInfo.getPackageName()</span><br><span class="line">                + <span class="string">", comp="</span> + r.intent.getComponent().toShortString()</span><br><span class="line">                + <span class="string">", dir="</span> + r.packageInfo.getAppDir());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">            Configuration config = <span class="keyword">new</span> Configuration(mCompatConfiguration);</span><br><span class="line">            <span class="keyword">if</span> (r.overrideConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                config.updateFrom(r.overrideConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG, <span class="string">"Launching activity "</span></span><br><span class="line">                    + r.activityInfo.name + <span class="string">" with config "</span> + config);</span><br><span class="line">            Window window = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.mPendingRemoveWindow != <span class="keyword">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">                window = r.mPendingRemoveWindow;</span><br><span class="line">                r.mPendingRemoveWindow = <span class="keyword">null</span>;</span><br><span class="line">                r.mPendingRemoveWindowManager = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 调用Activity的attach方法</span></span><br><span class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (customIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                activity.mIntent = customIntent;</span><br><span class="line">            &#125;</span><br><span class="line">            r.lastNonConfigurationInstances = <span class="keyword">null</span>;</span><br><span class="line">            activity.mStartedActivity = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class="line">            <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">                activity.setTheme(theme);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                    <span class="string">"Activity "</span> + r.intent.getComponent().toShortString() +</span><br><span class="line">                    <span class="string">" did not call through to super.onCreate()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity = activity;</span><br><span class="line">            r.stopped = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                activity.performStart();</span><br><span class="line">                r.stopped = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (r.state != <span class="keyword">null</span> || r.persistentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class="line">                                r.persistentState);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnPostCreate(activity, r.state,</span><br><span class="line">                            r.persistentState);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                        <span class="string">"Activity "</span> + r.intent.getComponent().toShortString() +</span><br><span class="line">                        <span class="string">" did not call through to super.onPostCreate()"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r.paused = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to start activity "</span> + component</span><br><span class="line">                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码主要做了4件事情：</p>
<ol>
<li>从ActivityClientRecord中得到待启动的Activity组件的信息</li>
<li>通过Instrumentation的newActivity方法来创建Activity对象</li>
<li>创建Application对象</li>
<li>调用新启动Activity的attach方法</li>
</ol>
<p>上述四个逻辑对应的源码详见中文注释。</p>
<p>对于上述4件事情，我们主要关注以下几点：</p>
<p>1.Instrumentation的newActivity的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Perform instantiation of the process's &#123;<span class="doctag">@link</span> Activity&#125; object.  The</span><br><span class="line"> * default implementation provides the normal system behavior.</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> cl The ClassLoader with which to instantiate the object.</span><br><span class="line"> * <span class="doctag">@param</span> className The name of the class implementing the Activity</span><br><span class="line"> *                  object.</span><br><span class="line"> * <span class="doctag">@param</span> intent The Intent object that specified the activity class being</span><br><span class="line"> *               instantiated.</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@return</span> The newly instantiated Activity object.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">newActivity</span><span class="params">(ClassLoader cl, String className,</span><br><span class="line">        Intent intent)</span></span><br><span class="line">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span><br><span class="line">        ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Activity)cl.loadClass(className).newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，使用类加载器初始化一个Activity对象。</p>
<p>2.再来看下Application对象是如何创建出来的，以下为对应代码：</p>
<p><code>Application app = r.packageInfo.makeApplication(false, mInstrumentation);</code></p>
<p>其中r.packageInfo为LoadedApk对象，在LoadedApk类中的具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">makeApplication</span><span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass,</span><br><span class="line">        Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mApplication;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"makeApplication"</span>);</span><br><span class="line"></span><br><span class="line">    Application app = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    String appClass = mApplicationInfo.className;</span><br><span class="line">    <span class="keyword">if</span> (forceDefaultAppClass || (appClass == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        appClass = <span class="string">"android.app.Application"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">        <span class="keyword">if</span> (!mPackageName.equals(<span class="string">"android"</span>)) &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                    <span class="string">"initializeJavaContextClassLoader"</span>);</span><br><span class="line">            initializeJavaContextClassLoader();</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="keyword">this</span>);</span><br><span class="line">        app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                cl, appClass, appContext);</span><br><span class="line">        appContext.setOuterContext(app);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mActivityThread.mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to instantiate application "</span> + appClass</span><br><span class="line">                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mActivityThread.mAllApplications.add(app);</span><br><span class="line">    mApplication = app;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (instrumentation != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            instrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!instrumentation.onException(app, e)) &#123;</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Unable to create application "</span> + app.getClass().getName()</span><br><span class="line">                    + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rewrite the R 'constants' for all library apks.</span></span><br><span class="line">    SparseArray&lt;String&gt; packageIdentifiers = getAssets(mActivityThread)</span><br><span class="line">            .getAssignedPackageIdentifiers();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = packageIdentifiers.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> id = packageIdentifiers.keyAt(i);</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">0x01</span> || id == <span class="number">0x7f</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到源码中有如下判断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> mApplication;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正是因为每个App中只有一个Application的实例。接下来可以看到创建Application的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">        cl, appClass, appContext);</span><br></pre></td></tr></table></figure>
<p>最终仍然是进入到Instrumentation中，继续跟踪：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Perform instantiation of the process's &#123;<span class="doctag">@link</span> Application&#125; object.  The</span><br><span class="line"> * default implementation provides the normal system behavior.</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> cl The ClassLoader with which to instantiate the object.</span><br><span class="line"> * <span class="doctag">@param</span> className The name of the class implementing the Application</span><br><span class="line"> *                  object.</span><br><span class="line"> * <span class="doctag">@param</span> context The context to initialize the application with</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@return</span> The newly instantiated Application object.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(ClassLoader cl, String className, Context context)</span></span><br><span class="line">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException, </span><br><span class="line">        ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> newApplication(cl.loadClass(className), context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续调用如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Perform instantiation of the process's &#123;<span class="doctag">@link</span> Application&#125; object.  The</span><br><span class="line"> * default implementation provides the normal system behavior.</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> clazz The class used to create an Application object from.</span><br><span class="line"> * <span class="doctag">@param</span> context The context to initialize the application with</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@return</span> The newly instantiated Application object.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(Class&lt;?&gt; clazz, Context context)</span></span><br><span class="line">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException, </span><br><span class="line">        ClassNotFoundException </span>&#123;</span><br><span class="line">    Application app = (Application)clazz.newInstance();</span><br><span class="line">    app.attach(context);</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，Application也是通过类加载器来创建是个实例对象。</p>
<p>当Application创建完成之后，会调用如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instrumentation.callApplicationOnCreate(app);</span><br></pre></td></tr></table></figure>
<p>查看位于Instrumentation的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Perform calling of the application's &#123;<span class="doctag">@link</span> Application#onCreate&#125;</span><br><span class="line"> * method.  The default implementation simply calls through to that method.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Note: This method will be called immediately after &#123;<span class="doctag">@link</span> #onCreate(Bundle)&#125;.</span><br><span class="line"> * Often instrumentation tests start their test thread in onCreate(); you</span><br><span class="line"> * need to be careful of races between these.  (Well between it and</span><br><span class="line"> * everything else, but let's start here.)</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> app The application being created.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callApplicationOnCreate</span><span class="params">(Application app)</span> </span>&#123;</span><br><span class="line">    app.onCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用<code>app.onCreate()</code>从而触发Application的onCreate生命周期回调，到这里我们就非常熟悉了。</p>
<p>3.当Activity创建完成后，还需要为其创建相关的上下文对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Context appContext = createBaseContextForActivity(r, activity);</span><br></pre></td></tr></table></figure>
<p>然后为其创建window对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Window window = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (r.mPendingRemoveWindow != <span class="keyword">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">    window = r.mPendingRemoveWindow;</span><br><span class="line">    r.mPendingRemoveWindow = <span class="keyword">null</span>;</span><br><span class="line">    r.mPendingRemoveWindowManager = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后调用Activity的attach方法，将上下文对象、window等附加到Activity上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">        r.referrer, r.voiceInteractor, window);</span><br></pre></td></tr></table></figure>
<p>注意上述方法的第三个参数，getInstrumentation()返回的是ActivityThread的mInstrumentation实例。还记得之前遗留的问题：Activity的attach是何时调用的吗？到现在答案已经知道了。</p>
<p>Activity A启动Activity B，使用的是A的mInstrumentation，B创建完成，调用attach之后，B也就有了mInstrumentation，mInstrumentation变量在Activity中的声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set by the thread after the constructor and before onCreate(Bundle savedInstanceState) is called.</span></span><br><span class="line"><span class="keyword">private</span> Instrumentation mInstrumentation;</span><br></pre></td></tr></table></figure>
<p>根据注释可知，它是在构造函数之后、onCreate之前赋值的，就是上述attach方法。</p>
<p>attach之后，还可能为Activity设置主题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class="line"><span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">    activity.setTheme(theme);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就会调用<code>mInstrumentation.callActivityOnCreate</code>，在Instrumentation的一种重载方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Perform calling of an activity's &#123;<span class="doctag">@link</span> Activity#onCreate&#125;</span><br><span class="line"> * method.  The default implementation simply calls through to that method.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> activity The activity being created.</span><br><span class="line"> * <span class="doctag">@param</span> icicle The previously frozen state (or null) to pass through to onCreate().</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle)</span> </span>&#123;</span><br><span class="line">    prePerformCreate(activity);</span><br><span class="line">    activity.performCreate(icicle);</span><br><span class="line">    postPerformCreate(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>activity.performCreate(icicle)</code>会调用到Activity中的对应方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle)</span> </span>&#123;</span><br><span class="line">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">    onCreate(icicle);</span><br><span class="line">    mActivityTransitionState.readState(icicle);</span><br><span class="line">    performCreateCommon();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>onCreate(icicle)</code>会触发Activity的onCreate生命周期回调，至此Activity的启动流程大家就非常熟悉了，不再赘述。</p>
<p>Instrumentation源码中除了本小节之前的内容，其他主要就是跟Activity生命周期相关的逻辑，除了上述分析的启动逻辑，还有onStart()、onPause()、onResume()、onStop()、onDestroy()等过程，就不在一一分析。</p>
<h4 id="ActivityThread_u4E2D_u7684Instrumentation_u662F_u4F55_u65F6_u521D_u59CB_u5316_u7684"><a href="#ActivityThread_u4E2D_u7684Instrumentation_u662F_u4F55_u65F6_u521D_u59CB_u5316_u7684" class="headerlink" title="ActivityThread中的Instrumentation是何时初始化的"></a>ActivityThread中的Instrumentation是何时初始化的</h4><p>Instrumentation在ActivityThread中的声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Instrumentation mInstrumentation;</span><br></pre></td></tr></table></figure>
<p>从前文的分析可知，Activity创建之后调用attach方法中传入的Instrumentation就是ActivityThread中的，那么在ActivityThread中的Instrumentation是何时初始化的呢？</p>
<p>在ActivityThread中搜索，发现有几处为mInstrumentation赋值的地方：</p>
<p>1.ActivityThread的attach方法，方法声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当system参数为true时，会执行到如下为mInstrumentation赋值的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    mInstrumentation = <span class="keyword">new</span> Instrumentation();</span><br><span class="line">    ContextImpl context = ContextImpl.createAppContext(</span><br><span class="line">            <span class="keyword">this</span>, getSystemContext().mPackageInfo);</span><br><span class="line">    mInitialApplication = context.mPackageInfo.makeApplication(<span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">    mInitialApplication.onCreate();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Unable to instantiate Application():"</span> + e.toString(), e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主线程ActivityThread的main方法中system参数为false，故此时没有创建Instrumentation对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">thread.attach(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p>2.ActivityThread的handleBindApplication(AppBindData data)方法中，有如下逻辑：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">final</span> <span class="type">InstrumentationInfo</span> ii;</span><br><span class="line"><span class="title">if</span> (<span class="typedef"><span class="keyword">data</span>.instrumentationName != null) <span class="container">&#123;</span><br><span class="line">    <span class="title">try</span> &#123;</span><br><span class="line">        <span class="title">ii</span> = <span class="title">new</span> <span class="type">ApplicationPackageManager</span>(<span class="title">null</span>, <span class="title">getPackageManager</span>())</span><br><span class="line">                .<span class="title">getInstrumentationInfo</span>(<span class="title">data</span>.<span class="title">instrumentationName</span>, 0);</span><br><span class="line">    &#125;</span> catch <span class="container">(<span class="type">PackageManager</span>.<span class="type">NameNotFoundException</span> <span class="title">e</span>)</span> <span class="container">&#123;</span><br><span class="line">        <span class="title">throw</span> <span class="title">new</span> <span class="type">RuntimeException</span>(</span><br><span class="line">                "<span class="type">Unable</span> <span class="title">to</span> <span class="title">find</span> <span class="title">instrumentation</span> <span class="title">info</span> <span class="title">for</span>: " + <span class="title">data</span>.<span class="title">instrumentationName</span>);</span><br><span class="line">    &#125;</span></span></span><br><span class="line"></span><br><span class="line">    mInstrumentationPackageName = ii.packageName;</span><br><span class="line">    mInstrumentationAppDir = ii.sourceDir;</span><br><span class="line">    mInstrumentationSplitAppDirs = ii.splitSourceDirs;</span><br><span class="line">    mInstrumentationLibDir = getInstrumentationLibrary(<span class="typedef"><span class="keyword">data</span>.appInfo, ii);</span></span><br><span class="line">    mInstrumentedAppDir = <span class="typedef"><span class="keyword">data</span>.info.getAppDir<span class="container">()</span>;</span></span><br><span class="line">    mInstrumentedSplitAppDirs = <span class="typedef"><span class="keyword">data</span>.info.getSplitAppDirs<span class="container">()</span>;</span></span><br><span class="line">    mInstrumentedLibDir = <span class="typedef"><span class="keyword">data</span>.info.getLibDir<span class="container">()</span>;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ii = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Continue loading instrumentation.</span></span><br><span class="line"><span class="keyword">if</span> (ii != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> ApplicationInfo instrApp = <span class="keyword">new</span> ApplicationInfo();</span><br><span class="line">    ii.copyTo(instrApp);</span><br><span class="line">    instrApp.initForUser(UserHandle.myUserId());</span><br><span class="line">    <span class="keyword">final</span> LoadedApk pi = getPackageInfo(instrApp, data.compatInfo,</span><br><span class="line">            appContext.getClassLoader(), <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">final</span> ContextImpl instrContext = ContextImpl.createAppContext(<span class="keyword">this</span>, pi);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> ClassLoader cl = instrContext.getClassLoader();</span><br><span class="line">        mInstrumentation = (Instrumentation)</span><br><span class="line">            cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Unable to instantiate instrumentation "</span></span><br><span class="line">            + data.instrumentationName + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ComponentName component = <span class="keyword">new</span> ComponentName(ii.packageName, ii.name);</span><br><span class="line">    mInstrumentation.init(<span class="keyword">this</span>, instrContext, appContext, component,</span><br><span class="line">            data.instrumentationWatcher, data.instrumentationUiAutomationConnection);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mProfiler.profileFile != <span class="keyword">null</span> &amp;&amp; !ii.handleProfiling</span><br><span class="line">            &amp;&amp; mProfiler.profileFd == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mProfiler.handlingProfiling = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> File file = <span class="keyword">new</span> File(mProfiler.profileFile);</span><br><span class="line">        file.getParentFile().mkdirs();</span><br><span class="line">        Debug.startMethodTracing(file.toString(), <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mInstrumentation = <span class="keyword">new</span> Instrumentation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当data.instrumentationName不为null时，即必须在AndroidManifest.xml中声明了Instrumentation标签才行，否则不会执行，此时会构造一个InstrumentationInfo对象ii，接下来会使用类加载器构造一个Instrumentation实例。</p>
<p>如果AndroidManifest.xml中没有声明Instrumentation标签，即data.instrumentationName为null时，则直接通过new来创建一个Instrumentation实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mInstrumentation = <span class="keyword">new</span> Instrumentation();</span><br></pre></td></tr></table></figure>
<p>一般应用都会在ActivityThread启动后，通过此方式创建Instrumentation的实例，该行为在应用其他组件创建之前。在一个应用进程中，各个Activity中的Instrumentation都是由ActivityThread传入的，它们归根溯源是同一个。</p>
<h3 id="Instrumentation_u603B_u7ED3"><a href="#Instrumentation_u603B_u7ED3" class="headerlink" title="Instrumentation总结"></a>Instrumentation总结</h3><p>通过上述源码梳理，发现Instrumentation是一个非常重要的类，甚至Application、Activity的生命周期都与其相关。它的功能大概可以总结为三个方面：</p>
<ol>
<li><p>参与Application、Activity的生命周期逻辑</p>
</li>
<li><p>用于Android单元测试</p>
</li>
<li><p>由于Instrumentation独特的运行时机，对于Application、Activity举足轻重的控制权，因此可以进行一些hook操作，具体可参考以下几篇文章：</p>
<ol>
<li><a href="http://m.blog.csdn.net/article/details?id=52078445" target="_blank" rel="external">Android中Hook Instrumentation的一些思考</a></li>
<li><a href="http://tech.meituan.com/mt-android-auto-split-dex.html" target="_blank" rel="external">美团Android DEX自动拆包及动态加载简介</a></li>
<li><a href="http://zhengxiaoyong.me/2016/07/18/Android%E7%AB%AF%E5%BA%94%E7%94%A8%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E4%BD%93%E9%AA%8C/" target="_blank" rel="external">Android端应用秒开优化体验</a></li>
</ol>
<p>​</p>
</li>
</ol>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/01/19/面对五花八门的新技术，如何看待与学习/">面对五花八门的新技术，如何看待与学习</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-01-19
        </span>
        
          <div class="post-category">
            
              <a href="/categories/杂谈/">杂谈</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <blockquote>
<p>A：最近VR很火啊，大家都在争夺这片蓝海，要学习VR了！</p>
<p>B：Google开源TensorFlow了，看来人工智能（Artificial Intelligence）是发展方向啊！</p>
<p>C：微信推出小程序了，是不是Android、iOS程序员要失业了？赶紧学一番！</p>
<p>D：大数据时代来了，是不是要学一下Python呢？</p>
<p>E：React、Vue都不知道还好意思说是做前端的！学起来！</p>
<p>F：……</p>
</blockquote>
<p>现在的程序员真是幸福，因为有太多的新技术可以用来解决问题；同时现在的程序员真是痛苦，太多的新技术层出不穷，根本没有时间和精力去学习。相信很多程序员有这样的想法。这里分享一下针对新技术如何看待与学习的个人观点：</p>
<h3 id="u4E0D_u8981_u8D2A_u591A"><a href="#u4E0D_u8981_u8D2A_u591A" class="headerlink" title="不要贪多"></a>不要贪多</h3><p>虽然有俗语曰：技多不压身，但现在的技术多如牛毛，且要学精每一门都需要耗费大量精力，如少林七十二绝技，精通一两门已能纵横江湖。对于技术，建议不要贪多，专注于一两门，精益求精，切不可见一门学一门，最终导致没有一门精通。当然天才排除在外，大多数人由于工作需要、时间精力等因素，往往无法做到兼收多门技术。</p>
<p>先专注于自己工作需要的技术吧！有人说我不学某个技术是不是以后都找不到工作了，这个观点其实很难成立，在一个很长的时间段内，每一门技术的存在都有其用武之地，就像360行，行行出状元。</p>
<h3 id="u4E0D_u8981_u8DDF_u98CE"><a href="#u4E0D_u8981_u8DDF_u98CE" class="headerlink" title="不要跟风"></a>不要跟风</h3><p>技术人员在聊天或逛论坛时发现某人在学习某技术，经常心动，自己也想来学习一下。如看到有人用Python爬取数据，觉得非常好玩，也想学一下；看到有人学习WebKit，发现也很有意思，又想涉猎一下……也许程序员对新技术有着天生的嗅觉与敏锐感，于是他们有了上述的痛苦。</p>
<p>建议大家不要跟风，有人用Python是由于工作需要或者人家专注于Python，而你做Android开发的，眼前只需要专注于Java与Linux。不要觉得自己的领域已经没东西可学了（大神除外），Java所有API、新特性都熟练掌握了吗？Java虚拟机规范及虚拟机运行原理了解吗？Linux操作系统原理了解吗？Linux内核熟练掌握了吗？往往知道的越多发现需要学习的越多，越觉得个人的渺小。</p>
<p>先把自己工作领域的技术都吃透吧！有人说去面试Android开发，但没用过RxAndroid、没用过OkHttp、没用过React Native，面试官觉得技术不行。我想说的是，如果你Java及Android开发经验很好，但由于没用过这几个框架而被拒的话，这是你的幸运，如此本末倒置的公司还是放弃为好。我在面试应聘者的时候，从来不对Android框架做硬性要求，不知道或没用过不代表技术不行，闻道有先后、术业有专攻。只要你基础知识足够扎实，学习一个框架那是非常快的事情，甚至可以自己写一个框架出来。</p>
<p>不要跟风学习各种框架，先把基本功打好，等真正需要使用的时候再去学习，否则累个半死也学不过来。</p>
<h3 id="u4E0E_u65F6_u4FF1_u8FDB"><a href="#u4E0E_u65F6_u4FF1_u8FDB" class="headerlink" title="与时俱进"></a>与时俱进</h3><p>这一点需要辩证地来看待，上面提到在短期内需要专注于一两门技术深挖。但也不能一直死守这一两门技术，譬如VB、Pascal等编程语言已经慢慢地被淡忘，技术都有其时代的局限性。同时这需要大家的判断能力，预测未来的技术发展方向，也确定自己的学习方向。需要多思考，这一点尤其重要，比如十年后移动开发会怎样，会不会被Web所替代；人工智能会发展到怎样，也许到时候都不用人来敲代码了。多思考就会知道自己需要去学习什么，而不是被动地跟风。</p>
<p>学无止境，但希望大家快乐地学习技术。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/01/19/App内存占用优化/">App内存占用优化</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-01-19
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="u4F18_u5316App_u5185_u5B58_u4F7F_u7528"><a href="#u4F18_u5316App_u5185_u5B58_u4F7F_u7528" class="headerlink" title="优化App内存使用"></a>优化App内存使用</h2><p>RAM（Random-access memory）在任何软件开发中都是非常宝贵的资源，移动操作系统由于其物理内存的局限性更是如此。尽管ART（Android Runtime）与Dalvik虚拟机会执行常规的垃圾回收，但这并不意味着可以忽略App中的内存分配与释放。我们应当避免引起内存泄露，如持有静态成员变量而导致无法释放，应当在应用的生命周期回调中释放掉所有的引用。</p>
<p>本文主要介绍如何减少App中的内存使用。</p>
<h3 id="u76D1_u63A7_u53EF_u7528_u5185_u5B58_u53CA_u5185_u5B58_u4F7F_u7528_u72B6_u51B5"><a href="#u76D1_u63A7_u53EF_u7528_u5185_u5B58_u53CA_u5185_u5B58_u4F7F_u7528_u72B6_u51B5" class="headerlink" title="监控可用内存及内存使用状况"></a>监控可用内存及内存使用状况</h3><p>Android 框架与Android Studio可以帮助我们来分析和调整App的内存使用，其中Android框架提供了一些API来帮助App在运行时动态减少内存占用，Android Studio包括一些工具来查看内存的使用情况。</p>
<h4 id="RAM_u4F7F_u7528_u5206_u6790_u5DE5_u5177"><a href="#RAM_u4F7F_u7528_u5206_u6790_u5DE5_u5177" class="headerlink" title="RAM使用分析工具"></a>RAM使用分析工具</h4><p>在优化内存问题之前，需要先找到这些问题，Android Studio及Android SDK提供了几个工具用来分析App中的内存使用：</p>
<ol>
<li><p>Android Studio中的Memory Monitor</p>
<p>该工具可以显示一个会话过程中的内存分配情况，有一个可视化的图形界面，可以看到Java内存随时间的变化情况以及GC事件。当App运行时，可以启动GC操作并且获取Java Heap的快照。该工具的输出可以帮助我们定位哪里容易导致频繁的垃圾回收，从而导致应用程序变慢。</p>
</li>
<li><p>Android Studio中的Allocation Tracker工具</p>
<p>该工具记录了一个App的内存分配情况并在分析快照中列出了所有分配的对象。可以使用此工具找到分配过多对象的部分代码。</p>
</li>
</ol>
<h4 id="u54CD_u5E94_u56DE_u8C03_u91CA_u653E_u5185_u5B58"><a href="#u54CD_u5E94_u56DE_u8C03_u91CA_u653E_u5185_u5B58" class="headerlink" title="响应回调释放内存"></a>响应回调释放内存</h4><p>不同的Android设备或不同的用户操作会导致不同的内存占用状况，Android系统在遇到内存压力的情况下会发出信号预警，App需要监听这些信号来调整内存的使用。</p>
<p>可以使用<code>ComponentCallbacks2</code> API来监听回调以调整内存使用状态。<code>onTrimMemory()</code>可以允许App监听内存相关的事件，无论App是在前台运行还是在后台运行。下面是一个示例，通过实现Activity的<code>onTrimMemory()</code>方法来监听内存相关的回调。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.ComponentCallbacks2;</span><br><span class="line"><span class="comment">// Other import statements ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title">ComponentCallbacks2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Other activity code ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Release memory when the UI becomes hidden or when system resources become low.</span><br><span class="line">     * <span class="doctag">@param</span> level the memory-related event that was raised.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Determine which lifecycle or system event was raised.</span></span><br><span class="line">        <span class="keyword">switch</span> (level) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN:</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span><br><span class="line">                   Release any UI objects that currently hold memory.</span><br><span class="line"></span><br><span class="line">                   The user interface has moved to the background.</span><br><span class="line">                */</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE:</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW:</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL:</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span><br><span class="line">                   Release any memory that your app doesn't need to run.</span><br><span class="line"></span><br><span class="line">                   The device is running low on memory while the app is running.</span><br><span class="line">                   The event raised indicates the severity of the memory-related event.</span><br><span class="line">                   If the event is TRIM_MEMORY_RUNNING_CRITICAL, then the system will</span><br><span class="line">                   begin killing background processes.</span><br><span class="line">                */</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_BACKGROUND:</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_MODERATE:</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_COMPLETE:</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span><br><span class="line">                   Release as much memory as the process can.</span><br><span class="line"></span><br><span class="line">                   The app is on the LRU list and the system is running low on memory.</span><br><span class="line">                   The event raised indicates where the app sits within the LRU list.</span><br><span class="line">                   If the event is TRIM_MEMORY_COMPLETE, the process will be one of</span><br><span class="line">                   the first to be terminated.</span><br><span class="line">                */</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">/*</span><br><span class="line">                  Release any non-critical data structures.</span><br><span class="line"></span><br><span class="line">                  The app received an unrecognized memory level value</span><br><span class="line">                  from the system. Treat this as a generic low-memory message.</span><br><span class="line">                */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>onTrimMemory()</code>回调是在Android4.0（API Level 14）添加的，对于之前的版本，可以使用<code>onLowMemory()</code>回调替代，它大致相当于<code>TRIM_MEMORY_COMPLETE</code>事件。</p>
<h4 id="u68C0_u6D4B_u5E94_u8BE5_u4F7F_u7528_u591A_u5C11_u5185_u5B58"><a href="#u68C0_u6D4B_u5E94_u8BE5_u4F7F_u7528_u591A_u5C11_u5185_u5B58" class="headerlink" title="检测应该使用多少内存"></a>检测应该使用多少内存</h4><p>Android为了支持多进程，因此为每个App占用的内存做了限制。由于不同设备的RAM大小不同，因此分配给每个App的Heap大小也会有差异。当App已经到达了特定的Heap限制，如果再进行内存分配的话，就会抛出 <code>OutOfMemoryError</code>异常。</p>
<p>为了避免内存溢出，我们可以通过<code>getMemoryInfo()</code>查询当前设备上还有多少可用的内存空间，该方法返回一个<code>ActivityManager.MemoryInfo</code>对象，它包含了设备当前的内存状态，如可用内存、总内存以及内存阈值（当可用内存低于该阈值时，系统就会杀死部分进程）等信息。<code>ActivityManager.MemoryInfo</code>有一个叫做<code>lowMemory</code>的布尔属性，表示设备是否处于低内存状态。</p>
<p>下面是一个使用<code>getMemoryInfo()</code>的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingMemoryIntensive</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before doing something that requires a lot of memory,</span></span><br><span class="line">    <span class="comment">// check to see whether the device is in a low memory state.</span></span><br><span class="line">    ActivityManager.MemoryInfo memoryInfo = getAvailableMemory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!memoryInfo.lowMemory) &#123;</span><br><span class="line">        <span class="comment">// Do memory intensive work ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get a MemoryInfo object for the device's current memory status.</span></span><br><span class="line"><span class="keyword">private</span> ActivityManager.<span class="function">MemoryInfo <span class="title">getAvailableMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ActivityManager activityManager = (ActivityManager) <span class="keyword">this</span>.getSystemService(ACTIVITY_SERVICE);</span><br><span class="line">    ActivityManager.MemoryInfo memoryInfo = <span class="keyword">new</span> ActivityManager.MemoryInfo();</span><br><span class="line">    activityManager.getMemoryInfo(memoryInfo);</span><br><span class="line">    <span class="keyword">return</span> memoryInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u4F7F_u7528_u9AD8_u6548_u3001_u5185_u5B58_u5360_u7528_u5C11_u7684_u4EE3_u7801_u7ED3_u6784"><a href="#u4F7F_u7528_u9AD8_u6548_u3001_u5185_u5B58_u5360_u7528_u5C11_u7684_u4EE3_u7801_u7ED3_u6784" class="headerlink" title="使用高效、内存占用少的代码结构"></a>使用高效、内存占用少的代码结构</h3><p>一些Android特性、Java类、代码结构会使用更多的内存，可通过使用更高效的代码结构来节省内存。</p>
<h4 id="u6709_u8282_u5236_u5730_u4F7F_u7528Service"><a href="#u6709_u8282_u5236_u5730_u4F7F_u7528Service" class="headerlink" title="有节制地使用Service"></a>有节制地使用Service</h4><p>让一个不再需要的Service保持运行是Android开发中最糟糕的内存管理错误之一。如果App需要Service来执行后台任务，需要在它完成任务时终止它，否则可能导致内存泄露。</p>
<p>当启动一个Service时，系统会保持该服务所在的进程，这样该服务占用的内存将不能被其他进程使用。同时系统通过LRU Cache缓存的的进程数量也将减少，从而降低进程间切换的效率。当内存紧张或系统无法为当前所运行的Service提供足够的进程时还会发生系统抖动。</p>
<p>应当避免使用持久运行的Service，因为它们对内存有持续的需求，建议使用<code>JobScheduler</code>。</p>
<p>如果必须使用Service，可以使用<code>IntentService</code>来限制其生命周期，<code>IntentService</code>会在处理完任务之后终止。</p>
<h4 id="u4F7F_u7528_u4F18_u5316_u7684_u6570_u636E_u5BB9_u5668"><a href="#u4F7F_u7528_u4F18_u5316_u7684_u6570_u636E_u5BB9_u5668" class="headerlink" title="使用优化的数据容器"></a>使用优化的数据容器</h4><p>一些编程语言提供的类可能并未针对移动设备做优化，例如通用的HashMap实现是比较低效的，因为每一个映射都需要一个单独的Entry对象。</p>
<p>Android框架提供了一些优化过的数据容器，如<code>SparseArray</code>、<code>SparseBooleanArray</code>和<code>LongSparseArray</code>。例如<code>SparseArray</code>更加高效，是因为它避免了对key及一些value的自动装箱操作。</p>
<h4 id="u8C28_u614E_u4F7F_u7528_u4EE3_u7801_u62BD_u8C61"><a href="#u8C28_u614E_u4F7F_u7528_u4EE3_u7801_u62BD_u8C61" class="headerlink" title="谨慎使用代码抽象"></a>谨慎使用代码抽象</h4><p>开发者经使用抽象来简化编程，因为抽象可以提高代码的灵活性，也更方便维护。但是抽象会带来明显的内存消耗：抽象一般来说需要执行更多的代码、需要更多的时间以及RAM空间来将代码映射到内存。所以如果抽象不能带来明显的好处，应当避免使用代码抽象。</p>
<p>例如，枚举占用的内存通常是静态常量的两倍，需要严格避免在Android中使用枚举。</p>
<h4 id="u4F7F_u7528Nano_u7248_u672Cprotobufs_u5E8F_u5217_u5316_u6570_u636E"><a href="#u4F7F_u7528Nano_u7248_u672Cprotobufs_u5E8F_u5217_u5316_u6570_u636E" class="headerlink" title="使用Nano版本protobufs序列化数据"></a>使用Nano版本protobufs序列化数据</h4><p><a href="https://developers.google.cn/protocol-buffers/docs/overview" target="_blank" rel="external">Protocol buffers</a>是Google出品的独立于平台及语言的、可拓展的结构化数据序列化技术，它类似于XML，但更加轻量级、快速、简洁。如果决定使用protobufs来序列化数据，应该在客户端选择使用Nano版本，因为常规版本的protobufs会生成极其冗长的代码，从而导致App端出现各种问题，如内存溢出、APK大小增加、执行速度变慢等。</p>
<p>Nano版本Protobufs的相关参考：<a href="https://android.googlesource.com/platform/external/protobuf/+/master/java/README.txt" target="_blank" rel="external">protobuf readme</a>。</p>
<h4 id="u907F_u514D_u5185_u5B58_u6CC4_u9732"><a href="#u907F_u514D_u5185_u5B58_u6CC4_u9732" class="headerlink" title="避免内存泄露"></a>避免内存泄露</h4><p>垃圾回收通常不会影响应用的性能，但是短时间内的垃圾收集将会占用帧时间，垃圾回收占用的时间越多，用到其他事情上的时间就越少。</p>
<p>通常，内存泄露会导致频繁地垃圾回收事件的发生，在实践中，内存泄露描述了给定时间内分配的临时对象的数量。</p>
<p>例如，可能在for循环中分配多个临时对象，或者在View的<code>onDraw()</code>方法中创建多个Paint、Bitmap对象。上述情况下，App会快速创建大量对象，从而迅速消耗掉新生代中的内存，导致GC的发生。</p>
<p>我们需要找到内存泄露的地方并进行修复，如将实例化操作移出for循环，不要在<code>onDraw()</code>这种频繁调用的方法中创建对象。</p>
<h3 id="u79FB_u9664_u5185_u5B58_u5BC6_u96C6_u578B_u7684_u8D44_u6E90_u548C_u5E93"><a href="#u79FB_u9664_u5185_u5B58_u5BC6_u96C6_u578B_u7684_u8D44_u6E90_u548C_u5E93" class="headerlink" title="移除内存密集型的资源和库"></a>移除内存密集型的资源和库</h3><p>代码中的一些资源及Library可能会在我们不知情的情况下吞噬内存。一个APK中，第三方库或者嵌入的资源会影响到App占用的内存总量。可以通过移除冗余的资源、臃肿的组件及不必要的Library来优化内存消耗。</p>
<h4 id="u51CF_u5C0FAPK_u5927_u5C0F"><a href="#u51CF_u5C0FAPK_u5927_u5C0F" class="headerlink" title="减小APK大小"></a>减小APK大小</h4><p>通过减小APK的大小可以明显减低App对内存的占用。Bitmap大小、资源、动画帧图像以及第三方库影响APK的大小，Android Studio及Android SDK提供了一些工具用来减少资源大小及外部依赖。</p>
<p>更多关于APK的瘦身方案，可参考<a href="https://developer.android.google.cn/topic/performance/reduce-apk-size.html" target="_blank" rel="external">Reduce APK Size</a>。</p>
<h4 id="u4F7F_u7528Dagger2_u5B9E_u73B0_u4F9D_u8D56_u6CE8_u5165"><a href="#u4F7F_u7528Dagger2_u5B9E_u73B0_u4F9D_u8D56_u6CE8_u5165" class="headerlink" title="使用Dagger2实现依赖注入"></a>使用Dagger2实现依赖注入</h4><p>依赖注入框架可以简化代码并为测试及其他配置变化提供适配环境。</p>
<p>如果打算在App中使用依赖注入框架的话，建议使用<a href="http://google.github.io/dagger/" target="_blank" rel="external">Dagger2</a>。Dagger没有使用反射，它的静态、编译时实现意味着它不需要运行时成本及内存消耗。</p>
<p>其他使用反射的依赖注入框架需要扫描代码来寻找注解，这个过程可能需要更多的CPU周期和RAM，并可能导致应用程序启动的明显滞后。</p>
<h4 id="u8C28_u614E_u4F7F_u7528_u5916_u90E8Library"><a href="#u8C28_u614E_u4F7F_u7528_u5916_u90E8Library" class="headerlink" title="谨慎使用外部Library"></a>谨慎使用外部Library</h4><p>第三方的Library代码可能并非为移动环境所写，当应用到移动客户端时可能导致性能降低。当决定使用一个第三方库时，需要针对移动环境做优化，另外需要分析Library的代码大小及内存占用情况，最后再决定是否应用该Library。</p>
<p>哪怕是一些针对移动环境做过优化的Library因为不同的实现也可能导致一些问题，如一种情况使用了Nano版的protobufs，另一种情况使用了Micro版的protobufs，不同的Library实现有可能导致意想不到的问题。</p>
<p>尽管<a href="https://developer.android.google.cn/tools/help/proguard.html" target="_blank" rel="external">Proguard</a>可以移除无效的API及资源，但是它无法移除一个Library大的内部依赖。这些库中的功能可能需要较低的依赖项，例如当使用一个库提供的Activity子类时，可能会引入大量的依赖。</p>
<p>需要避免只使用一个库中的有限的功能而引入库的情况，我们不希望引入大量不需要的代码。当决定是否使用一个Library时，尽可能高度匹配我们的需求，否则，可以考虑自己实现。</p>
<p>参考文献<a href="https://developer.android.google.cn/topic/performance/memory.html" target="_blank" rel="external">Manage Your App’s Memory</a>。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/01/19/Android高性能编码最佳实践/">Android高性能编码最佳实践</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-01-19
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>本文主要讲一些代码级别的细微优化，但别小看这些，当它们组合起来的时候就能提高App的整体性能。这类的优化不同于算法与数据结构优化所能达到的显著效果，但我们应该把它作为自己的编码习惯从而写出高效的代码。</p>
<p>写出高效代码的两个基本原则：</p>
<ul>
<li>不要做不必要的事情</li>
<li>不要分配不必要的内存</li>
</ul>
<p>优化一个App时最棘手的问题在于它可能运行于不同的硬件设备上，不同的虚拟机版本、不同的处理器从而导致不同的运行速度；设备有无JIT也将导致不同的性能。为了保证在不同的设备上都有较好的性能，我们就需要从代码层面进行优化，确保代码可以高效地执行。</p>
<h3 id="u907F_u514D_u521B_u5EFA_u4E0D_u5FC5_u8981_u7684_u5BF9_u8C61"><a href="#u907F_u514D_u521B_u5EFA_u4E0D_u5FC5_u8981_u7684_u5BF9_u8C61" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h3><p>对象创建是有开销的，我们需要尽可能避免创建过多临时性的对象，一旦为App创建了过多的对象，那就意味着频繁地垃圾回收。频繁地垃圾回收会对用户体验造成不良影响，虽然Android 2.3之后，垃圾回收不再是“Stop-The-World”，可以并发执行了，但我们仍需要避免不必要的对象创建。以下示例可作为参考：</p>
<ul>
<li>如果一个方法返回String结果并且该结果将会被附加到一个StringBuffer上，则可以修改方法的实现直接处理附加操作，从而避免创建一个临时对象。</li>
<li>如果从一个输入中提取字符串，尽可能返回原始数据的一个子串而不是原始数据的拷贝。你将创建一个新的String对象，但可以与原始数据共享char[]。</li>
</ul>
<p>一种比较激进的方法是将多维数组分割成多个平行的一维数组：</p>
<ul>
<li>int数组比Integer数组更高效，也可以推广到两个平行的int数组比二维数组（int, int）更加高效，对于任何其他原始类型的组合也一样。</li>
<li>如果想实现类似（Foo,Bar）的元组对象，尽量使用两个平行的数组：Foo[]与Bar[]。当然如果我们是在实现对外的API，则需要对此做一个折中，牺牲一点速度，从而实现一个好的API设计。但对于我们内部代码来说，应该尽可能地高效。</li>
</ul>
<p>总的来说，尽量避免不必要的对象创建，创建的对象越少，意味着垃圾回收的频率也越低，这将直接影响到用户的体验。</p>
<h3 id="u4F18_u5148_u4F7F_u7528Static_u65B9_u6CD5"><a href="#u4F18_u5148_u4F7F_u7528Static_u65B9_u6CD5" class="headerlink" title="优先使用Static方法"></a>优先使用Static方法</h3><p>如果不需要访问一个对象的属性，可以将方法声明为static，这样做可以使该方法的调用速度提高15%-20%。这是一种好的做法，从而可以通知方法签名调用该方法并不会改变对象的属性状态。</p>
<h3 id="u4F7F_u7528static_u548Cfinal_u6765_u4FEE_u9970_u5E38_u91CF"><a href="#u4F7F_u7528static_u548Cfinal_u6765_u4FEE_u9970_u5E38_u91CF" class="headerlink" title="使用static和final来修饰常量"></a>使用static和final来修饰常量</h3><p>来看类中的如下声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> intVal = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">static</span> String strVal = <span class="string">"Hello, world!"</span>;</span><br></pre></td></tr></table></figure>
<p>当该类第一次被使用时，编译器会生成一个叫做<clinit>的类初始化方法，该方法会将42存储到intVal中并为strVal返回一个类文件字符串常量表中的一个引用。当这些变量被调用的时候，它们通过字段查找的方式被访问。</clinit></p>
<p>我们可以使用final关键字来优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> intVal = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String strVal = <span class="string">"Hello, world!"</span>;</span><br></pre></td></tr></table></figure>
<p>这样一来该类不再需要<clinit>方法，因为上述常量将会使用静态字段初始化。调用intVal时将会直接使用整型值42，访问strVal时将会使用开销更小的字符串常量而不是字段查找。</clinit></p>
<blockquote>
<p>注意：这个优化只针对原始类型及String常量。</p>
</blockquote>
<h3 id="u907F_u514D_u5185_u90E8_u7684Getters/Setters"><a href="#u907F_u514D_u5185_u90E8_u7684Getters/Setters" class="headerlink" title="避免内部的Getters/Setters"></a>避免内部的Getters/Setters</h3><p>在C++这样的语言中，经常使用getters（如i=getCount()）来代替直接的字段访问（如i=mCount），这个特性同样被用于C#、Java等面向对象的语言中。</p>
<p>然而在Android中，这样使用并不是一个好习惯。方法调用比字段查找的开销更大，虽然从面向对象编程的角度来看应该使用getters与setters，但在一个类的内部，应该尽可能直接访问字段。</p>
<p>在没有JIT的情况下，直接对字段进行访问比调用getter方法大概要快3倍；有JIT的情况下，直接对字段进行访问比getter大概要快7倍。</p>
<h3 id="u4F7F_u7528_u589E_u5F3A_u7684for_u5FAA_u73AF_u8BED_u6CD5"><a href="#u4F7F_u7528_u589E_u5F3A_u7684for_u5FAA_u73AF_u8BED_u6CD5" class="headerlink" title="使用增强的for循环语法"></a>使用增强的for循环语法</h3><p>增强的for循环如for-each，可以用于实现了Iterable接口的集合、数组。以下示例是几种遍历数组的方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mSplat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo[] mArray = ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mArray.length; ++i) &#123;</span><br><span class="line">        sum += mArray[i].mSplat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    Foo[] localArray = mArray;</span><br><span class="line">    <span class="keyword">int</span> len = localArray.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        sum += localArray[i].mSplat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">two</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Foo a : mArray) &#123;</span><br><span class="line">        sum += a.mSplat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法zero()是最慢的，因为每一次循环时都要获取数组长度，这个开销JIT无法优化。</p>
<p>方法one()比zero()快，它把所有变量都存储为局部变量，避免了查找，优化了获取数组长度的性能开销。</p>
<p>方法two()使用了增强的for循环语法，在无JIT时是最快的；在有JIT的情况下，它跟方法one()的性能大概类似。</p>
<h3 id="u5BF9_u4E8E_u79C1_u6709_u5185_u90E8_u7C7B_uFF0C_u4F7F_u7528_u5305_u8BBF_u95EE_u6743_u9650_u4EE3_u66FF_u79C1_u6709_u8BBF_u95EE_u6743_u9650"><a href="#u5BF9_u4E8E_u79C1_u6709_u5185_u90E8_u7C7B_uFF0C_u4F7F_u7528_u5305_u8BBF_u95EE_u6743_u9650_u4EE3_u66FF_u79C1_u6709_u8BBF_u95EE_u6743_u9650" class="headerlink" title="对于私有内部类，使用包访问权限代替私有访问权限"></a>对于私有内部类，使用包访问权限代替私有访问权限</h3><p>看下面这个类的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">stuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Foo.<span class="keyword">this</span>.doStuff(Foo.<span class="keyword">this</span>.mValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        mValue = <span class="number">27</span>;</span><br><span class="line">        in.stuff();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStuff</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Value is "</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，Foo类中定义了一个内部类Inner，这个内部类直接访问了外部类的私有方法及私有成员字段。这是合法的，最终代码会输出“Value is 27”。</p>
<p>但是从虚拟机角度来看，从内部类Inner直接访问外部类Foo的私有方法及成员是不合法的，因为它们是两个不同的类。为了使得它们可以直接访问，编译器生成了一些合成方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">int</span> Foo.access$<span class="number">100</span>(Foo foo) &#123;</span><br><span class="line">    <span class="keyword">return</span> foo.mValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">void</span> Foo.access$<span class="number">200</span>(Foo foo, <span class="keyword">int</span> value) &#123;</span><br><span class="line">    foo.doStuff(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当Inner需要访问外部类的私有方法及成员变量时就会调用上述静态方法。这意味着需要通过合成的访问器方法来访问变量，因为会比直接访问要慢，这也可以作为一个示例，说明了一些不可见的性能损耗。</p>
<p>为了避免上述情况的性能开销，可以将被内部类访问方法及变量声明为包访问权限而不是私有访问权限。但这就意味着可以被同包的其他类直接访问，因此最好不要出现在公有API中。</p>
<h3 id="u907F_u514D_u4F7F_u7528_u6D6E_u70B9_u578B"><a href="#u907F_u514D_u4F7F_u7528_u6D6E_u70B9_u578B" class="headerlink" title="避免使用浮点型"></a>避免使用浮点型</h3><p>众所周知，在Android设备上浮点型比整型大概慢2倍。</p>
<p>从速度方面来看，float与double在现代硬件设备上几乎没有什么区别。从空间开销角度来看，double是float的2倍。对于台式机来说，假如空间不是问题，那么应该优先选择double。</p>
<p>对于整型来说，一些处理器有硬件乘法而缺少硬件除法支持，这种情况下，整型除法以及求模运算需要在软件层面处理，比如设计一个哈希表或进行大量的数学运算。</p>
<h3 id="u4E86_u89E3_u5E76_u4F7F_u7528Library"><a href="#u4E86_u89E3_u5E76_u4F7F_u7528Library" class="headerlink" title="了解并使用Library"></a>了解并使用Library</h3><p>In addition to all the usual reasons to prefer library code over rolling your own, bear in mind that the system is at liberty to replace calls to library methods with hand-coded assembler, which may be better than the best code the JIT can produce for the equivalent Java. The typical example here is <code>String.indexOf()</code> and related APIs, which Dalvik replaces with an inlined intrinsic. Similarly, the <code>System.arraycopy()</code> method is about 9x faster than a hand-coded loop on a Nexus One with the JIT.</p>
<h3 id="u8C28_u614E_u4F7F_u7528Native_u65B9_u6CD5"><a href="#u8C28_u614E_u4F7F_u7528Native_u65B9_u6CD5" class="headerlink" title="谨慎使用Native方法"></a>谨慎使用Native方法</h3><p>使用Android NDK写Native代码来实现App功能不一定比使用Java高效。例如，Java与Native的交互需要开销，并且JIT无法对此进行优化。一旦为Native资源分配内存（如在Native heap中），就意味着很难安排收集这些资源，并且需要为不同的CPU架构来编译不同的版本，甚至需要为相同的架构编译多个版本：如为G1的ARM处理器编译的Native代码并不能在Nexus One上充分发挥性能，而为Nexus One的ARM编译的代码则无法在G1的ARM上运行。</p>
<p>当我们想将已有的Native代码库用到Android的时候，我们才应该使用Native代码，而并非为了提升Java代码模块的速度使用Native代码。</p>
<p>如果需要使用Native代码，需要了解<a href="https://developer.android.google.cn/training/articles/perf-jni.html" target="_blank" rel="external">JNI</a>的相关知识。</p>
<h3 id="u6027_u80FD_u795E_u8BDD"><a href="#u6027_u80FD_u795E_u8BDD" class="headerlink" title="性能神话"></a>性能神话</h3><p>在没有JIT的情况下，通过明确类型的对象来调用方法比接口调用要快一些，如HashMap对象的方法调用快于Map接口，两者的效率大概相差6%左右，如果有JIT，则两者效率几乎是相同的。</p>
<p>在没有JIT的情况下，缓存字段的访问比重复访问某个字段快20%；有JIT时，字段访问开销跟本地访问相同，所以除非你觉得会让代码更易阅读，否则这不需要优化。</p>
<h3 id="u6301_u7EED_u8861_u91CF"><a href="#u6301_u7EED_u8861_u91CF" class="headerlink" title="持续衡量"></a>持续衡量</h3><p>在进行优化之前，最好先确认你需要解决的问题，务必确保能够精确衡量到目前的性能状态，否则即使优化之后，你也无法衡量优化所带来的性能提升。</p>
<p>你可能会使用<a href="https://developer.android.google.cn/studio/profile/traceview.html" target="_blank" rel="external">Traceview</a>来进行分析，但是需要意识到，使用Traceview时是禁用JIT的，因此可能会导致当你觉得性能不佳，但使用JIT后，性能又会显著提升的情况。当你根据Traceview的建议修改之后，务必要确保在没有Traceview的情况下，优化后的代码比以前的速度更快。</p>
<p>参考文献<a href="https://developer.android.google.cn/training/articles/perf-tips.html" target="_blank" rel="external">Performance Tips</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/12/19/Android布局性能优化指南/">Android布局性能优化指南</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-12-19
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>Android布局是应用的重要组成部分，它直接影响到用户的体验。如果布局不合理则会导致内存占用过多且UI卡顿。Android SDK提供了一些工具可以帮助我们快速定位到影响性能的布局问题，一般可从以下几个方面来进行布局优化。</p>
<h3 id="u4F18_u5316_u5E03_u5C40_u5C42_u6B21_u7ED3_u6784"><a href="#u4F18_u5316_u5E03_u5C40_u5C42_u6B21_u7ED3_u6784" class="headerlink" title="优化布局层次结构"></a>优化布局层次结构</h3><p>众所周知，复杂的网页加载速度很慢，Android应用也一样，复杂的布局结构也将引起性能问题。下面来说明如何使用工具来检查布局并发现性能瓶颈。</p>
<p>我们知道，应用中的每个组件及布局都需要初始化、测量、绘制等流程，例如使用了嵌套的LinearLayout将会导致更深的View层次，一旦嵌套的LinearLayout使用了layout_weight属性则将导致更长的加载时间，因为每个子控件将被测量两次。这种影响在ListView或GridView中将会更加明显，因为这两个控件的每一个Item都会重用一套布局。</p>
<p>我们将使用Hierarchy Viewer来检查并优化布局。</p>
<h4 id="u68C0_u67E5_u5E03_u5C40"><a href="#u68C0_u67E5_u5E03_u5C40" class="headerlink" title="检查布局"></a>检查布局</h4><p>Hierarchy Viewer是Android SDK tools提供的一个工具，它位于sdk/tools/目录下，可以用来分析布局并发现其中的性能瓶颈。需要注意到是使用Hierarchy Viewer时需要保持App正在运行（使用模拟器或连接真机，真机需要支持调试模式），并保持当前应用的进程正常连接。下面举一个例子：</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/imgs/layout-listitem.png" alt="这里写图片描述"></p>
<p>上图是一个ListView的行布局结构，最外层是一个水平方向的LinearLayout，其内部左侧是一个ImageView用来显示图片，右侧是一个垂直方向的LinearLayout，该LinearLayout又包含上下两个TextView用来显示文本。这种布局结构在我们日常开发中非常常见，接下来我们检测一下它的布局性能。</p>
<p>打开Hierarchy Viewer工具后，点击“Load View Hierarchy”,结果如下图所示：</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/imgs/hierarchy-linearlayout.png" alt="这里写图片描述"></p>
<p>从上图可以看到，这是一个深度为3层的布局结构，点击每一块布局则会显示其测量、布局、绘制3个过程的时间消耗，如下图所示：</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/imgs/hierarchy-layouttimes.png" alt="这里写图片描述"></p>
<p>它说明使用该布局完全渲染一条列表项的具体耗时为：</p>
<ul>
<li>测量：0.977ms</li>
<li>布局：0.167ms</li>
<li>绘制：2.717ms</li>
</ul>
<p>这样开发者就能够清楚地发现哪里是布局的性能瓶颈，接下来就可以针对性地进行优化了。</p>
<h4 id="u4FEE_u6539_u5E03_u5C40"><a href="#u4FEE_u6539_u5E03_u5C40" class="headerlink" title="修改布局"></a>修改布局</h4><p>上述布局由于使用了嵌套的LinearLayout才导致性能下降，因此提高性能的办法就是减少布局的层次嵌套，使之扁平化。我们将最外层的LinearLayout替换成RelativeLayout，使用相对布局，可以将原来3层的布局减少为两层。再次使用Hierarchy Viewer查看，结果如下：</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/imgs/hierarchy-relativelayout.png" alt="这里写图片描述"></p>
<p>现在每一行的布局渲染时间消耗为：</p>
<ul>
<li>测量：0.598ms</li>
<li>布局：0.110ms</li>
<li>绘制：2.146ms</li>
</ul>
<p>可以看到，性能已经得到了细微的提升，千万别小看这微小的提升，这个布局在ListView中可是会被多次调用的，因此整体性能提升是很可观的。</p>
<p>LinearLayout使用了layout_weight会降低测量的速度，因此在使用权重时务必谨慎，能不用则不用。</p>
<h4 id="u4F7F_u7528Lint"><a href="#u4F7F_u7528Lint" class="headerlink" title="使用Lint"></a>使用Lint</h4><p>我们还可以使用Lint工具来发现布局中可优化的地方，Lint已经内置到Android Studio中，使用非常方便。Lint有以下常用规则：</p>
<ul>
<li>使用复合Drawable——如果一个LinearLayout包含一个ImageView和一个TextView则使用复合Drawable的方式会更加高效。</li>
<li>合并根布局——如果FrameLayout为根布局且没有背景或内边距等属性，则可以使用marge标签来合并跟布局以提高效率。</li>
<li>无用的叶节点布局——一个布局如果没有子布局且无背景属性，则可以移除它，因为它不会显示出来，移除之后使得布局层次更加扁平且高效。</li>
<li>无用的父布局——如果一个布局（除ScrollView、根布局之外）没有背景等属性，且它的子布局也无兄弟布局，就可以将它本身移除，将其子布局直接移出来。</li>
<li>布局层次过深——布局层次嵌套过多严重影响性能，可考虑使用RelativeLayout或GridLaout来提升性能，建议布局层次深度不要超过10层。</li>
</ul>
<p>Lint能够自动帮助我们修复一些问题、可以提供修改建议或者跳转到出问题的代码部分，建议大家好好利用Lint这个工具。</p>
<h3 id="u4F7F_u7528include_u91CD_u7528_u5E03_u5C40"><a href="#u4F7F_u7528include_u91CD_u7528_u5E03_u5C40" class="headerlink" title="使用include重用布局"></a>使用include重用布局</h3><p>如果某一种特定的布局结构在应用中出现多次，则可以使用include来重用该布局，提高效率。</p>
<h4 id="u5B9A_u4E49_u91CD_u7528_u5E03_u5C40"><a href="#u5B9A_u4E49_u91CD_u7528_u5E03_u5C40" class="headerlink" title="定义重用布局"></a>定义重用布局</h4><p>加入我们想重用某个布局，可以单独为它创建一个xml布局，例如，定义一个TitleBar（titlebar.xml），每一个Activity都可以重用它。titlebar.xml内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">FrameLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">    <span class="attribute">android:background</span>=<span class="value">"@color/titlebar_bg"</span></span><br><span class="line">    <span class="attribute">tools:showIn</span>=<span class="value">"@layout/activity_main"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">ImageView</span> <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">               <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">               <span class="attribute">android:src</span>=<span class="value">"@drawable/gafricalogo"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述定义中的tools:showIn属性指定了一个父布局来include该重用布局，此属性将会在编译时移除，它只是为了方便在开发时预览布局效果。</p>
<h4 id="u4F7F_u7528include_u6807_u7B7E"><a href="#u4F7F_u7528include_u6807_u7B7E" class="headerlink" title="使用include标签"></a>使用include标签</h4><p>在需要重用布局的地方使用include标签即可引入布局，示例如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:background</span>=<span class="value">"@color/app_bg"</span></span><br><span class="line">    <span class="attribute">android:gravity</span>=<span class="value">"center_horizontal"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">include</span> <span class="attribute">layout</span>=<span class="value">"@layout/titlebar"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span> <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">              <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">              <span class="attribute">android:text</span>=<span class="value">"@string/hello"</span></span><br><span class="line">              <span class="attribute">android:padding</span>=<span class="value">"10dp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以为include标签下的布局重写android:layout_*等属性，如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">include</span> <span class="attribute">android:id</span>=<span class="value">"@+id/news_title"</span></span><br><span class="line">         <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">         <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">         <span class="attribute">layout</span>=<span class="value">"@layout/title"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="u4F7F_u7528merge_u6807_u7B7E"><a href="#u4F7F_u7528merge_u6807_u7B7E" class="headerlink" title="使用merge标签"></a>使用merge标签</h4><p>merge标签可以帮助我们消除冗余布局，例如最外层布局是一个垂直方向的LinearLayout，它内部是一个可重用的布局，而这个可重用布局也是一个垂直方向的LinearLayout包含上下两个Button。那么导致的结果是：一个垂直方向的LinearLayout包含另一个垂直方向的LinearLayout，这种冗余嵌套必然延迟UI的加载效率。</p>
<p>对于上述情况，可以使用merge来消除冗余，修改如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">merge</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">Button</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:text</span>=<span class="value">"@string/add"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">Button</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:text</span>=<span class="value">"@string/delete"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">merge</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="u6309_u9700_u52A0_u8F7D_u89C6_u56FE"><a href="#u6309_u9700_u52A0_u8F7D_u89C6_u56FE" class="headerlink" title="按需加载视图"></a>按需加载视图</h3><p>有时候，一些复杂的View只是偶尔才需要显示，那么就可以在需要时再加载它们，这样减小内存占用并提高渲染速度，通常的做法就是使用ViewStub。</p>
<h4 id="u5B9A_u4E49ViewStub"><a href="#u5B9A_u4E49ViewStub" class="headerlink" title="定义ViewStub"></a>定义ViewStub</h4><p>ViewStub是一个轻量级的view,它不会在布局加载时进行绘制与展示，因此它几乎没有性能开销。每一个ViewStub需要一个android:layout属性来指定要加载的布局。</p>
<p>以下ViewStub示例为一个透明的进度条覆盖层，它只是在新内容加载时才会显示。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">ViewStub</span></span><br><span class="line">    <span class="attribute">android:id</span>=<span class="value">"@+id/stub_import"</span></span><br><span class="line">    <span class="attribute">android:inflatedId</span>=<span class="value">"@+id/panel_import"</span></span><br><span class="line">    <span class="attribute">android:layout</span>=<span class="value">"@layout/progress_overlay"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">    <span class="attribute">android:layout_gravity</span>=<span class="value">"bottom"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="u52A0_u8F7DViewStub_u5E03_u5C40"><a href="#u52A0_u8F7DViewStub_u5E03_u5C40" class="headerlink" title="加载ViewStub布局"></a>加载ViewStub布局</h4><p>当你需要加载ViewStub指定的布局时，有两种方法：</p>
<ul>
<li>通过调用<code>setVisibility(View.VISIBLE)</code>将其设为可见</li>
<li>调用<code>inflate()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">((ViewStub) findViewById(R.id.stub_import)).setVisibility(View.VISIBLE);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">View importPanel = ((ViewStub) findViewById(R.id.stub_import)).inflate();</span><br></pre></td></tr></table></figure>
<p>需要注意的是<code>inflate()</code>方法完成后会返回ViewStub指定的布局，因此不再需要通过<code>findViewById()</code>来得到此布局。</p>
<p>ViewStub一旦被inflate或设为可见，ViewStub元素将不再作为View层次结构的一部分。原来的ViewStub将会被它指定的布局所替代，而这个布局的id就是在ViewStub中指定的<code>android:inflatedId</code>属性的值。而原来的ViewStub的id，即Android:id也将无效。</p>
<p>ViewStub的一个缺点是它指定的布局不支持<merge>标签的使用。</merge></p>
<h3 id="u4F7FListView_u6D41_u7545_u5730_u6ED1_u52A8"><a href="#u4F7FListView_u6D41_u7545_u5730_u6ED1_u52A8" class="headerlink" title="使ListView流畅地滑动"></a>使ListView流畅地滑动</h3><p>保证ListView流畅滑动的关键是应用的主线程没有耗时的事务处理，一些耗时操作如磁盘访问、网络访问、或数据库访问需要使用后台线程。</p>
<h4 id="u4F7F_u7528_u540E_u53F0_u7EBF_u7A0B"><a href="#u4F7F_u7528_u540E_u53F0_u7EBF_u7A0B" class="headerlink" title="使用后台线程"></a>使用后台线程</h4><p>使用后台线程可以减轻UI线程的负担，这样UI线程可以专注于UI绘制，保证流程的用户体验。AsyncTask提供了一种简单的后台线程的调用方法，如下示例为使用AsyncTask下载图片，图片下载完成后会显示到视图组件上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using an AsyncTask to load the slow images in a background thread</span></span><br><span class="line"><span class="keyword">new</span> AsyncTask&lt;ViewHolder, Void, Bitmap&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> ViewHolder v;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">doInBackground</span><span class="params">(ViewHolder... params)</span> </span>&#123;</span><br><span class="line">        v = params[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> mFakeImageLoader.getImage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Bitmap result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPostExecute(result);</span><br><span class="line">        <span class="keyword">if</span> (v.position == position) &#123;</span><br><span class="line">            <span class="comment">// If this item hasn't been recycled already, hide the</span></span><br><span class="line">            <span class="comment">// progress and set and show the image</span></span><br><span class="line">            v.progress.setVisibility(View.GONE);</span><br><span class="line">            v.icon.setVisibility(View.VISIBLE);</span><br><span class="line">            v.icon.setImageBitmap(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.execute(holder);</span><br></pre></td></tr></table></figure>
<p>从Android 3.0（API level 11）起，可以通过使用<code>executeOnExecutor()</code>在后台并行处理多个请求。</p>
<h4 id="u4F7F_u7528ViewHolder"><a href="#u4F7F_u7528ViewHolder" class="headerlink" title="使用ViewHolder"></a>使用ViewHolder</h4><p>在ListView滑动时，会频繁调用<code>findViewById()</code>，这将降低性能。即使Adapter返回一个重用的布局，仍然需要找到对应元素并更新它们。一种可以替代频繁调用<code>findViewById()</code>的方式是使用ViewHolder。</p>
<p>ViewHolder对象存储了每一个view组件，最终通过setTag方法保存到Layout的tag字段中，这样就能够快速访问每个组件。ViewHolder类的创建方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">  TextView text;</span><br><span class="line">  TextView timestamp;</span><br><span class="line">  ImageView icon;</span><br><span class="line">  ProgressBar progress;</span><br><span class="line">  <span class="keyword">int</span> position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充ViewHolder并把它保存在Layout中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ViewHolder holder = <span class="keyword">new</span> ViewHolder();</span><br><span class="line">holder.icon = (ImageView) convertView.findViewById(R.id.listitem_image);</span><br><span class="line">holder.text = (TextView) convertView.findViewById(R.id.listitem_text);</span><br><span class="line">holder.timestamp = (TextView) convertView.findViewById(R.id.listitem_timestamp);</span><br><span class="line">holder.progress = (ProgressBar) convertView.findViewById(R.id.progress_spinner);</span><br><span class="line">convertView.setTag(holder);</span><br></pre></td></tr></table></figure>
<p>然后就可以轻松地访问每个视图，而不需要查找，从而节省宝贵的处理时间。</p>
<p>参考文献：<a href="https://developer.android.google.cn/training/improving-layouts/index.html" target="_blank" rel="external">Improving Layout Performance</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/12/15/APK瘦身指南/">APK瘦身指南</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-12-15
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="APK_u7626_u8EAB_u7B56_u7565"><a href="#APK_u7626_u8EAB_u7B56_u7565" class="headerlink" title="APK瘦身策略"></a>APK瘦身策略</h2><p>用户一般会不会在应用市场上下载那些看起来很大的App，尤其是当他们使用2G或3G网络或者是按流量付费的时候。因此这篇文章将讲述如何减小APK的大小，从而让更多的用户来下载你的应用。</p>
<h3 id="u4E86_u89E3APK_u6587_u4EF6_u7684_u7ED3_u6784"><a href="#u4E86_u89E3APK_u6587_u4EF6_u7684_u7ED3_u6784" class="headerlink" title="了解APK文件的结构"></a>了解APK文件的结构</h3><p>在探讨如何减小App大小之前，有必要先弄清楚APK文件的结构。APK实质上是一个ZIP压缩文件，它包含了构成App的所有文件，如Java类文件，资源文件，以及编译后的资源文件等。</p>
<p>一个APK包含以下几个文件目录：</p>
<ul>
<li>META-INF/：包含CERT.SF及CERT.RSA签名文件以及MANIFEST.MF。</li>
<li>assets/：包含App的资源，这些资源文件可通过AssetManager获取。</li>
<li>res/：包含了不会被编译到resources.arsc中的资源。</li>
<li>lib：包含了特定于处理器软件层的已编译的代码。该文件夹中针对不同处理器平台架构提供不同子文件夹，如armeabi、armeabi-v7、arm64-v8a、x86、x86_64以及mips。</li>
</ul>
<p>一个APK还包含了以下文件，其中，只有AndroidManifest.xml是强制性的。</p>
<ul>
<li>resources.arsc：包含了编译的资源，如res/values/文件夹中的xml文件将会被编译到这里。打包工具会将xml文件编译为二进制格式，包括strings及styles以及某些资源的路径信息，如布局文件以及图片资源。</li>
<li>classes.dex：包含可被Dalvik或ART虚拟机执行的DEX文件。</li>
<li>AndroidManifest.xml：包含了Android的核心配置文件，该文件配置了应用的名称、版本、访问权限以及引用的类文件等信息。此文件也是被编译为二进制格式。</li>
</ul>
<h3 id="u51CF_u5C11_u8D44_u6E90_u6570_u91CF_u53CA_u5927_u5C0F"><a href="#u51CF_u5C11_u8D44_u6E90_u6570_u91CF_u53CA_u5927_u5C0F" class="headerlink" title="减少资源数量及大小"></a>减少资源数量及大小</h3><p>APK的大小会影响应用的加载速度、内存占用以及电量消耗。一个简单的减小APK的方法是减少它所用到的资源数量和大小。尤其是我们可以移除App中不再使用的资源，还可以使用Drawable来替代图片文件。这一节将讨论上述方法及其他几种方案来减小App中的资源以达到APK瘦身的目的。</p>
<h4 id="u79FB_u9664_u65E0_u7528_u8D44_u6E90"><a href="#u79FB_u9664_u65E0_u7528_u8D44_u6E90" class="headerlink" title="移除无用资源"></a>移除无用资源</h4><p>使用Android Studio提供的静态代码分析工具——lint，可以检测到res/文件夹中未被你的代码引用的资源。一旦lint工具发现了潜在的未使用的资源，就会打印出如下信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res/layout/preferences.xml: Warning: The resource R.layout.preferences appears</span><br><span class="line">    to be unused [UnusedResources]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：lint工具并不会扫描assets/文件夹、以及通过反射或library引用的资源；另外lint并不会移除资源，只是提醒它们的存在。</p>
</blockquote>
<p>App中添加的一些Library可能包含无用的资源，如果我们在build.gradle文件中配置了<code>shrinkResources</code>，那么Gradle可以帮助我们删除这些资源文件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    // Other settings</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled true</span><br><span class="line">            shrinkResources true</span><br><span class="line">            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了使用shrinkResources，需要允许代码压缩，在应用的构建过程中，首先ProGuard会移除无用代码，但会保留未使用的资源，然后Gradle再移除未使用的资源。</p>
<p>更多关于ProGuard及其他Android Studio提供的APK压缩方法，可参考<a href="https://developer.android.google.cn/studio/build/shrink-code.html" target="_blank" rel="external">Shrink Your Code and Resources</a>。</p>
<h4 id="u51CF_u5C0F_u7B2C_u4E09_u65B9_u5E93_u7684_u5927_u5C0F"><a href="#u51CF_u5C0F_u7B2C_u4E09_u65B9_u5E93_u7684_u5927_u5C0F" class="headerlink" title="减小第三方库的大小"></a>减小第三方库的大小</h4><p>开发一个Android应用时，会经常用到第三方库来实现各种各样的功能，例如，可能会使用Android Support Library来兼容老的设备以提升用户体验，或者可能使用Google Play Service实现App的文本自动翻译功能。</p>
<p>如果一个库是为服务端或桌面应用设计的，它可能包含了很多App中用不到的对象和方法。为了只引入App所用到的部分，如果该库的许可允许修改，那么我们可以修改精简该库；或者使用其他专门针对移动端的可替代库来实现App功能。</p>
<p>注意：ProGuard可以移除library中的一些无用代码，但无法删除library中大的内部依赖。</p>
<h4 id="u4EC5_u652F_u6301_u7279_u5B9A_u5C4F_u5E55_u5BC6_u5EA6"><a href="#u4EC5_u652F_u6301_u7279_u5B9A_u5C4F_u5E55_u5BC6_u5EA6" class="headerlink" title="仅支持特定屏幕密度"></a>仅支持特定屏幕密度</h4><p>Android支持一系列设备，包括各种不同的屏幕分辨率。Android 4.4及更高的版本，支持众多屏幕密度，如ldpi、mdpi、tvdpi、hdpi、xhdpi、xxhdpi、xxxhdpi。尽管Android支持上述所有屏幕密度，但我们不需要为所有密度提供图片资源。</p>
<p>如果你知道某个分辨率的设备使用者占比很小，则可以考虑是否还要为其提供针对性的资源。如果我们不提供某个分辨率的图片资源，Android系统会自动将已存在的资源缩放以适配该屏幕密度。</p>
<p>如果应用仅需要可缩放的图片，可以使用drawable-nodpi/以节省更多空间，同时推荐为每个App至少配置一个xxhdpi图片文件夹。</p>
<h4 id="u51CF_u5C11_u52A8_u753B_u7684_u5E27_u6570"><a href="#u51CF_u5C11_u52A8_u753B_u7684_u5E27_u6570" class="headerlink" title="减少动画的帧数"></a>减少动画的帧数</h4><p>帧动画会显著增加APK的大小，因为帧动画一般会被分离成多张图片，每张图片代表动画的一帧。</p>
<p>动画中每添加一帧，意味着APK将增加一张图片数量。</p>
<h4 id="u4F7F_u7528Drawable"><a href="#u4F7F_u7528Drawable" class="headerlink" title="使用Drawable"></a>使用Drawable</h4><p>一些图片不需要静态图片资源，系统可以在运行时动态绘制。Drawable在APK中只占用很小的空间，另外用XML表示的Drawable对象可以生成兼容Material Design指南的单色图。</p>
<h4 id="u8D44_u6E90_u91CD_u7528"><a href="#u8D44_u6E90_u91CD_u7528" class="headerlink" title="资源重用"></a>资源重用</h4><p>对于着色、阴影、旋转等效果，可以只使用一张独立的图片即可。这里建议重用同一套资源，在需要的时候再进行自定义处理。</p>
<p>Android提供了一些列的实用工具来改变资源的颜色，如使用android:tint或tintMode属性（API level 21+），对于低于Android 5.0的版本，则可以使用ColorFilter类。</p>
<p>对于图片旋转的需求，下面代码片段提供了一个示例：简单地将原始图片选装180度，从而将一个箭头icon从“展开”状态变为“收起”状态：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">rotate</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:drawable</span>=<span class="value">"@drawable/ic_arrow_expand"</span></span><br><span class="line">    <span class="attribute">android:fromDegrees</span>=<span class="value">"180"</span></span><br><span class="line">    <span class="attribute">android:pivotX</span>=<span class="value">"50%"</span></span><br><span class="line">    <span class="attribute">android:pivotY</span>=<span class="value">"50%"</span></span><br><span class="line">    <span class="attribute">android:toDegrees</span>=<span class="value">"180"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="u4F7F_u7528_u4EE3_u7801_u6E32_u67D3"><a href="#u4F7F_u7528_u4EE3_u7801_u6E32_u67D3" class="headerlink" title="使用代码渲染"></a>使用代码渲染</h4><p>可以使用程序代码来渲染图片以减小APK大小，因为如果用代码来实现的话，就不需要在APK中存储图片了。</p>
<h4 id="Crunch_PNG_Files"><a href="#Crunch_PNG_Files" class="headerlink" title="Crunch PNG Files"></a>Crunch PNG Files</h4><p>在构建过程中，aapt工具可以对res/drawable/中的图片进行无损优化，如aapt可使用调色板将小于256色的真彩色PNG图片转换为8-bit的PNG。这样做可以在不影响图片质量的情况下减小内存占用。</p>
<p>需要注意aapt有以下局限性：</p>
<ul>
<li><p>aapt工具不能压缩assets/文件夹中的PNG文件</p>
</li>
<li><p>aapt工具只能优化那些不超过256色的图片文件</p>
</li>
<li><p>aapt工具可能inflate被压缩过的PNG文件，为了禁止此功能，可以在Gradle中使用cruncherEnabled标志：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaptOptions &#123;</span><br><span class="line">    cruncherEnabled = false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="u538B_u7F29PNG_u4E0EJPEG_u6587_u4EF6"><a href="#u538B_u7F29PNG_u4E0EJPEG_u6587_u4EF6" class="headerlink" title="压缩PNG与JPEG文件"></a>压缩PNG与JPEG文件</h4><p>可以在不影响图片质量的情况下对PNG文件进行压缩，常用工具有 <a href="http://pmt.sourceforge.net/pngcrush/" target="_blank" rel="external">pngcrush</a>， <a href="https://pngquant.org/" target="_blank" rel="external">pngquant</a>，或者<a href="https://github.com/google/zopfli" target="_blank" rel="external">zopflipng</a>。这些工具都可以减少PNG文件大小，同时保持图像质量。</p>
<p>pngcrush是特别有效的工具，它会遍历PNG过滤器和zlib（紧缩）参数，使用每个过滤器及参数的组合来压缩图像，然后选择能够产生最小压缩输出的配置。</p>
<p>对于JPEG文件，可以使用类似 <a href="http://www.elektronik.htw-aalen.de/packjpg/" target="_blank" rel="external">packJPG</a>的工具来将JPEG压缩到更紧凑的形式。</p>
<h4 id="u4F7F_u7528WebP_u6587_u4EF6_u683C_u5F0F"><a href="#u4F7F_u7528WebP_u6587_u4EF6_u683C_u5F0F" class="headerlink" title="使用WebP文件格式"></a>使用WebP文件格式</h4><p>除了使用PNG及JPEG文件外，还可以使用 <a href="https://developers.google.cn/speed/webp/" target="_blank" rel="external">WebP</a>图片格式来作为替代。WebP拥有JPEG的无损压缩以及PNG的透明度特性，同时可以提供更优于JPEG及PNG的压缩效果。</p>
<p>使用WebP文件格式有几个值得注意的缺陷，第一，低于Android3.2(API level 13)的系统不支持WebP，第二，使用WebP将花费比PNG文件更多的解码时间。</p>
<blockquote>
<p>注意：Google Play只接受应用图标为PNG格式的应用，不能使用其他文件格式，如果打算通过Google Play来分发应用，则不可使用JPEG或WebP格式的应用图标。</p>
</blockquote>
<h4 id="u4F7F_u7528_u77E2_u91CF_u56FE"><a href="#u4F7F_u7528_u77E2_u91CF_u56FE" class="headerlink" title="使用矢量图"></a>使用矢量图</h4><p>可以使用矢量图来创建分辨率无关的icon或者可缩放的多媒体，使用矢量图可以极大地减小APK的大小。矢量图在Android中表现为VectorDrawable对象，使用VectorDrawable，100字节的大小就可以创建一个清晰的屏幕大小的图片。</p>
<p>然而，使用VectorDrawable，系统需要更多的时间来渲染，如果图片较大，则需要更长的时间才能显示到屏幕上。因此，最好是在展示小图片时考虑使用矢量图。</p>
<h3 id="u51CF_u5C0FNative_u4E0EJava_u4EE3_u7801_u7684_u5927_u5C0F"><a href="#u51CF_u5C0FNative_u4E0EJava_u4EE3_u7801_u7684_u5927_u5C0F" class="headerlink" title="减小Native与Java代码的大小"></a>减小Native与Java代码的大小</h3><p>可以使用以下几种方法来减小Java代码与Native代码的大小。</p>
<h4 id="u79FB_u9664_u4E0D_u5FC5_u8981_u7684_u751F_u6210_u4EE3_u7801"><a href="#u79FB_u9664_u4E0D_u5FC5_u8981_u7684_u751F_u6210_u4EE3_u7801" class="headerlink" title="移除不必要的生成代码"></a>移除不必要的生成代码</h4><p>请务必了解自动生成的代码会占用多大空间，例如，许多协议缓冲工具会产生过多的方法和类，它可以占用双倍或三倍于App的大小。</p>
<h4 id="u79FB_u9664_u679A_u4E3E"><a href="#u79FB_u9664_u679A_u4E3E" class="headerlink" title="移除枚举"></a>移除枚举</h4><p>单个枚举可以使App的classes.dex文件增加1到1.4KB的大小，由于系统的复杂性及共享库的使用，这种增加累计起来将会很可观。如果可能，考虑使用@IntDef注解或者使用ProGuard将注解转换为整型，这种类型转换可以保持枚举类型的安全性。</p>
<h4 id="u51CF_u5C11_u672C_u5730_u4E8C_u8FDB_u5236_u6587_u4EF6_u7684_u5927_u5C0F"><a href="#u51CF_u5C11_u672C_u5730_u4E8C_u8FDB_u5236_u6587_u4EF6_u7684_u5927_u5C0F" class="headerlink" title="减少本地二进制文件的大小"></a>减少本地二进制文件的大小</h4><p>如果应用使用到本地代码及Android NDK，我们可以通过优化代码来减小应用的大小。两种有用的技术可以删除调试符号而不是提取本地库。</p>
<h5 id="u5220_u9664_u8C03_u8BD5_u7B26_u53F7"><a href="#u5220_u9664_u8C03_u8BD5_u7B26_u53F7" class="headerlink" title="删除调试符号"></a>删除调试符号</h5><p>在应用的开发与调试阶段，使用调试符号是有意义。可以使用Android NDK提供的arm-eabi-strip工具来移除本地库中不必要的调试符号。移除之后，我们可以编译应用的release版本。</p>
<h5 id="u907F_u514D_u63D0_u53D6_u672C_u5730_u5E93"><a href="#u907F_u514D_u63D0_u53D6_u672C_u5730_u5E93" class="headerlink" title="避免提取本地库"></a>避免提取本地库</h5><p>将未压缩的.so文件添加到APK中，在manifest配置文件的<applicaiton>中将android:extractNativeLibs设为false。做了上述配置后，在应用安装时，PackageManager将不会把.so文件从APK中拷贝到文件系统，这样做也有额外的好处，可以使App的增量更新变得更小。</applicaiton></p>
<h3 id="u7EF4_u62A4_u591A_u4E2A_u4E13_u7528APK"><a href="#u7EF4_u62A4_u591A_u4E2A_u4E13_u7528APK" class="headerlink" title="维护多个专用APK"></a>维护多个专用APK</h3><p>用户下载了你的App，但很可能有些内容用户不会用到，如地区及语言信息。为了让用户得到最小化的下载，我们可以根据一些因素，如屏幕尺寸或对GPU的支持来将我们的App分化成多个App。</p>
<p>当用户下载App时，可以根据用户的设备信息与配置下载对应的APK，因此，该设备将不会收到与此设备本身支持的特性不匹配的资源要素。例如，用户设备只支持hdpi，所以这些设备不需要为高密度设备所准备的xxxhdpi资源。</p>
<p>官方原文：<a href="https://developer.android.google.cn/topic/performance/reduce-apk-size.html" target="_blank" rel="external">Reduce APK Size</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/11/27/如何配置方法数超过64K的应用/">如何配置方法数超过64K的应用</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-11-27
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>随着Android平台的继续成长，Android应用的大小也在变大。当一个应用及其引用的库到达一定的规模，在编译应用时就会遇到构建错误，这表示此App已经达到了Android构建系统的某个限制。在早期的构建系统版本中，此错误表现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Conversion to Dalvik format failed:</span><br><span class="line">Unable to execute dex: method ID not in [<span class="number">0</span>, <span class="number">0xffff</span>]: <span class="number">65536</span></span><br></pre></td></tr></table></figure>
<p>现在的Android构建系统可能会报另一个不同的错误，但它们表示的都是同一个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trouble writing output:</span><br><span class="line">Too many field references: <span class="number">131000</span>; max is <span class="number">65536</span>.</span><br><span class="line">You may <span class="keyword">try</span> using --multi-dex option.</span><br></pre></td></tr></table></figure>
<p>这些错误的发生条件都指向了一个共同的数字：65536，这个数字非常重要，它代表了一个单独的DEX字节码文件可执行的引用总数。本文将说明如何通过将一个应用配置为multidex的方式来解决该问题，配置之后，该应用将构建和读取多个DEX文件。</p>
<h3 id="u5173_u4E8E64K_u7684_u5F15_u7528_u9650_u5236"><a href="#u5173_u4E8E64K_u7684_u5F15_u7528_u9650_u5236" class="headerlink" title="关于64K的引用限制"></a>关于64K的引用限制</h3><p>Android 应用（APK）中以Dalvik虚拟机可执行文件（即DEX）的形式包含了可执行的字节码文件，DEX文件中编译后的代码则用于运行App功能。DEX规范做了如下限制：一个单独的DEX文件可引用的最多方法数为65636——包括Android框架中的方法、第三方库的方法以及自己代码中的方法。在计算机科学的表述中，K表示1024（或2^10）。因为65536即64x1024，所以65536的方法数限制也叫做64K引用限制。</p>
<h4 id="Android_5-0_u4E4B_u524D_u7684_u7248_u672C_u4F7F_u7528Mutidex"><a href="#Android_5-0_u4E4B_u524D_u7684_u7248_u672C_u4F7F_u7528Mutidex" class="headerlink" title="Android 5.0之前的版本使用Mutidex"></a>Android 5.0之前的版本使用Mutidex</h4><p>Android 5.0（API level 21）之前的版本使用Dalvik虚拟机来执行应用代码，默认情况下，Dalvik限制每个APK中只有一个classes.dex字节码文件。为了绕过这个限制，可以使用支持库<a href="https://developer.android.com/tools/support-library/features.html#multidex" target="_blank" rel="external">multidex support library</a>，它将作为主DEX的一部分，用来管理对额外的DEX文件及其代码的访问。</p>
<blockquote>
<p>说明：如果为minSdkVersion=20或更低的应用配置multidex，并且运行目标设备为Android 4.4（API level 20）或更低，此时Android Studio将禁止使用<a href="https://developer.android.com/tools/building/building-studio.html#instant-run" target="_blank" rel="external">Instant Run</a>。</p>
</blockquote>
<h4 id="Android_5-0_u53CA_u4E4B_u540E_u7684_u7248_u672C_u4F7F_u7528Multidex"><a href="#Android_5-0_u53CA_u4E4B_u540E_u7684_u7248_u672C_u4F7F_u7528Multidex" class="headerlink" title="Android 5.0及之后的版本使用Multidex"></a>Android 5.0及之后的版本使用Multidex</h4><p>Android 5.0 （API level 21）及更高版本使用ART 运行时，ART默认支持从APK文件中加载多个DEX文件。当应用安装时，ART将执行预编译，会扫描多个.dex文件，并将它们编译为一个单独的.oat文件用来被Android设备执行。因此如果minSdkVersion=21或者更高，则不再需要multidex支持库。</p>
<p>关于更多的Anroid 5.0运行时知识，请参考<a href="https://source.android.com/devices/tech/dalvik/index.html" target="_blank" rel="external">ART and Dalvik</a>。</p>
<blockquote>
<p>说明：当使用Instant Run时，如果应用的minSdkVersion=21或者更高，则Android Studio会自动为该应用配置multidex。由于Instant Run仅用于App编译的debug模式，因此仍然需要为release模式配置multidex来避免64K的限制。</p>
</blockquote>
<h3 id="u907F_u514D64K__u65B9_u6CD5_u6570_u7684_u9650_u5236"><a href="#u907F_u514D64K__u65B9_u6CD5_u6570_u7684_u9650_u5236" class="headerlink" title="避免64K 方法数的限制"></a>避免64K 方法数的限制</h3><p>在为App配置允许使用64K或更多的方法引用之前，我们应该采取措施来减少App中所需的方法总数，包括我们自定义的方法及引用库的方法。以下策略可以帮助我们避免触发DEX的64K限制：</p>
<ul>
<li><p>Review应用的直接依赖或传递依赖</p>
<p>Ensure any large library dependency you include in your app is used in a manner that outweighs the amount of code being added to the app. A common anti-pattern is to include a very large library because a few utility methods were useful. 减少应用的代码依赖可以有效地避免DEX引用限制。</p>
</li>
<li><p>使用ProGuard移除无用代码</p>
<p>为应用的release版本开启Proguard的<a href="https://developer.android.com/studio/build/shrink-code.html" target="_blank" rel="external">Enable code shrinking</a>，代码压缩将不会把无用代码打包到APK中。</p>
</li>
</ul>
<p>使用上述方法可以帮助我们避免在应用中使用multidex，同时能够有效减少APK包的大小。</p>
<h3 id="u4E3A_u5E94_u7528_u914D_u7F6Emultidex"><a href="#u4E3A_u5E94_u7528_u914D_u7F6Emultidex" class="headerlink" title="为应用配置multidex"></a>为应用配置multidex</h3><p>为应用配置multidex需要对应用工程作一些修改，这取决于该App所支持的最低Android版本。</p>
<p>如果<code>minSdkVersion</code>设置为21或更高，那么只需要为module中的<code>build.gradle</code>文件添加<code>multiDexEnabled</code>为<code>true</code>，具体如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">android</span> &#123;</span><br><span class="line">    <span class="tag">defaultConfig</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">minSdkVersion</span> <span class="tag">21</span> </span><br><span class="line">        <span class="tag">targetSdkVersion</span> <span class="tag">25</span></span><br><span class="line">        <span class="tag">multiDexEnabled</span> <span class="tag">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>minSdkVersion</code>为20或更低，则必须使用<code>multidex support library</code>，具体操作如下：</p>
<ol>
<li><p>为Module中的<code>build.gradle</code>文件添加<code>multiDexEnabled</code>为<code>true</code>，并且添加multidex library依赖，如下所示：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        minSdkVersion <span class="number">15</span> </span><br><span class="line">        targetSdkVersion <span class="number">25</span></span><br><span class="line">        multiDexEnabled <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">  <span class="keyword">compile</span> <span class="string">'com.android.support:multidex:1.0.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据是否重写了<code>Application</code>类，选择下面的对应方案：</p>
<ul>
<li><p>如果没有重写<code>Application</code>类，将AndroidManifest.xml中的<application>标签的<code>android:name</code>做如下设置：</application></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">package</span>=<span class="value">"com.example.myapp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">application</span></span><br><span class="line">            <span class="attribute">android:name</span>=<span class="value">"android.support.multidex.MultiDexApplication"</span> &gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果重写了<code>Application</code>类，让它继承<code>MultiDexApplication</code>（如果可能）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">MultiDexApplication</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果重写了<code>Application</code>类，但是它的基类无法修改，那么可以重写<code>attachBaseContext()</code>方法并且调用<code>MultiDex.install(this)</code>来允许使用multidex。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">SomeOtherApplication</span> </span>&#123;</span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.attachBaseContext(context);</span><br><span class="line">     Multidex.install(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>现在当编译应用，Android构建工具将会构造一个主DEX文件（classes.dex），如果有需要的话还会生成其他DEX文件（如classes2.dex，classes3.dex等），构建系统然后会将所有的DEX文件打包到APK中。</p>
<p>在运行的时候，multidex API会使用特定的类加载器在所有可用的DEX文件中来搜索所需方法。</p>
<h4 id="multidex_support_library_u7684_u5C40_u9650_u6027"><a href="#multidex_support_library_u7684_u5C40_u9650_u6027" class="headerlink" title="multidex support library的局限性"></a>multidex support library的局限性</h4><p><code>multidex support library</code>有一些已知的局限性，在为应用配置multidex之前我们需要知道并测试：</p>
<ul>
<li>在启动时将DEX安装到设备的数据分区很复杂，如果第二个DEX文件很大的话，有可能导致ANR错误。这种情况下，我们需要开启<a href="https://developer.android.com/studio/build/shrink-code.html" target="_blank" rel="external">code shrinking with ProGuard</a>来减小DEX的大小并移除无用代码。</li>
<li>一些使用了multidex的应用可能无法在低于Android 4.0（API level 14）的设备上运行，这可能是由于<code>Dalvik linarAlloc bug</code>（ <a href="http://b.android.com/22586" target="_blank" rel="external">Issue 22586</a>）引起。如果目标API的版本低于14，必须确保对这些平台版本展开充分测试，因为它们可能在启动或某些特殊类加载时产生异常。Code shrinking可以减少或消除这些潜在的问题。</li>
<li>使用了multidex的应用需要更多的内存分配，也可能导致应用崩溃，这是由于<code>Dalvik linearAlloc limit</code>（<a href="http://b.android.com/78035" target="_blank" rel="external">Issue 78053</a>）的原因。虽然内存分配限制在Android 4.0（API level 14）增加了，但App仍有可能在Android 5.0（API level 21）之前的版本中运行时到达上限。</li>
</ul>
<h3 id="u4E3A_u4E3BDEX__u6587_u4EF6_u58F0_u660E_u5FC5_u987B_u7C7B"><a href="#u4E3A_u4E3BDEX__u6587_u4EF6_u58F0_u660E_u5FC5_u987B_u7C7B" class="headerlink" title="为主DEX 文件声明必须类"></a>为主DEX 文件声明必须类</h3><p>为配置了multidex的应用构建每一个DEX文件时，构建工具需要做一个复杂的决策，来决定哪一个类是主DEX文件必须的，来保证应用能成功启动。如果某个在启动时必须的类没有被包含到主DEX文件，那么应用启动时就会崩溃，并报错<code>java.lang.NoClassDefFoundError</code>。</p>
<p>如果我们应用的代码可以直接访问某些代码，上述错误一般来说不会发生，因为构建工具可以识别出这些代码路径，但是当代码路径不可见时就可能会发生上述异常，如应用中的某个库包含了复杂的依赖。一个更具体的例子，如代码使用了反射或从Native代码调用Java方法，这些方法则可能不会被识别并放到主DEX文件中。</p>
<p>所以当遇到<code>java.lang.NoClassDefFoundError</code>时，需要手动指定哪些类为主DEX必须的，具体方法为通过在build type中使用<code>multiDexKeepFile</code>属性来声明它们。在这里指定的文件必须每个类声明为一行，书写格式为<code>com/example/MyClass.class</code>。例如，可以创建如下一个叫做dex.keep的文件：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com<span class="regexp">/example/My</span><span class="keyword">Class</span>.<span class="keyword">class</span></span><br><span class="line">com<span class="regexp">/example/My</span>OtherClass.<span class="keyword">class</span></span><br></pre></td></tr></table></figure>
<p>然后就可以为某个build type指定此文件：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">android</span> &#123;</span><br><span class="line">    <span class="title">buildTypes</span> &#123;</span><br><span class="line">        <span class="title">release</span> &#123;</span><br><span class="line">            <span class="title">multiDexKeepFile</span> file(<span class="string">'dex.keep'</span>)</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为Gradle是相对于build.gradle文件读取路径的，所以上述例子中的dex.keep需要跟build.gradle文件处于相同的目录才可生效。</p>
<h3 id="u5728_u5F00_u53D1_u4E2D_u4F18_u5316multidex_u7684_u6784_u5EFA_u8FC7_u7A0B"><a href="#u5728_u5F00_u53D1_u4E2D_u4F18_u5316multidex_u7684_u6784_u5EFA_u8FC7_u7A0B" class="headerlink" title="在开发中优化multidex的构建过程"></a>在开发中优化multidex的构建过程</h3><p>配置了Multidex的应用所需要的构建时间明显增加，因为构建系统需要做复杂的分析来决定哪些类需要包含在主DEX中，哪些类需要包含则其他DEX文件中。这意味着使用multidex的构建会花费更多时间并减慢我们的开发过程。</p>
<p>为了缩短multidex的构建时间，我们可以使用<code>productFlavors</code>创建两个构建变种：一个<code>development flavor</code>和一个<code>release flavor</code>，它们使用不同的minSdkVersion。</p>
<p>对于<code>development flavor</code>，将<code>minSdkVersion</code>设为21，此设置将会使用一种叫做<code>per-dexing</code>的构建功能，在使用ART模式时（Android 5.0或更高），它会更快地为multidex生成APK。对于<code>release flavor</code>，将<code>minSdkVersion</code>设置为应用真正要支持的最低版本，这种设置方式将会生成兼容更多设备的APK，但是需要花费更长的构建时间。</p>
<p>下面的构建配置说明了在Gradle中如何设置上述flavor：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        multiDexEnabled <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        dev &#123;</span><br><span class="line">            <span class="comment">// Enable pre-dexing to produce an APK that can be tested on</span></span><br><span class="line">            <span class="comment">// Android 5.0+ without the time-consuming DEX build processes.</span></span><br><span class="line">            minSdkVersion <span class="number">21</span></span><br><span class="line">        &#125;</span><br><span class="line">        prod &#123;</span><br><span class="line">            <span class="comment">// The actual minSdkVersion for the production version.</span></span><br><span class="line">            minSdkVersion <span class="number">14</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">true</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>),</span><br><span class="line">                                                 <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:multidex:1.0.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成了上述配置后，就可以使用<code>devDebug</code>变种来进行增量构建，此种方式组合了<code>dev</code> product flavor以及<code>debug</code>构建类型。这将生成一个debug版的使用了multidex并且禁用proguard（因为<code>minifyEnabled</code>默认为false）的应用。上述配置会让Gradle插件做以下事情：</p>
<ol>
<li>执行<code>pre-dexing</code>：将每一个Module及每一个依赖编译成一个独立的DEX文件。</li>
<li>将每一个DEX文件不做任何修改地包含进APK文件中（没有执行代码压缩）。</li>
<li>最重要的是，每个Module生成的DEX没有组合起来，因此不需要花费很长时间来计算主DEX应该包含哪些内容。</li>
</ol>
<p>上述配置会使得构建加快，因为仅仅是发生修改的module会被重计算及打包构建出新的DEX文件，但是，上述配置生成的APK只能在Android 5.0的设备上测试。然而通过使用flavor配置，我们也可以使用通用的构建方式来生成APK，这些APK可以适配最低的SDK版本并且使用了<code>ProGuard</code>代码压缩。</p>
<p>还可以构建其他变种，如<code>prodDebug</code>，它会花费较长时间来构建，但是可以用来做开发之外的测试。<code>prodRelease</code>可作为最终的测试及发布版本。如需了解更多的构建变种知识，请参考 <a href="https://developer.android.com/studio/build/build-variants.html" target="_blank" rel="external">Configure Build Variants</a>。</p>
<h3 id="u6D4B_u8BD5multidex_u5E94_u7528"><a href="#u6D4B_u8BD5multidex_u5E94_u7528" class="headerlink" title="测试multidex应用"></a>测试multidex应用</h3><p>为multidex应用写测试用例时，无需其他配置。<code>AndroidJUnitRunner</code>支持multidex，只要你使用<code>MultiDexApplication</code>或者为自定义的<code>Application</code>重写<code>attachBaseContext()</code>方法并调用<code>MultiDex.install(this)</code>来开启muxtidex支持。</p>
<p>另外，可以在<code>AndroidJUnitRunner</code>中重写<code>onCreate()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle arguments)</span> </span>&#123;</span><br><span class="line">    MultiDex.install(getTargetContext());</span><br><span class="line">    <span class="keyword">super</span>.onCreate(arguments);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：使用multidex来创建一个测试APK目前是不支持的。</p>
</blockquote>
<p><a href="https://developer.android.com/studio/build/multidex.html" target="_blank" rel="external">原文地址</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/10/25/关于日益泛滥的Android第三方框架/">关于日益泛滥的Android第三方框架</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-10-25
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h4 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h4><p>目前Android开发依然很火，如果你关注GitHub，可能会发现越来越多的第三方库与框架（一些简单的库可能称不上框架，为了行文方便，后文统一称之为框架）如雨后春笋般出现。这在一定程度上反映了Android开发的繁荣，但任何事情都有其另一面，第三方框架在方便了App开发的同时，也带来了一些不利影响。</p>
<p>最近我们在招聘2~3年工作经验的Android工程师，应聘者简历上的项目介绍无一例外都用到了大量第三方框架，更有甚者几乎整个App都是靠框架堆起来的。但是当问面试者某个框架的优缺点时，却很少有人能回答出来，即使有的面试者知道所用框架的优缺点，但却丝毫没看过框架的源码，更别提对源码做修改或扩展了。仅仅是拿来主义，简单地拿来实现自己的功能，最多做个简单的封装，有的甚至封装都是第三方库代劳。</p>
<p>其实不只是中高级开发者，很多初学者，一上来就各种框架地用，压根儿不去想内部是如何实现的。比如使用OkHttp获取网络数据却不知道HTTP请求的基本原理，使用Glide请求加载图片却不知道图片的缓存、解码过程……</p>
<p>突然感到事情很严重，也庆幸当初自己学习Android时还没有那么多框架。</p>
<h4 id="u56DE_u5F52_u672C_u771F"><a href="#u56DE_u5F52_u672C_u771F" class="headerlink" title="回归本真"></a>回归本真</h4><p>从我身边的朋友，同学，网络以及面试遇到的一些开发者来看，貌似都是言必谈框架，开发必用框架，不知道某个框架就好像落伍了一样，但这些开发者里面真正能完全弄懂自己所用框架的却占很小比例，也许这并不能覆盖整个业界的情况，但多多少少能反映出一些端倪。</p>
<p>于是，越来越多的人盲目跟风地使用RxAndroid、Dagger、ReactNative，其实并不是这几个框架不好，相反这几个框架非常不错，只是很多人是为用而用，没有理解其原理，没有了解其优缺点就盲目地用。</p>
<p>是的，技术发展日新月异，就像这个社会，总是会有新的事物出现。但在某个阶段，技术发展的同时也许会迷失了自我，前段时间有一篇文章《<a href="https://www.v2ex.com/t/310767?p=1" target="_blank" rel="external">2016年学习JavaScript是一种怎样的体验</a>》非常火，真心建议大家一看。其实无论技术发展得如何眼花缭乱，我们需要真正掌握最本质的东西，对于前端，我觉得是JavaScript、HTML、CSS，对于Android，我觉得是Java与Android API。万变不离其宗，回归本真，这世上本无框架。</p>
<h4 id="u7B2C_u4E09_u65B9_u6846_u67B6"><a href="#u7B2C_u4E09_u65B9_u6846_u67B6" class="headerlink" title="第三方框架"></a>第三方框架</h4><p>其实第三方框架并非质量都不好，也并非不可使用，只是不建议大家没有选择地使用，不明所以地使用，更不建议大家靠第三方框架来堆砌App。如果没有吃透第三方框架，那么这个App就像一座华丽的大楼，如果哪天某个框架出了问题，可能就像坏了一根支撑的柱子，大厦就有可能崩塌。</p>
<p>因为第三方框架也是人写的，是人写的就有可能出bug。相比框架bug，更让人担心地是一种不好地风气正在蔓延。以热更新技术为例（不一一列举名称了，大家都知道的），国内真是热闹，你方唱罢我登场，有个人的，有公司的，你刚开源一套框架，过不多久，我也来开源一套，到现在怎么也得有六七八九个框架了吧！</p>
<p>开源的目的是为了不重复造轮子，而我们呢？大家何不齐心合力去完善一个框架呢？大家貌似都在炫耀技术：看，我家也有热更新！还有一些个人开源库的作者，求star，求推广，一夜star上千，为名还是为利？过段时间项目没人维护了，试问这样的框架你敢用吗？</p>
<p>当然也有一些非常好的框架，比如Square出品的，Google出品的，基本都是精品，值得学习。</p>
<h4 id="u9009_u62E9_u6807_u51C6"><a href="#u9009_u62E9_u6807_u51C6" class="headerlink" title="选择标准"></a>选择标准</h4><p>第三方框架数量众多，且还在快速增长，其质量良莠不齐。因此如何挑选框架成为一个严肃的问题，以下是个人的几点参考：</p>
<ol>
<li>业界著名的（如Square, Google的）且经过大量使用验证的框架</li>
<li>长期维护且比较活跃（如提交issue）的框架</li>
<li>选择合适的框架，尽量小而精，不要大而全。这可能有些矛盾，因为大部分框架都会考虑通用性，如果仅需要其中一两个功能，就需要权衡了</li>
<li>根据开源级别，尽量选择允许修改源码的，这样一旦框架出现问题，可自行修改</li>
<li>对于国内的库，千万不要相信star数量</li>
</ol>
<h4 id="u4E00_u4E9B_u5EFA_u8BAE"><a href="#u4E00_u4E9B_u5EFA_u8BAE" class="headerlink" title="一些建议"></a>一些建议</h4><h5 id="u5BF9_u521D_u5B66_u8005"><a href="#u5BF9_u521D_u5B66_u8005" class="headerlink" title="对初学者"></a>对初学者</h5><p>对于刚迈入Android开发门槛的初学者，建议不要一上来就使用各种框架，这样有两点坏处：</p>
<ol>
<li>框架帮我们完成了功能，屏蔽了实现细节，导致自己看不到底层具体实现</li>
<li>框架一般抽象度较高，且对于初学者不易看懂，学习框架费时费力，事倍功半</li>
</ol>
<p>建议初学者实打实地一行一行代码写，如自己尝试封装一个HTTP请求的功能模块，自己写一个图片三级缓存，自己实现一个线程池调度器……扎扎实实打好基础，把握住本质的东西，以后对于各种框架就比较容易驾驭了。</p>
<p>因此对于初学者建议是不用框架。</p>
<h5 id="u5BF9_u4E2D_u9AD8_u7EA7_u5F00_u53D1_u8005"><a href="#u5BF9_u4E2D_u9AD8_u7EA7_u5F00_u53D1_u8005" class="headerlink" title="对中高级开发者"></a>对中高级开发者</h5><p>对于中高级开发者，如果要在项目中使用第三方框架的话，建议慎重选择合适的框架，且务必研读其源码，详细了解其实现原理、利弊等，否则一旦出现异常，都无从下手。假设App是亿级用户规模，使用任何第三方的东西都要小心，确保一切在掌握中才行。</p>
<h5 id="u5BF9_u6846_u67B6_u5F00_u53D1_u8005"><a href="#u5BF9_u6846_u67B6_u5F00_u53D1_u8005" class="headerlink" title="对框架开发者"></a>对框架开发者</h5><p>对于框架开发者，希望不要奔着名利的目的去贡献一个框架，不要重复造轮子，为大家提供真正精致优秀的框架，感谢！</p>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
    
      <a class="next" href="/page/2/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">AN</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>

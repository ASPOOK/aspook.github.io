<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="请不要灰心，你也会有人妒忌"/>













  <link rel="alternative" href="/default" title="ASPOOK" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://aspook.com/page/4/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />






  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> ASPOOK </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">ASPOOK</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">ASPOOK</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/06/如何判断是否可以使用某个Intent/">如何判断是否可以使用某个Intent</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-07-06
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>Android提供了一个称为Intent的强大易用的工具，Intent可以将应用转化为高等组件来使用并能比以前更好地重用代码。例如Android主屏幕和AnyCut广泛地使用Intent来创建快捷方式。虽然这种松耦合的API使用起来非常方便，但并不能保证你所发送的Intent一定会被另一个应用接收，这种情况会发生在某些特定的第三方应用程序，如Panoramio及它的RADAR Intent。</p>
<p>在开发一个新应用程序的时候，我想到了一个非常简单的方法来判断系统是否包含某个应用程序可以响应我想要使用的Intent。用户一般通过点击菜单来触发某个Intent，我实现了上述方法，如果某个系统无法响应某个Intent，我会把菜单置灰。实现代码是非常简单和易于遵循的，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Indicates whether the specified action can be used as an intent. This</span><br><span class="line"> * method queries the package manager for installed packages that can</span><br><span class="line"> * respond to an intent with the specified action. If no suitable package is</span><br><span class="line"> * found, this method returns false.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> context The application's environment.</span><br><span class="line"> * <span class="doctag">@param</span> action  The Intent action to check for availability.</span><br><span class="line"> * <span class="doctag">@return</span> True if an Intent with the specified action can be sent and</span><br><span class="line"> * responded to, false otherwise.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isIntentAvailable</span><span class="params">(Context context, String action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> PackageManager packageManager = context.getPackageManager();</span><br><span class="line">    <span class="keyword">final</span> Intent intent = <span class="keyword">new</span> Intent(action);</span><br><span class="line">    List&lt;ResolveInfo&gt; list =</span><br><span class="line">            packageManager.queryIntentActivities(intent,</span><br><span class="line">                    PackageManager.MATCH_DEFAULT_ONLY);</span><br><span class="line">    <span class="keyword">return</span> list.size() &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是具体的使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPrepareOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> scanAvailable = isIntentAvailable(<span class="keyword">this</span>,</span><br><span class="line">            <span class="string">"com.google.zxing.client.android.SCAN"</span>);</span><br><span class="line"></span><br><span class="line">    MenuItem item;</span><br><span class="line">    item = menu.findItem(R.id.menu_item_add);</span><br><span class="line">    item.setEnabled(scanAvailable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onPrepareOptionsMenu(menu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，如果手机中没有安装条码扫描应用，那么该菜单会被置灰。另一种简单的处理方法是在调用<code>startActivity()</code>后捕捉<code>ActivityNotFoundException</code>异常，但是这种方式只能是在问题发生后被动地响应，而不能预先判断，假如某个Intent不能被接收的话，就事先更改UI（如置灰）来阻止用户操作。这里介绍的方法也可以在启动时询问用户是否愿意安装所缺少的应用包，你也可以通过使用适当的URI方便地将用户引导到Android市场去下载应用。</p>
<p><a href="http://android-developers.blogspot.com.tr/2009/01/can-i-use-this-intent.html" target="_blank" rel="external">原文地址</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/06/Android进程间通信纪要/">Android进程间通信纪要</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-07-06
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h4 id="u8FDB_u7A0B_u95F4_u901A_u4FE1_u57FA_u7840"><a href="#u8FDB_u7A0B_u95F4_u901A_u4FE1_u57FA_u7840" class="headerlink" title="进程间通信基础"></a>进程间通信基础</h4><p>虽然Android是基于Linux的，但在Linux操作系统中的IPC技术在Android平台中被Binder Framework替代。Messenger、AIDL等进程间通信方式底层都是基于Binder的。</p>
<p>Android中每个app都有独立的虚拟机，不同虚拟机在内存分配上有不同的地址空间，一般来说每个app都对应着一个进程，因此进程间通信不像线程间那样可以通过共享内存来实现。</p>
<p>进程间通信传递的数据，包括传入参数与返回值都需要实现android.os.Parcelable接口。</p>
<p>由于远程方法可能是耗时的操作，因此请务必在客户端使用工作线程去执行RPC操作。除非你很清楚远端进程的操作是怎样的。 或者UI线程发起一个异步调用，通过callback来获取返回结果。如果从服务端调客户端的远程方法，如果也是耗时操作，同样需要开子线程。</p>
<p>Messenger机制是单线程顺序执行的，容易实现，其实质是基于AIDL的。所能传递的数据类型为Message，跟线程间使用Message机制类似，但要注意对object参数的限制。</p>
<h4 id="u4E24_u79CD_u5E38_u7528_u7684_u5E8F_u5217_u5316_u65B9_u5F0F"><a href="#u4E24_u79CD_u5E38_u7528_u7684_u5E8F_u5217_u5316_u65B9_u5F0F" class="headerlink" title="两种常用的序列化方式"></a>两种常用的序列化方式</h4><ol>
<li>Serializable——Java中的序列化方式，使用简单，开销较大，效率不是很高，比较适合磁盘序列化。</li>
<li>Parcelable—— Android中的序列化方式，实现较为繁琐，效率较高，适合内存序列化，也是在Android开发中推荐使用的序列化方式。</li>
</ol>
<h4 id="u5E38_u7528_u8FDB_u7A0B_u95F4_u901A_u4FE1_u65B9_u5F0F"><a href="#u5E38_u7528_u8FDB_u7A0B_u95F4_u901A_u4FE1_u65B9_u5F0F" class="headerlink" title="常用进程间通信方式"></a>常用进程间通信方式</h4><ol>
<li>通过Intent在Activity、Service或BroadcastReceiver间进行进程间通信，可通过Intent传递数据</li>
<li>AIDL方式</li>
<li>Messenger方式</li>
<li>利用ContentProvider</li>
<li>Socket方式</li>
<li>基于文件共享的方式</li>
</ol>
<h4 id="Binder_u8FDB_u7A0B_u95F4_u901A_u4FE1_u539F_u7406"><a href="#Binder_u8FDB_u7A0B_u95F4_u901A_u4FE1_u539F_u7406" class="headerlink" title="Binder进程间通信原理"></a>Binder进程间通信原理</h4><p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/imgs/IPC%20through%20Binder.png" alt=""></p>
<p>上图摘自Efficient Android Threading。</p>
<h4 id="AIDL_u8FDB_u7A0B_u95F4_u901A_u4FE1_u539F_u7406"><a href="#AIDL_u8FDB_u7A0B_u95F4_u901A_u4FE1_u539F_u7406" class="headerlink" title="AIDL进程间通信原理"></a>AIDL进程间通信原理</h4><p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/imgs/IPC%20with%20AIDL.png" alt=""></p>
<p>上图摘自Efficient Android Threading。</p>
<h4 id="Messenger_u8FDB_u7A0B_u95F4_u539F_u7406"><a href="#Messenger_u8FDB_u7A0B_u95F4_u539F_u7406" class="headerlink" title="Messenger进程间原理"></a>Messenger进程间原理</h4><p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/imgs/IPC%20with%20Messenger.png" alt=""></p>
<p>上图摘自Efficient Android Threading。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/05/LRU算法原理/">LRU算法原理</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-07-05
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Algorithms/">Algorithms</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h4 id="LRU_28Least_Recently_Used_29"><a href="#LRU_28Least_Recently_Used_29" class="headerlink" title="LRU(Least Recently Used)"></a>LRU(Least Recently Used)</h4><p>LRU即最近最少使用，常用作缓存算法，其原理如下。</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/imgs/LRU.jpg" alt=""></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/05/二叉树的构建及各种遍历方式/">二叉树的构建及各种遍历方式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-07-05
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Algorithms/">Algorithms</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h4 id="u6458_u8981"><a href="#u6458_u8981" class="headerlink" title="摘要"></a>摘要</h4><p>树型结构是一种非常重要的非线性数据结构，在计算机领域应用广泛，本文以二叉树为例，详细介绍二叉树的构建及遍历方式，其中包含递归实现的先序遍历、中序遍历及后续遍历，以及非递归实现的深度优先遍历、广度优先遍历。</p>
<h4 id="Java_u4EE3_u7801_u5B9E_u73B0"><a href="#Java_u4EE3_u7801_u5B9E_u73B0" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p>package me.geed.algorithms;</p>
<p>import java.util.LinkedList;<br>import java.util.Queue;<br>import java.util.Stack;</p>
<p>public class BinaryTree {<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**二叉树根节点*/</span></span><br><span class="line"><span class="keyword">private</span> Node rootNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 由整数数组构造二叉树</span><br><span class="line"> * <span class="doctag">@param</span> array</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">	rootNode = createBinaryTreeNode(array, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">private</span> Node leftChild;</span><br><span class="line">	<span class="keyword">private</span> Node rightChild;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 先序遍历二叉树--递归方式</span><br><span class="line"> * <span class="doctag">@param</span> node</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">		System.out.print(node.value + <span class="string">"  "</span>);</span><br><span class="line">		preOrderTraverse(node.leftChild);</span><br><span class="line">		preOrderTraverse(node.rightChild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 中序遍历二叉树--递归方式</span><br><span class="line"> * <span class="doctag">@param</span> node</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrderTraverse</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;			</span><br><span class="line">		midOrderTraverse(node.leftChild);</span><br><span class="line">		System.out.print(node.value + <span class="string">"  "</span>);</span><br><span class="line">		midOrderTraverse(node.rightChild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 后序遍历二叉树--递归方式</span><br><span class="line"> * <span class="doctag">@param</span> node</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderTraverse</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;			</span><br><span class="line">		postOrderTraverse(node.leftChild);			</span><br><span class="line">		postOrderTraverse(node.rightChild);</span><br><span class="line">		System.out.print(node.value + <span class="string">"  "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 深度优先遍历（跟先序遍历是一样的）--非递归实现</span><br><span class="line"> * 借助栈先进后出的特点，示例仅演示原理，如果追求效率可以使用ArrayDeque</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depthOrderTraverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (rootNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">	stack.push(rootNode);</span><br><span class="line">	<span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">		Node node = stack.pop();</span><br><span class="line">		System.out.print(node.value + <span class="string">"  "</span>);</span><br><span class="line">		<span class="keyword">if</span> (node.rightChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">			stack.push(node.rightChild);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (node.leftChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">			stack.push(node.leftChild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 广度优先遍历（跟层序遍历是一样的）--非递归实现</span><br><span class="line"> * 借助链表尾部进、头部出的特点，如追求效率可使用ArrayDeque</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrderTraverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (rootNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">	queue.add(rootNode);</span><br><span class="line">	<span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">		Node node = queue.remove();</span><br><span class="line">		System.out.print(node.value + <span class="string">"  "</span>);</span><br><span class="line">		<span class="keyword">if</span> (node.leftChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">			queue.add(node.leftChild);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (node.rightChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">			queue.add(node.rightChild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 创建二叉树的节点</span><br><span class="line"> * <span class="doctag">@param</span> array</span><br><span class="line"> * <span class="doctag">@param</span> index</span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">createBinaryTreeNode</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; array.length) &#123;</span><br><span class="line">		<span class="keyword">int</span> value = array[index];</span><br><span class="line">		<span class="keyword">if</span> (value != <span class="number">0</span>) &#123;</span><br><span class="line">			Node node = <span class="keyword">new</span> Node(value);</span><br><span class="line">			node.leftChild = createBinaryTreeNode(array, index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">			node.rightChild = createBinaryTreeNode(array, index * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 入口函數</span><br><span class="line"> * <span class="doctag">@param</span> args</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="keyword">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">29</span>, <span class="number">47</span>, <span class="number">35</span>, <span class="number">0</span>, <span class="number">99</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">68</span>, <span class="number">0</span>&#125;;</span><br><span class="line">	BinaryTree bTree = <span class="keyword">new</span> BinaryTree(array);</span><br><span class="line">	<span class="comment">/**  </span><br><span class="line">	 * 由以上数组生成的二叉树结构如下，0表示空节点</span><br><span class="line">	 * </span><br><span class="line">     *                  1 </span><br><span class="line">     *                /   \ </span><br><span class="line">     *               3     6 </span><br><span class="line">     *              / \   / \ </span><br><span class="line">     *             8  12 7  29 </span><br><span class="line">     *            / \   \   / </span><br><span class="line">     *           47 35  99 68  </span><br><span class="line">     */</span>  </span><br><span class="line">	System.out.println(<span class="string">"先序遍历二叉树"</span>);</span><br><span class="line">	bTree.preOrderTraverse(bTree.rootNode);</span><br><span class="line">	</span><br><span class="line">	System.out.println(<span class="string">"\n中序遍历二叉树"</span>);</span><br><span class="line">	bTree.midOrderTraverse(bTree.rootNode);</span><br><span class="line">	</span><br><span class="line">	System.out.println(<span class="string">"\n后序遍历二叉树"</span>);</span><br><span class="line">	bTree.postOrderTraverse(bTree.rootNode);</span><br><span class="line">	</span><br><span class="line">	System.out.println(<span class="string">"\n深度优先遍历二叉树"</span>);</span><br><span class="line">	bTree.depthOrderTraverse();</span><br><span class="line">	</span><br><span class="line">	System.out.println(<span class="string">"\n广度优先遍历二叉树"</span>);</span><br><span class="line">	bTree.levelOrderTraverse();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>}</p>
<h4 id="u8FD0_u884C_u7ED3_u679C"><a href="#u8FD0_u884C_u7ED3_u679C" class="headerlink" title="运行结果"></a>运行结果</h4><p>以上代码中的注释已经描述的比较清楚，程序运行结果如下：</p>
<p><em>先序遍历二叉树</em><br>1  3  8  47  35  12  99  6  7  29  68<br><em>中序遍历二叉树</em><br>47  8  35  3  12  99  1  7  6  68  29<br><em>后序遍历二叉树</em><br>47  35  8  99  12  3  7  68  29  6  1<br><em>深度优先遍历二叉树</em><br>1  3  8  47  35  12  99  6  7  29  68<br><em>广度优先遍历二叉树</em><br><em>1  3  6  8  12  7  29  47  35  99  68</em>  </p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/05/Bundle源码解析/">Bundle源码解析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-07-05
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>本文最初于2016-05-18发布于个人<a href="http://blog.csdn.net/ahence/article/details/51443722" target="_blank" rel="external">CSDN博客</a>。</p>
<h3 id="Bundle_u7684_u6982_u5FF5_u7406_u89E3"><a href="#Bundle_u7684_u6982_u5FF5_u7406_u89E3" class="headerlink" title="Bundle的概念理解"></a>Bundle的概念理解</h3><p>Bundle对于Android开发者来说肯定非常眼熟，它经常出现在以下场合：</p>
<ol>
<li>Activity状态数据的保存与恢复涉及到的两个回调：<code>void onSaveInstanceState (Bundle outState)</code>、<code>void onCreate (Bundle savedInstanceState)</code></li>
<li>Fragment的setArguments方法：<code>void setArguments (Bundle args)</code></li>
<li>消息机制中的Message的setData方法：<code>void setData (Bundle data)</code></li>
<li>其他场景不再列举</li>
</ol>
<p>Bundle从字面上解释为“一捆、一批、一包”，结合上述几个应用场合，可以知道Bundle是用来传递数据的，我们暂将Bundle理解为Android中用来传递数据的一个容器。官方文档对Bundle的说明如下：</p>
<blockquote>
<p>A mapping from String values to various Parcelable types.</p>
</blockquote>
<p>官方意为Bundle封装了String值到各种Parcelable类型数据的映射，可见跟我们上述理解是吻合的。</p>
<h3 id="Bundle_u6E90_u7801_u5206_u6790"><a href="#Bundle_u6E90_u7801_u5206_u6790" class="headerlink" title="Bundle源码分析"></a>Bundle源码分析</h3><p>知道了Bundle的主要作用，再来看源码就容易理解了。</p>
<p>Bundle位于<code>android.os</code>包中，是一个final类，这就注定了Bundle不能被继承。Bundle继承自BaseBundle并实现了Cloneable和Parcelable两个接口，因此对Bundle源码的分析会结合着对BaseBundle源码进行分析。由于实现了Cloneable和Parcelable接口，因此以下几个重载是必不可少的：</p>
<ul>
<li><code>public Object clone()</code></li>
<li><code>public int describeContents()</code></li>
<li><code>public void writeToParcel(Parcel parcel, int flags)</code></li>
<li><code>public void readFromParcel(Parcel parcel)</code></li>
<li><code>public static final Parcelable.Creator&lt;Bundle&gt; CREATOR = new Parcelable.Creator&lt;Bundle&gt;()</code> </li>
</ul>
<p>以上代码无需过多解释。</p>
<h4 id="Bundle_u7684_u51E0_u4E2A_u516C_u6709_u6784_u9020_u65B9_u6CD5"><a href="#Bundle_u7684_u51E0_u4E2A_u516C_u6709_u6784_u9020_u65B9_u6CD5" class="headerlink" title="Bundle的几个公有构造方法"></a>Bundle的几个公有构造方法</h4><table>
<thead>
<tr>
<th>公有构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public Bundle()</td>
<td>Constructs a new, empty Bundle</td>
</tr>
<tr>
<td>public Bundle(ClassLoader loader)</td>
<td>Constructs a new, empty Bundle that uses a specific ClassLoader for instantiating Parcelable and Serializable objects.</td>
</tr>
<tr>
<td>public Bundle(int capacity)</td>
<td>Constructs a new, empty Bundle sized to hold the given number of elements.</td>
</tr>
<tr>
<td>public Bundle(Bundle b)</td>
<td>Constructs a Bundle containing a copy of the mappings from the given Bundle.</td>
</tr>
<tr>
<td>public Bundle(PersistableBundle b)</td>
<td>Constructs a Bundle containing a copy of the mappings from the given PersistableBundle.</td>
</tr>
</tbody>
</table>
<p>第5个构造函数中的PersistableBundle也是继承自BaseBundle的，Bundle还提供了一个静态方法，用来返回只包含一个键值对的Bundle对象，具体源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bundle <span class="title">forPair</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">    Bundle b = <span class="keyword">new</span> Bundle(<span class="number">1</span>);</span><br><span class="line">    b.putString(key, value);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Bundle_u7684put_u4E0Eget_u65B9_u6CD5_u65CF"><a href="#Bundle_u7684put_u4E0Eget_u65B9_u6CD5_u65CF" class="headerlink" title="Bundle的put与get方法族"></a>Bundle的put与get方法族</h4><p>Bundle的功能是用来保存数据，那么必然提供了一系列存取数据的方法，这些方法太多了，几乎能够存取任何类型的数据，具体整理为下表：</p>
<table>
<thead>
<tr>
<th>相关保存方法</th>
<th>相关读取方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>public void putBoolean(String key, boolean value)</td>
<td>public boolean getBoolean(String key)</td>
</tr>
<tr>
<td>public void putByte(String key, byte value)</td>
<td>public byte getByte(String key)</td>
</tr>
<tr>
<td>public void putChar(String key, char value)</td>
<td>public char getChar(String key)</td>
</tr>
<tr>
<td>public void putShort(String key, short value)</td>
<td>public short getShort(String key)</td>
</tr>
<tr>
<td>public void putFloat(String key, float value)</td>
<td>public float getFloat(String key)</td>
</tr>
<tr>
<td>public void putCharSequence(String key, CharSequence value)</td>
<td>public CharSequence getCharSequence(String key)</td>
</tr>
<tr>
<td>public void putParcelable(String key, Parcelable value)</td>
<td>public <t extends="" parcelable=""> T getParcelable(String key)</t></td>
</tr>
<tr>
<td>public void putSize(String key, Size value)</td>
<td>public Size getSize(String key)</td>
</tr>
<tr>
<td>public void putSizeF(String key, SizeF value)</td>
<td>public SizeF getSizeF(String key)</td>
</tr>
<tr>
<td>public void putParcelableArray(String key, Parcelable[] value)</td>
<td>public Parcelable[] getParcelableArray(String key)</td>
</tr>
<tr>
<td>public void putParcelableArrayList(String key, ArrayList&lt;? extends Parcelable&gt; value)</td>
<td>public <t extends="" parcelable=""> ArrayList<t> getParcelableArrayList(String key)</t></t></td>
</tr>
<tr>
<td>public void putSparseParcelableArray(String key, SparseArray&lt;? extends Parcelable&gt; value)</td>
<td>public <t extends="" parcelable=""> SparseArray<t> getSparseParcelableArray(String key)</t></t></td>
</tr>
<tr>
<td>public void putIntegerArrayList(String key, ArrayList<integer> value)</integer></td>
<td>public ArrayList<integer> getIntegerArrayList(String key)</integer></td>
</tr>
<tr>
<td>public void putStringArrayList(String key, ArrayList<string> value)</string></td>
<td>public ArrayList<string> getStringArrayList(String key)</string></td>
</tr>
<tr>
<td>public void putCharSequenceArrayList(String key, ArrayList<charsequence> value)</charsequence></td>
<td>public ArrayList<charsequence> getCharSequenceArrayList(String key)</charsequence></td>
</tr>
<tr>
<td>public void putSerializable(String key, Serializable value)</td>
<td>public Serializable getSerializable(String key)</td>
</tr>
<tr>
<td>public void putBooleanArray(String key, boolean[] value)</td>
<td>public boolean[] getBooleanArray(String key)</td>
</tr>
<tr>
<td>public void putByteArray(String key, byte[] value)</td>
<td>public byte[] getByteArray(String key)</td>
</tr>
<tr>
<td>public void putShortArray(String key, short[] value)</td>
<td>public short[] getShortArray(String key)</td>
</tr>
<tr>
<td>public void putCharArray(String key, char[] value)</td>
<td>public char[] getCharArray(String key)</td>
</tr>
<tr>
<td>public void putFloatArray(String key, float[] value)</td>
<td>public float[] getFloatArray(String key)</td>
</tr>
<tr>
<td>public void putCharSequenceArray(String key, CharSequence[] value)</td>
<td>public CharSequence[] getCharSequenceArray(String key)</td>
</tr>
<tr>
<td>public void putBundle(String key, Bundle value)</td>
<td>public Bundle getBundle(String key)</td>
</tr>
<tr>
<td>public void putBinder(String key, IBinder value)</td>
<td>public IBinder getBinder(String key)</td>
</tr>
</tbody>
</table>
<p>除了上述存取数据涉及到的方法外，Bundle还提供了一个clear方法：<code>public void clear()</code>，该方法可用于移除Bundle中的所有数据。</p>
<p>Bundle之所以能以键值对的方式存储数据，实质上是因为它内部维护了一个ArrayMap，具体定义是在其父类BaseBundle中：</p>
<blockquote>
<p>ArrayMap&lt;String, ObjectmMap = null;</p>
</blockquote>
<p>ArrayMap比HashMap更加高效、更加节省内存，它的初始化是在Bundle的构造方法中实现的，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BaseBundle(ClassLoader loader, <span class="keyword">int</span> capacity) &#123;</span><br><span class="line">    mMap = capacity &gt; <span class="number">0</span> ?</span><br><span class="line">            <span class="keyword">new</span> ArrayMap&lt;String, Object&gt;(capacity) : <span class="keyword">new</span> ArrayMap&lt;String, Object&gt;();</span><br><span class="line">    mClassLoader = loader == <span class="keyword">null</span> ? getClass().getClassLoader() : loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外还可以发现，存储数据用的key都是String类型，值为各种数据类型，甚至可以存储Bundle、Binder等，如果ArrayMap中存在相同的key，则会替换掉之前的对应值。每一个put方法都对应一个get方法，对于基本数据类型还可以设置缺省值（上述表中未列出对应方法）。具体的存取则是在其父类BaseBundle中实现的，下面就以布尔类型数据为例来分析一下。</p>
<h4 id="Bundle_u5B58_u53D6_u6570_u636E_u7684_u5177_u4F53_u5B9E_u73B0"><a href="#Bundle_u5B58_u53D6_u6570_u636E_u7684_u5177_u4F53_u5B9E_u73B0" class="headerlink" title="Bundle存取数据的具体实现"></a>Bundle存取数据的具体实现</h4><p>布尔数据的存储源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Inserts a Boolean value into the mapping of this Bundle, replacing</span><br><span class="line"> * any existing value for the given key.  Either key or value may be null.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> key a String, or null</span><br><span class="line"> * <span class="doctag">@param</span> value a Boolean, or null</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putBoolean</span><span class="params">(String key, <span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">    unparcel();</span><br><span class="line">    mMap.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的mMap就是ArrayMap了，存储数据就是把键值对保存到ArrayMap里。</p>
<p>布尔类型数据的读取源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns the value associated with the given key, or false if</span><br><span class="line"> * no mapping of the desired type exists for the given key.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> key a String</span><br><span class="line"> * <span class="doctag">@return</span> a boolean value</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    unparcel();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"Getting boolean in "</span>+ Integer.toHexString(System.identityHashCode(<span class="keyword">this</span>)));</span><br><span class="line">    <span class="keyword">return</span> getBoolean(key, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getBoolean(String key, boolean defaultValue)的具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns the value associated with the given key, or defaultValue if</span><br><span class="line"> * no mapping of the desired type exists for the given key.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> key a String</span><br><span class="line"> * <span class="doctag">@param</span> defaultValue Value to return if key does not exist</span><br><span class="line"> * <span class="doctag">@return</span> a boolean value</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(String key, <span class="keyword">boolean</span> defaultValue)</span> </span>&#123;</span><br><span class="line">    unparcel();</span><br><span class="line">    Object o = mMap.get(key);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Boolean) o;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">        typeWarning(key, o, <span class="string">"Boolean"</span>, defaultValue, e);</span><br><span class="line">        <span class="keyword">return</span> defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据读取的逻辑也很简单，就是通过key从ArrayMap里读出保存的数据，并转换成对应的类型返回，当没找到数据或发生类型转换异常时返回缺省值。</p>
<p>注意到这里出现了一个方法：<code>unparcel()</code>，它的具体源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * If the underlying data are stored as a Parcel, unparcel them</span><br><span class="line"> * using the currently assigned class loader.</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* package */</span> <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unparcel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mParcelledData == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(<span class="keyword">this</span>))</span><br><span class="line">                + <span class="string">": no parcelled data"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mParcelledData == EMPTY_PARCEL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(<span class="keyword">this</span>))</span><br><span class="line">                + <span class="string">": empty"</span>);</span><br><span class="line">        <span class="keyword">if</span> (mMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mMap = <span class="keyword">new</span> ArrayMap&lt;String, Object&gt;(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMap.erase();</span><br><span class="line">        &#125;</span><br><span class="line">        mParcelledData = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> N = mParcelledData.readInt();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(<span class="keyword">this</span>))</span><br><span class="line">            + <span class="string">": reading "</span> + N + <span class="string">" maps"</span>);</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mMap = <span class="keyword">new</span> ArrayMap&lt;String, Object&gt;(N);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mMap.erase();</span><br><span class="line">        mMap.ensureCapacity(N);</span><br><span class="line">    &#125;</span><br><span class="line">    mParcelledData.readArrayMapInternal(mMap, N, mClassLoader);</span><br><span class="line">    mParcelledData.recycle();</span><br><span class="line">    mParcelledData = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(<span class="keyword">this</span>)) + <span class="string">" final map: "</span> + mMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先来看下BaseBundle中mParcelledData的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * If mParcelledData is non-null, then mMap will be null and the</span><br><span class="line"> * data are stored as a Parcel containing a Bundle.  When the data</span><br><span class="line"> * are unparcelled, mParcelledData willbe set to null.</span><br><span class="line"> */</span></span><br><span class="line">Parcel mParcelledData = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>在大部分情况下mParcelledData都是null，因此unparcel()直接返回。当使用构造函数<code>public Bundle(Bundle b)</code>创建Bundle时，会给mParcelledData赋值，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Constructs a Bundle containing a copy of the mappings from the given</span><br><span class="line"> * Bundle.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> b a Bundle to be copied.</span><br><span class="line"> */</span></span><br><span class="line">BaseBundle(BaseBundle b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b.mParcelledData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b.mParcelledData == EMPTY_PARCEL) &#123;</span><br><span class="line">            mParcelledData = EMPTY_PARCEL;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mParcelledData = Parcel.obtain();</span><br><span class="line">            mParcelledData.appendFrom(b.mParcelledData, <span class="number">0</span>, b.mParcelledData.dataSize());</span><br><span class="line">            mParcelledData.setDataPosition(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mParcelledData = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b.mMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mMap = <span class="keyword">new</span> ArrayMap&lt;String, Object&gt;(b.mMap);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mMap = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mClassLoader = b.mClassLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码片段可以知道mParcelledData的取值有3种情况：</p>
<ul>
<li>mParcelledData = EMPTY_PARCEL</li>
<li>mParcelledData = Parcel.obtain()</li>
<li>mParcelledData = null</li>
</ul>
<p>在<code>unparcel()</code>方法中就对上述几种情况做了不同的处理，当mParcelledData为null时，直接返回；当mParcelledData为EMPTY_PARCEL时，会创建一个容量为1的ArrayMap对象；当mParcelledData为Parcel.obtain()时，则会将里面的数据读出，并创建一个ArrayMap，并将数据存储到ArrayMap对象里面，同时将mParcelledData回收并置为null，具体是由以下代码片段实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N = mParcelledData.readInt();</span><br><span class="line"><span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(<span class="keyword">this</span>))</span><br><span class="line">        + <span class="string">": reading "</span> + N + <span class="string">" maps"</span>);</span><br><span class="line"><span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">    mMap = <span class="keyword">new</span> ArrayMap&lt;String, Object&gt;(N);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mMap.erase();</span><br><span class="line">    mMap.ensureCapacity(N);</span><br><span class="line">&#125;</span><br><span class="line">mParcelledData.readArrayMapInternal(mMap, N, mClassLoader);</span><br><span class="line">mParcelledData.recycle();</span><br><span class="line">mParcelledData = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>上面只是以布尔类型的数据为例分析了Bundle的存取过程，其他数据类型的存取原理相同，就不再赘述。</p>
<h4 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h4><p>到此，Bundle的源码分析基本就结束了，其实Bundle比较简单，只是一个数据容器，不像Activity等有复杂的生命周期。对于开发者来说，只需要了解Bundle的功能、使用场景并掌握常用的数据存取方法即可。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/03/如何构建安全的Android应用/">如何构建安全的Android应用</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-07-03
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h4 id="App_u7684_u5B89_u5168_u95EE_u9898"><a href="#App_u7684_u5B89_u5168_u95EE_u9898" class="headerlink" title="App的安全问题"></a>App的安全问题</h4><p>随着移动操作系统的日趋完善及App开发流程的逐渐成熟，App的安全问题得到越来越多的重视，同时很多App的安全问题被暴露出来，其中又以Android为甚，如App被反编译植入广告、App轻易被抓包、模拟App爬取服务器的数据等等。现在的Android开发者在开发一个App的时候，所想的就不仅仅是实现功能，而是要思考如何才能开发一个安全的应用。</p>
<p>花了两天时间看了《构建安全的Android App》一书，书中概括性地提到了关于Android安全的方方面面，大部分都是我们日常开发中遇到的情况，也许有的方面你注意到了，也许有的方面你还没有注意。根据此书提到的部分观点结合作者这几年的开发感悟，接下来总结一些关于Android App安全方面的经验。</p>
<h4 id="Android_App_u5B89_u5168_u7ECF_u9A8C"><a href="#Android_App_u5B89_u5168_u7ECF_u9A8C" class="headerlink" title="Android App安全经验"></a>Android App安全经验</h4><p>首先明确一点，所谓的安全，只是一个相对的概念，并没有绝对的安全。对于一个App，如果黑客有足够的时间并且足够坚定，那么他就能破解所有的App，因此我们所能做的只是让App相对更加安全，或者说增加应用被破解的难度。以下经验不分先后：</p>
<ul>
<li>从代码层面加以保护，如使用混淆器混淆代码。需要注意的是选择合适的混淆器及混淆级别，同时务必在上传APK到市场之前自己反编译一下，检查代码混淆是否起到作用。代码混淆只是保证APK被反编译后看到的是无意义的代码，加大理解难度，但并不能阻止被反汇编，好在Smail理解起来要比反编译得到的代码难度大多了。但Smail也有其语法，还是可以被破解的。</li>
<li>利用NDK，将某些关键性的逻辑或规则，如核心算法、加密规则等用C或C++来实现，这样可以大大增加代码被破的难度。但是没有绝对的安全，C或C++代码虽不能被反编译，但可以被反汇编，黑客还是可以读取二进制文件，遇到高手仍然无能为力。曾经我们App的加密算法写在C中还是被破了，也耳闻一位高手是如何破别人的算法库的，道高一尺，魔高一丈，就是这样互相博弈。</li>
<li>对资源进行混淆，由于我们一般对资源命名有着特定规则和含义，黑客们往往由于代码混淆而不好入手时，从而改为由资源文件作为突破口。资源混淆的原理跟代码混淆类似，就是把原来有意义的命名改为无意义的命名，如home.xml变成a.xml，原来一看就知道是首页相关布局，而混淆后就加大了理解难度。</li>
<li>对APK进行加固，目的是为了防止反编译。目前已有很多第三方的加密工具，有收费的也有免费的。如果有能力和精力，建议自己开发，使用第三方的工具，至少我个人不会放心。</li>
<li>不要将App中的敏感信息存储在外部存储器中，因为SD卡是大家都可以访问的。最好存在App的私有目录，最完美的做法是从不在客户端保存任何数据，都存储在云端。</li>
<li>与服务器通信时尽可能地使用HTTPS，并做真正的证书校验及主机验证，防止中间人攻击，保证数据通信安全，这样如果所有数据都在云端的话才有意义。</li>
<li>客户端本地数据库或SharedPreferences存储关键数据时不要存储明文，估计很多应用的用户名和密码都是以明文在客户端存储的，请务必加密，关于加密密钥后文会谈到。</li>
<li>使用已经存在的加密算法，而不要自己去写一个，已经证明过的总比未经证明的靠谱。</li>
<li>所有的加密尽可能使用非对称加密，加密密钥最好不要保存在本地，如果保存在本地，那一定要藏得隐蔽一些，或者写入C或C++中，不过要找到也只是时间问题。</li>
<li>对于进程间通信、广播接收、进程间隐式Intent调用，务必注意权限设置及安全防范，防止信息或数据泄露。</li>
<li>使用SQL参数化查询，避免SQL注入。</li>
<li>WebView中如果不需要JavaScript，那么一定要禁用，以防XSS攻击。可惜的是目前大多Hybrid App都是需要JavaScript的。对于Hybrid App，一定提醒Web开发人员将JavaScript代码进行混淆。</li>
<li>将App需要的权限需求减到最少，不要申请不必要的权限，因为权限越多，App越不安全。有一种非常好的方案是尽可能使用Intent的方式减少对权限的申请，如拨打电话，可以通过Intent调用系统拨号从而不必单独申请权限。</li>
<li>使用第三方SDK时，务必做好调查工作，了解该SDK是否含有不安全因素，如它在后台偷偷收集用户地理位置或App关键信息，甚至做其他见不得人的事。哪怕大厂提供的SDK也不能相信，根据国内的业界情况，你懂的。可以通过第三方SDK需要的权限来初步判断，如果它需要很多与其表述的功能无关的权限，那么你就不得不留心了。如果第三库是开源的，必须通读源码，如果非开源，可以试着反编译第三方库，尝试搜索可疑字符串。</li>
<li>做好安全验证工作，不仅仅是在客户端，也要在服务端同时做好，双管齐下。尽可能使用设备ID、设备Mac地址、设备型号品牌等信息来辅助用户名密码验证。</li>
<li>服务端的校验工作务必做好，另外尽量避免暴露RESTful API，因为这种API规则的统一性很容易在得知一个后实施其他侵入。</li>
<li>服务端需要根据请求数量或请求类型来决定一个单独IP的访问间隔和次数，如频繁访问则可能被认为是数据爬取而封锁该IP。</li>
<li>服务端应当与客户端约定请求验证规则，如利用随机数机制来阻止对服务器实施重放攻击。</li>
<li>在Android开发过程中，学会使用Lint工具，务必重视安全分类中的警告。</li>
</ul>
<p>上述每一条经验如果细讲的话都是一个很大的话题，限于篇幅原因在此没有详细阐述实施方案，欢迎大家留言讨论。由于个人经验有限，上面列举的只是暂时想到的，必定有所遗漏，同样欢迎大家分享补充关于Android App安全的策略和方案，最后希望大家都能开发出安全的App。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/06/29/工具类不应该有公有的构造函数/">工具类不应该有公有的构造函数</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-06-29
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Java/">Java</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>本文最初于2016-05-11发布在个人<a href="http://blog.csdn.net/ahence/article/details/51378880" target="_blank" rel="external">CSDN博客</a>。</p>
<h4 id="u5DE5_u5177_u7C7B_u4E0D_u5E94_u8BE5_u6709_u516C_u6709_u7684_u6784_u9020_u51FD_u6570"><a href="#u5DE5_u5177_u7C7B_u4E0D_u5E94_u8BE5_u6709_u516C_u6709_u7684_u6784_u9020_u51FD_u6570" class="headerlink" title="工具类不应该有公有的构造函数"></a>工具类不应该有公有的构造函数</h4><p>工具类是一系列静态成员或方法的集合，意味着它不可以被实例化，即使是抽象的工具类，它可以被继承，但也不应有公有的构造函数。</p>
<p>Java类如果没有声明构造函数，则会默认有一个公有的构造函数，因此需要给工具类至少声明一个非公有的构造函数。</p>
<h4 id="u4E0D_u89C4_u8303_u7684_u4EE3_u7801_u793A_u4F8B"><a href="#u4E0D_u89C4_u8303_u7684_u4EE3_u7801_u793A_u4F8B" class="headerlink" title="不规范的代码示例"></a>不规范的代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringUtils</span> </span>&#123; <span class="comment">// Noncompliant</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatenate</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> s1 + s2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u89E3_u51B3_u65B9_u6848"><a href="#u89E3_u51B3_u65B9_u6848" class="headerlink" title="解决方案"></a>解决方案</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringUtils</span> </span>&#123; <span class="comment">// Compliant</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">StringUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatenate</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> s1 + s2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原文地址：<a href="https://dev.eclipse.org/sonar/coding_rules#q=squid%3AS1118|s=createdAt|asc=false" target="_blank" rel="external">Utility classes should not have public constructors</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/06/25/Android开发书籍推荐/">Android开发书籍推荐</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-06-25
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>本文同步发布在个人<a href="http://blog.csdn.net/ahence/article/details/51760713" target="_blank" rel="external">CSDN博客</a>。</p>
<h4 id="Android_u5F00_u53D1_u4E66_u7C4D_u63A8_u8350"><a href="#Android_u5F00_u53D1_u4E66_u7C4D_u63A8_u8350" class="headerlink" title="Android开发书籍推荐"></a>Android开发书籍推荐</h4><p>作为一名Android开发者，推荐几本个人认为不错的书，本着负责任的态度，以下推荐都是个人看过的，这些书目可能更适合中高级开发者，排名不分先后：</p>
<ul>
<li><p>《深入理解计算机系统》——程序员是要跟计算机打交道的，那么最好首先明白它的工作原理，才能让你的代码游刃有余。</p>
</li>
<li><p>《图解HTTP》——如今单机版的App还有吗？绝大多数App的网络通信是基于HTTP协议的，所以你需要深入了解它。</p>
</li>
<li><p>《Effective Java 中文版（第2版）》——会Java只能让你写出普通的Android App，而这本书将告诉你如何用Java写出高效的App。如果你说你用H5、JS、Kotlin或者以后用Swift开发Android，那就当我没推荐。</p>
</li>
<li><p>《Efficient Android Threading》——Android中极为重要的概念之一，想一想每个界面的主线程、工作线程及线程通信吧。</p>
</li>
<li><p>《Pro Android Apps Performance Optimization》——这本书教你从哪些方面并且怎样进行Android性能优化。</p>
</li>
<li><p>《Android开发艺术探索》——为数不多的国内作者写的不错的书，对Android知识点结合源码进行较为深入的分析。</p>
</li>
<li><p>《App研发录》——也是国内作者写的，我也看到某人在博文里批此书内容空洞，但我认为是一本好书，喜欢作者提纲挈领，概括总结的风格，而不是拘泥于细节和代码。</p>
</li>
<li><p>《构建安全的Android App》——你的App被反编译过吗或者你反编译过别人的App吗？在这个年代，App安全越来越得到重视，所以它也是你需要的。PS:此书刚刚到手，简单翻阅了目录，如果看完觉得不好，再把它撤下来。</p>
</li>
<li><p>Android官方开发文档及Android源码——原谅我不得不把它列进来，甚至它比上述所有书籍都重要，它是一座宝库，希望大家千万要重视并好好利用，同时还可以练习英语哦，一举两得。</p>
<p>由于市面上相关书目众多，质量良莠不齐，希望以上推荐能帮大家筛选出一些好书。</p>
<p>切记读书不要贪多，重点在于吸收理解，本人愚钝，某些书籍的精彩篇章，甚至会读3遍甚至更多，往往每次阅读都有新的收获。</p>
<p>聊到读书，突然兴致倍增，但由于标题限制，无法涉及文史地理、风花雪月。原本是想做一个文艺青年的，原本是最爱文史的，原本是最爱席慕蓉的，后来却学了理工科，成了Android开发者，但是那些依然是我喜爱的。欢迎大家跟我交流，互相推荐好书，不局限于技术！</p>
</li>
</ul>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/06/25/Android文件存储/">Android文件存储</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-06-25
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>本文最初于2015-08-14发布于个人<a href="http://blog.csdn.net/ahence/article/details/47659263" target="_blank" rel="external">CSDN博客</a>。</p>
<p>Android文件系统跟其他平台基于磁盘的文件系统类似，这篇教程描述了如何使用文件相关的API在Android文件系统上进行读写操作。</p>
<p>File对象适合读写大量的流式数据，如图片文件或其他文件的网络传输。</p>
<p>这篇教程将演示如何在App中执行基本的文件操作，并假设读者对Linux文件系统和Java标准的文件输入输出有一定基础。</p>
<h4 id="u9009_u62E9_u5185_u90E8_u5B58_u50A8_u8FD8_u662F_u5916_u90E8_u5B58_u50A8"><a href="#u9009_u62E9_u5185_u90E8_u5B58_u50A8_u8FD8_u662F_u5916_u90E8_u5B58_u50A8" class="headerlink" title="选择内部存储还是外部存储"></a>选择内部存储还是外部存储</h4><p>所有的Android设备都将文件存储区域分为两部分：内部存储和外部存储。这种命名来源于早期的Android系统，当时大部分的设备都有一个内置的不可变的内存（内部存储），另外还有一个可移除的存储介质，如SD卡（外部存储），后来即使设备没有可移除的存储介质了，依然习惯性地将永久存储空间划分为“内部”和“外部”，并且无论外部存储是否可以移除，这两部分存储空间的API行为都是一样的。下面分别总结每个存储空间的特点：</p>
<h4 id="u5185_u90E8_u5B58_u50A8"><a href="#u5185_u90E8_u5B58_u50A8" class="headerlink" title="内部存储"></a>内部存储</h4><ol>
<li>总是可用的</li>
<li>内部存储空间内的文件默认只有你的App可以访问</li>
<li>当用户卸载了你的App，系统从内部存储空间中移除所有你的App相关的文件</li>
</ol>
<p>当你希望用户和其他App都不能访问你的文件时，内部存储是最好的选择。</p>
<h4 id="u5916_u90E8_u5B58_u50A8"><a href="#u5916_u90E8_u5B58_u50A8" class="headerlink" title="外部存储"></a>外部存储</h4><ol>
<li>并非总是可用的，因为用户可能将外部存储作为USB存储，某些情况下甚至会从设备上移除外部存储</li>
<li>它是大家都可以访问的，存储在这里的文件可以被其他应用程序访问</li>
<li>当用户卸载了你的App，系统仅仅会移除存储在通过 getExternalFilesDir()获取到的路径中的该App相关的文件</li>
</ol>
<p>当你的文件不需要访问限制，或者你想将文件分享给其他的App，或者允许用户通过电脑来访问它，那么外部存储是最好的选择。</p>
<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p>尽管App默认是被安装到内部存储空间中，但是你可以通过在AndroidManifest中指定android:installLocation属性来使App安装到外部存储空间。当APK文件很大且外部空间比内部空间大时，用户或许会喜欢这样做。如需要了解更多信息，请参考<a href="http://developer.android.com/guide/topics/data/install-location.html" target="_blank" rel="external">App InstallLocation</a>。</p>
<h4 id="u83B7_u53D6_u5916_u90E8_u5B58_u50A8_u7684_u6743_u9650"><a href="#u83B7_u53D6_u5916_u90E8_u5B58_u50A8_u7684_u6743_u9650" class="headerlink" title="获取外部存储的权限"></a>获取外部存储的权限</h4><p>为了在外部存储空间中写入数据，需要在AndroidManifest文件中加入权限：WRITE_EXTERNAL_STORAGE，如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：现在应用将获得读取外部存储空间的能力而不需要提供特别的权限，然而，这在以后的版本中可能会改变。如果应用需要读外部存储（但是不需要写），那么需要声明READ_EXTERNAL_STORAGE权限。在这个改变发生之前，为了保证应用能持续地按所期待地工作，那么最好现在就声明读权限，如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.READ_EXTERNAL_STORAGE"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是，如果应用声明了WRITE_EXTERNAL_STORAGE权限，那么它就默认有了读取外部存储空间的权限。</p>
<p>如果想保存文件到内部存储空间，则不需要声明任何权限。因为应用本身就有权限对内部存储空间进行读写。</p>
<h4 id="u4FDD_u5B58_u6587_u4EF6_u5230_u5185_u90E8_u5B58_u50A8_u7A7A_u95F4"><a href="#u4FDD_u5B58_u6587_u4EF6_u5230_u5185_u90E8_u5B58_u50A8_u7A7A_u95F4" class="headerlink" title="保存文件到内部存储空间"></a>保存文件到内部存储空间</h4><p>当保存一个文件到内部存储空间时，可以通过下面任一个方法来获得一个合适的目录作为File：</p>
<p><code>getFilesDir()</code></p>
<p>为你的应用返回一个代表内部目录的File对象。</p>
<p><code>getCacheDir()</code></p>
<p>为你的应用返回一个代表内部临时缓存文件目录的File对象。需要对该文件目录设置一个合理的大小，如1M，并且确保在不需要的时候删除里面的文件。如果系统存储空间不足时，可能会在没有警告的条件下删除缓存的文件。</p>
<p>如果要在内部存储目录下创建一个文件，可以使用File()构造函数，传入使用上述两个方法之一获取的File对象，它指定了内部存储的路径。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(context.getFilesDir(), filename);</span><br></pre></td></tr></table></figure>
<p>或者，可以调用openFileOutput()来获取一个FileOutputStream来写入内部存储路径下的某个文件，下面的例子说明了如何将一些文本写入文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String filename = <span class="string">"myfile"</span>;</span><br><span class="line">String string = <span class="string">"Hello world!"</span>;</span><br><span class="line">FileOutputStream outputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  outputStream = openFileOutput(filename, Context.MODE_PRIVATE);</span><br><span class="line">  outputStream.write(string.getBytes());</span><br><span class="line">  outputStream.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，如果需要缓存一些文件，应该使用createTempFile()。例如下面的示例从一个URL中提取出文件名，然后在应用的内部缓存目录创建了一个以该文件名命名的文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getTempFile</span><span class="params">(Context context, String url)</span> </span>&#123;</span><br><span class="line">    File file;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String fileName = Uri.parse(url).getLastPathSegment();</span><br><span class="line">        file = File.createTempFile(fileName, <span class="keyword">null</span>, context.getCacheDir());</span><br><span class="line">    <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// Error while creating file</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：App的内部存储目录位于Android文件系统中通过应用包名决定的特定位置，从技术上讲，如果你的文件设置为可读，其他应用可以读取你的内部文件，但是其他应用需要知道你应用的包名和文件名。如果你的文件没有设置为可读，那么其他应用是不能访问该App的内部目录并读写你的文件的。因为只要使用了MODE_PRIVATE模式，其他应用就不能访问。</p>
<h4 id="u4FDD_u5B58_u6587_u4EF6_u5230_u5916_u90E8_u5B58_u50A8"><a href="#u4FDD_u5B58_u6587_u4EF6_u5230_u5916_u90E8_u5B58_u50A8" class="headerlink" title="保存文件到外部存储"></a>保存文件到外部存储</h4><p>因为外部存储空间有时是不可用的，比如将外部存储空间连接到PC或者SD卡被移除的时候，所以应该在访问它的时候检查它的可用性。通常可以使用getExternalStorgeState()来查询外部存储空间的状态，如果状态为MEDIA_MOUNTED，那么就可以读写文件。下面是检查外部存储空间是否可用的有效方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Checks if external storage is available for read and write */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExternalStorageWritable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String state = Environment.getExternalStorageState();</span><br><span class="line">    <span class="keyword">if</span> (Environment.MEDIA_MOUNTED.equals(state)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Checks if external storage is available to at least read */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExternalStorageReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String state = Environment.getExternalStorageState();</span><br><span class="line">    <span class="keyword">if</span> (Environment.MEDIA_MOUNTED.equals(state) ||</span><br><span class="line">        Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管外部存储可以被用户和其他应用访问修改，有两种类型的文件可以保存在这里：</p>
<p>Public files</p>
<p>这类文件对于用户或其他应用都是可访问的，当用户卸载了你的App时，这些文件依然保留并可被用户访问。例如，你的App所拍摄的照片或下载的文件。</p>
<p>Private files</p>
<p>这类文件仅属于你的App,并且会随着App的卸载而被删除。因为这些文件存储在外部，因此在技术上这些文件是可以被用户和其他应用访问的，但这对于你的App之外的用户是没有什么价值的。当用户卸载掉App时，系统会删除该App所属的外部私有目录下的所有文件。例如App下载的额外资源文件或临时性的多媒体文件。</p>
<p>如果想在外部存储空间上保存公有文件，可以使用getExternalStoragePublicDirectory()方法来获取一个代表外部空间合适目录的File对象。这个方法需要一个参数来指定你所保存文件的类型，以便于跟其他公有文件分类。该参数类型有DIRECTORY_MUSIC或DIRECTORY_PICTURES等。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getAlbumStorageDir</span><span class="params">(String albumName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Get the directory for the user's public pictures directory. </span></span><br><span class="line">    File file = <span class="keyword">new</span> File(Environment.getExternalStoragePublicDirectory(</span><br><span class="line">            Environment.DIRECTORY_PICTURES), albumName);</span><br><span class="line">    <span class="keyword">if</span> (!file.mkdirs()) &#123;</span><br><span class="line">        Log.e(LOG_TAG, <span class="string">"Directory not created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想保存对于App私有的文件，可以调用getExternalFilesDir()来获取合适的文件目录，并传入一个指定文件类型的参数。通过这种方式创建的目录都会被添加到封装了该App所有外部存储文件的目录下，并且会在用户卸载App时被系统删除。下面例子可以用来创建一个个人相册的目录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getAlbumStorageDir</span><span class="params">(Context context, String albumName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Get the directory for the app's private pictures directory. </span></span><br><span class="line">    File file = <span class="keyword">new</span> File(context.getExternalFilesDir(</span><br><span class="line">            Environment.DIRECTORY_PICTURES), albumName);</span><br><span class="line">    <span class="keyword">if</span> (!file.mkdirs()) &#123;</span><br><span class="line">        Log.e(LOG_TAG, <span class="string">"Directory not created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果预定义的子目录并不适合存放我们的文件，可以调用getExternalFilesDir()并传入null，它会返回外部存储空间上该App的私有目录的根目录。</p>
<p>请记住，通过getExternalFilesDir()方法创建的目录会随着App的卸载被删除。如果想在App被卸载后仍然可以使用这些文件，比如一个拍照的App，我们想在卸载后依然保存照片，那么就应该使用getExternalStoragePublicDirectory()。</p>
<p>无论是使用getExternalStoragePublicDirectory()来保存共享文件还是使用getExternalFilesDir()保存App私有的文件，重要的是尽可能使用API常量提供的目录名称，如DIRECTORY_PICTURES，这些目录名称能保证系统正确地对待里面的文件。例如，以DIRECTORY_RINGTONES类型存储的文件会被系统识别为铃声而不是音乐。</p>
<h4 id="u67E5_u8BE2_u5269_u4F59_u7A7A_u95F4"><a href="#u67E5_u8BE2_u5269_u4F59_u7A7A_u95F4" class="headerlink" title="查询剩余空间"></a>查询剩余空间</h4><p>如果你事先知道要保存的文件的大小，可以通过调用getFreeSpace()或getTotalSpace()来判断是否有足够的空间，从而避免发生IOException。这些方法可以获得当前可用的空间以及总容量的大小，这些信息对于在一定阈值以上的存储空间上存储文件是很有用的。</p>
<p>然而，系统并不能保证可以写入getFreeSpace()大小的文件，如果剩余空间比你想要存储的文件大几M，或者存储空间使用还不到90%，那么继续存储文件一般是安全的，否则最好不要再写入文件。</p>
<p><strong>注意</strong>：其实并非强制在保存文件之前一定要对剩余空间进行查询。你可以直接尝试写入文件，然后捕捉IOException，如果你事先不知道到底需要多少存储空间的时候可以这样做。例如，当你把PNG图片转换为JPEG时，事先并不知道生成的图片大小是多少。</p>
<h4 id="u5220_u9664_u6587_u4EF6"><a href="#u5220_u9664_u6587_u4EF6" class="headerlink" title="删除文件"></a>删除文件</h4><p>你应该在不再需要的时候删除文件，最直接的方法是通过调用文件的delete()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFile.delete();</span><br></pre></td></tr></table></figure>
<p>如果文件是保存在内部存储空间上的，还可以调用Context的deleteFile()方法来定位和删除文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myContext.deleteFile(fileName);</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：当用户卸载了App，Android系统会删除如下文件：</p>
<ol>
<li>所有保存在内部存储空间的文件</li>
<li>所有保存在通过getExternalFilesDir()获取的外部存储空间目录的文件</li>
</ol>
<p>然而，你应该定期地删除所有通过getCacheDir()创建的缓存文件以及那些不再使用的文件。</p>
<p><a href="http://developer.android.com/training/basics/data-storage/files.html" target="_blank" rel="external">原文地址</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/06/23/巧用AsyncTask的onProgressUpdate回调/">巧用AsyncTask的onProgressUpdate回调</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-06-23
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>本文最初于2016-04-05发布于个人<a href="http://blog.csdn.net/ahence/article/details/51064466" target="_blank" rel="external">CSDN博客</a>。</p>
<h3 id="AsyncTask_u7B80_u4ECB"><a href="#AsyncTask_u7B80_u4ECB" class="headerlink" title="AsyncTask简介"></a>AsyncTask简介</h3><p>AsyncTask相信大家已经特别熟悉了，它是Android提供的一个轻量级的异步处理类。它简单易用，可以很容易地执行后台任务，也可以很方便地将后台任务执行的进度与结果发送到UI线程。</p>
<h3 id="u7231_u4E0E_u6068"><a href="#u7231_u4E0E_u6068" class="headerlink" title="爱与恨"></a>爱与恨</h3><p>由于Android的单线程模型，异步处理在Android开发中显得尤为重要，因此线程中的交互不可避免。假如我们利用Android消息机制自己实现这个过程，则较为复杂且有着发生各种各样错误的风险。使用AsyncTask则较为方便，它为我们封装好了工作线程的执行与交互的过程，我们仅需要派生一个AsyncTask的子类，实现几个回调，然后在UI线程启动这个task即可，整个使用过程相当简单。<br>但世界上没有十全十美的东西，AsyncTask也一样，虽然它轻便易用，但也有一些坑，让人又爱又恨。<br>如AsyncTask跟系统版本的关系，AsyncTask在API 4之前是串行执行的，在API 4~12则是并行执行的，等到了API 13+，它又改回了串行执行，另外AsyncTask.executeOnExecutor()则是在API 11才开始支持的，因此如果想让各版本实现一致的用户体验，就不得不注意这些陷阱。</p>
<p>AsyncTask虽然简单，但也有一些场景并非最佳选择，如一个后台任务，并不需要传入参数也不需要其返回数据，这种场景完全可以使用一个Thread来替代。还有假如某个后台任务需要Looper，则使用HandlerThread可能是更好的选择。</p>
<p>由于本文主题为“巧用onProgressUpdate回调”，因此以上只是简单概括一下AsyncTask的优缺点，真要写的话，就成了一篇很长的文章了，相关的文章网上也有很多。如果有不清楚的也可留言讨论，另外建议看一下AsyncTask的源码，下面切入主题。</p>
<h3 id="u5DE7_u7528onProgressUpdate_u56DE_u8C03"><a href="#u5DE7_u7528onProgressUpdate_u56DE_u8C03" class="headerlink" title="巧用onProgressUpdate回调"></a>巧用onProgressUpdate回调</h3><p>先来看下AsyncTask的几个主要回调：</p>
<ul>
<li><code>onPreExecute</code> 此回调是在主线程执行的，用来在后台任务执行前做一些预处理的工作。</li>
<li><code>doInBackground</code> 此回调是最重要的一个，用来处理后台任务，因此它必须在子线程运行。</li>
<li><code>onProgressUpdate</code> 此回调会将后台任务的执行进度发到UI线程，因此它是在UI线程中运行的，而且它是与<code>doInBackground</code>同时运行的。</li>
<li><code>onPostExecute</code> 顾名思义，此回调表示当后台任务执行完了，会通过它将结果返回给UI线程，它是在UI线程运行的。</li>
<li><code>onCancelled</code> 当取消一个任务时，会走到这个回调。</li>
</ul>
<p>创建一个AsyncTask子类的方法一般如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageDownloadTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">int</span>, <span class="title">Object</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是AsyncTask的实现类需要定义为静态内部类或者独立类，否则会持有外部类的引用，可能造成内存泄露。</p>
<p>上面的三个参数，第一个表示输入的参数，可以从UI线程传到子线程；第二个参数一般表示任务的执行进度，所以最常见的就是int类型；第三个参数则表示子线程执行完任务，返回给UI线程的数据类型，可为任意对象。</p>
<p>因此对于回调的使用，我们通常是这样的：<code>doInBackground</code>执行后台任务；<code>onProgressUpdate</code>用来更新后台任务的执行进度，最常见的如下载进度；执行完任务后，使用<code>onPostExecute</code>将结果返回给UI线程。</p>
<p>这里来展示一种巧用<code>onProgressUpdate</code>回调的场景，假设一个任务需要下载多张图片。可以让<code>onProgressUpdate</code>回调里返回下载好的图片，这样就可以在下载过程中，下载好一张图片展示一张，而不必等到多张图片全部下载完成后再通过<code>onPostExecute</code>回调将结果返回，实时渲染的用户体验显然更好，至于<code>onPostExecute</code>，则完全可以不用了。如果你想问如何确保<code>onProgressUpdate</code>在下载好每一张图片后会被调用？那么还记得<code>publishProgress</code>方法吗？它在源代码里的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * This method can be invoked from &#123;<span class="doctag">@link</span> #doInBackground&#125; to</span><br><span class="line"> * publish updates on the UI thread while the background computation is</span><br><span class="line"> * still running. Each call to this method will trigger the execution of</span><br><span class="line"> * &#123;<span class="doctag">@link</span> #onProgressUpdate&#125; on the UI thread.</span><br><span class="line"> *</span><br><span class="line"> * &#123;<span class="doctag">@link</span> #onProgressUpdate&#125; will not be called if the task has been</span><br><span class="line"> * canceled.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> values The progress values to update the UI with.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@see</span> #onProgressUpdate</span><br><span class="line"> * <span class="doctag">@see</span> #doInBackground</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@WorkerThread</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishProgress</span><span class="params">(Progress... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">        getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class="line">                <span class="keyword">new</span> AsyncTaskResult&lt;Progress&gt;(<span class="keyword">this</span>, values)).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释已经写的很明确了，只需要在<code>doInBackground</code>里的合适地方调用<code>publishProgress</code>就可以触发<code>onProgressUpdate</code>回调了。</p>
<h3 id="u4EE3_u7801_u793A_u4F8B"><a href="#u4EE3_u7801_u793A_u4F8B" class="headerlink" title="代码示例"></a>代码示例</h3><p>这里就是上述巧用场景的具体实现，一个Activity界面，一个下载按钮，点击后就会启动一个AsyncTask去下载4张图片，同时显示一个进度条，下载完成后，进度条消失。</p>
<h4 id="u754C_u9762_u5E03_u5C40"><a href="#u754C_u9762_u5E03_u5C40" class="headerlink" title="界面布局"></a>界面布局</h4><p>该示例的界面布局如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">RelativeLayout</span></span><br><span class="line"><span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line"><span class="attribute">xmlns:app</span>=<span class="value">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line"><span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span></span><br><span class="line"><span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line"><span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line"><span class="attribute">android:paddingBottom</span>=<span class="value">"@dimen/activity_vertical_margin"</span></span><br><span class="line"><span class="attribute">android:paddingLeft</span>=<span class="value">"@dimen/activity_horizontal_margin"</span></span><br><span class="line"><span class="attribute">android:paddingRight</span>=<span class="value">"@dimen/activity_horizontal_margin"</span></span><br><span class="line"><span class="attribute">android:paddingTop</span>=<span class="value">"@dimen/activity_vertical_margin"</span></span><br><span class="line"><span class="attribute">app:layout_behavior</span>=<span class="value">"@string/appbar_scrolling_view_behavior"</span></span><br><span class="line"><span class="attribute">tools:context</span>=<span class="value">"me.geed.cleverasynctask.MainActivity"</span></span><br><span class="line"><span class="attribute">tools:showIn</span>=<span class="value">"@layout/activity_main"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">ProgressBar</span></span><br><span class="line">    <span class="attribute">android:id</span>=<span class="value">"@+id/progress"</span></span><br><span class="line">    <span class="attribute">style</span>=<span class="value">"@style/Base.Widget.AppCompat.ProgressBar.Horizontal"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">    <span class="attribute">android:layout_alignParentTop</span>=<span class="value">"true"</span></span><br><span class="line">    <span class="attribute">android:visibility</span>=<span class="value">"gone"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">Button</span></span><br><span class="line">    <span class="attribute">android:id</span>=<span class="value">"@+id/btn_start"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">    <span class="attribute">android:layout_below</span>=<span class="value">"@+id/progress"</span></span><br><span class="line">    <span class="attribute">android:text</span>=<span class="value">"开始下载"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">ScrollView</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">    <span class="attribute">android:layout_below</span>=<span class="value">"@+id/btn_start"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">LinearLayout</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/lL_image_container"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ScrollView</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="u76F8_u5173_u63A7_u4EF6_u53CA_u754C_u9762_u7684_u521D_u59CB_u5316"><a href="#u76F8_u5173_u63A7_u4EF6_u53CA_u754C_u9762_u7684_u521D_u59CB_u5316" class="headerlink" title="相关控件及界面的初始化"></a>相关控件及界面的初始化</h4><p>相关控件及变量的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] IMAGE_URLS = &#123;</span><br><span class="line">        <span class="string">"http://img0w.pconline.com.cn/pconline/1401/15/4172339_touxiang/spcgroup/width_640,qua_30/23.jpg"</span>,</span><br><span class="line">        <span class="string">"http://img0w.pconline.com.cn/pconline/1401/15/4172339_touxiang/spcgroup/width_640,qua_30/22.jpg"</span>,</span><br><span class="line">        <span class="string">"http://img0w.pconline.com.cn/pconline/1401/15/4172339_touxiang/spcgroup/width_640,qua_30/24.jpg"</span>,</span><br><span class="line">        <span class="string">"http://img0w.pconline.com.cn/pconline/1401/15/4172339_touxiang/spcgroup/width_640,qua_30/26.jpg"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasExecuted = <span class="keyword">false</span>;</span><br><span class="line">ImageDownloadTask mImageDownloadTask;</span><br><span class="line">ProgressBar mProgressBar;</span><br><span class="line">LinearLayout mLinearLayout;</span><br><span class="line">Button mButton;</span><br></pre></td></tr></table></figure>
<p>初始化如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mLinearLayout = (LinearLayout) findViewById(R.id.lL_image_container);</span><br><span class="line">mProgressBar = (ProgressBar) findViewById(R.id.progress);</span><br><span class="line">mProgressBar.setMax(IMAGE_URLS.length);</span><br><span class="line">mButton = (Button) findViewById(R.id.btn_start);</span><br><span class="line">mImageDownloadTask = <span class="keyword">new</span> ImageDownloadTask(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<h4 id="AsyncTask_u7684_u5B9A_u4E49"><a href="#AsyncTask_u7684_u5B9A_u4E49" class="headerlink" title="AsyncTask的定义"></a>AsyncTask的定义</h4><p>AsyncTask定义为一个内部类，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * AsyncTask的实现类需要定义为静态内部类或者独立类，否则会持有外部类的引用，可能造成内存泄露</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageDownloadTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Bitmap</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MainActivity mActivity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageDownloadTask</span><span class="params">(MainActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mActivity = activity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setActivity</span><span class="params">(MainActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mActivity = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPreExecute();</span><br><span class="line">        mActivity.mProgressBar.setVisibility(View.VISIBLE);</span><br><span class="line">        mActivity.mProgressBar.setProgress(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(String... urls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String url : urls) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">                Bitmap bitmap = downloadImage(url);</span><br><span class="line">                publishProgress(bitmap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Bitmap... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onProgressUpdate(values);</span><br><span class="line">        <span class="keyword">if</span> (mActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mActivity.mProgressBar.setProgress(++mCount);</span><br><span class="line">            ImageView iv = <span class="keyword">new</span> ImageView(mActivity);</span><br><span class="line">            iv.setImageBitmap(values[<span class="number">0</span>]);</span><br><span class="line">            mActivity.mLinearLayout.addView(iv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Void aVoid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPostExecute(aVoid);</span><br><span class="line">        <span class="keyword">if</span> (mActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mActivity.mProgressBar.setVisibility(View.GONE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCancelled();</span><br><span class="line">        <span class="keyword">if</span> (mActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mActivity.mProgressBar.setVisibility(View.GONE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 图片下载，真正app中的实现可能并非这样</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> imageUrl</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Bitmap <span class="title">downloadImage</span><span class="params">(String imageUrl)</span> </span>&#123;</span><br><span class="line">        Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bitmap = BitmapFactory.decodeStream((InputStream) <span class="keyword">new</span> URL(imageUrl).getContent());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bitmap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AsyncTask_u7684_u542F_u52A8_u6267_u884C"><a href="#AsyncTask_u7684_u542F_u52A8_u6267_u884C" class="headerlink" title="AsyncTask的启动执行"></a>AsyncTask的启动执行</h4><p>启动一个任务，注意每个AsyncTask只能执行一次，否则会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasExecuted &amp;&amp; mImageDownloadTask.getStatus() != AsyncTask.Status.RUNNING) &#123;</span><br><span class="line">                mImageDownloadTask.execute(IMAGE_URLS);</span><br><span class="line">                hasExecuted = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"下载已完成，且每个Task只能执行一次"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/page/3/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    
    
      <a class="next" href="/page/5/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">AN</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>

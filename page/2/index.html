<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="请不要灰心，你也会有人妒忌"/>













  <link rel="alternative" href="/default" title="ASPOOK" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://aspook.com/page/2/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />






  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> ASPOOK </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">ASPOOK</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">ASPOOK</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/09/30/Messenger进程间通信及其原理/">Messenger进程间通信及其原理</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-09-30
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h3 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h3><p>之前分析Android消息机制的源码时，曾遇到过replyTo、IMessenger等属性字段，当时只是说这些字段用于进程间通信，并未作深入分析。今天这篇文字就来演示一下使用Messenger如何进行进程间通信并分析其源码实现。</p>
<h3 id="Messenger_u8FDB_u7A0B_u95F4_u901A_u4FE1_u7684_u6D41_u7A0B"><a href="#Messenger_u8FDB_u7A0B_u95F4_u901A_u4FE1_u7684_u6D41_u7A0B" class="headerlink" title="Messenger进程间通信的流程"></a>Messenger进程间通信的流程</h3><p>Messenger顾名思义，即信使，那么它的作用就是满足不同进程两边的通信需要了。通常我们会写AIDL来实现进程间通信，其实简单的IPC可以用Messenger来实现，需要知道的是Messenger也是基于AIDL的，只不过Messenger帮我们做了封装而已，其进程间通信框架是这样的：</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/imgs/IPC%20with%20Messenger.png" alt=""></p>
<p>如上图，假设两个进程分别为Client Process和Server Process，首先Server端需要将自己这边的Messenger引用传给Client，然后Client使用Server端传过来的Messenger来发消息给Server端，这样就实现了一个单向通信。同理，如果想要实现双向通信，则需要Client端也发送一个自己的Messenger到Server端，那么Server端也就可以利用该Messenger向Client发消息了。虽然Messenger是基于AIDL的，但它们最底层都是基于Binder的。</p>
<h3 id="Messenger_u8FDB_u7A0B_u95F4_u53CC_u5411_u901A_u4FE1_u793A_u4F8B"><a href="#Messenger_u8FDB_u7A0B_u95F4_u53CC_u5411_u901A_u4FE1_u793A_u4F8B" class="headerlink" title="Messenger进程间双向通信示例"></a>Messenger进程间双向通信示例</h3><h4 id="u521B_u5EFA_u4E00_u4E2AService_u6A21_u62DFServer_u8FDB_u7A0B"><a href="#u521B_u5EFA_u4E00_u4E2AService_u6A21_u62DFServer_u8FDB_u7A0B" class="headerlink" title="创建一个Service模拟Server进程"></a>创建一个Service模拟Server进程</h4><p>一般的进程间通信多是在两个App之间，但一个App中也可以有多进程，这个很常见，如应用中的推送服务一般位于单独的进程。当然我们可以把这个Service创建到另一个App中，但为了方便测试，这里只是将该Service注册为另一个进程，但还是在同一个应用中。</p>
<p>该Service的实现很简单，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WorkThread mWorkThread = <span class="keyword">new</span> WorkThread();</span><br><span class="line">    <span class="keyword">private</span> Messenger mMessenger;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        mWorkThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        mWorkThread.quit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Nullable</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMessenger.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareMessenger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mMessenger = <span class="keyword">new</span> Messenger(mWorkThread.mHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        Handler mHandler;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Looper.prepare();</span><br><span class="line">            mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">                <span class="annotation">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">                    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                        <span class="keyword">case</span> MessageConstant.CLIENT_TO_SERVER:</span><br><span class="line">                            Toast.makeText(RemoteService.<span class="keyword">this</span>, <span class="string">"Hello Server:"</span> + msg.arg1 + <span class="string">","</span> + msg.arg2, Toast.LENGTH_SHORT).show();</span><br><span class="line">                            <span class="keyword">if</span> (msg.replyTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    msg.replyTo.send(Message.obtain(<span class="keyword">null</span>, MessageConstant.SERVER_TO_CLIENT, <span class="number">0</span>, msg.arg1 + msg.arg2));</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                                    e.printStackTrace();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            prepareMessenger();</span><br><span class="line">            Looper.loop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mHandler.getLooper().quit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码虽然简单，但有几点需要注意：</p>
<ol>
<li>为什么Service中要开一个工作线程？因为Service作为四大组件之一，它是运行在主线程的，所以不能执行耗时操作，一旦进程间交互是耗时操作，那么Service所在进程就会阻塞，而Client端进程则不会阻塞。</li>
<li>该Service中创建了一个Messenger对象，并在onBind中返回了IBinder对象，这里是进程间通信的关键，在后面会详细分析。</li>
<li>该Service的子线程中创建了一个Handler，并关联给Messenger，用于进程间通信的消息处理。Handler消息处理跟我们平时用的一样，但有一点提一下，子线程是没有默认Looper的，因此需要自己创建并启动，否则子线程的Handler无法收到Message。</li>
<li>Server端收到消息后，Toast一下“hello server”并显示Cient传过来的两个整数值。如果Client端也将自己的Messenger传过来了，则向Client端回复消息，将两个整数之和返回。</li>
</ol>
<p>另外该Service在AndroidManifest.xml中的注册如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">service</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">".messenger.RemoteService"</span></span><br><span class="line">    <span class="attribute">android:enabled</span>=<span class="value">"true"</span></span><br><span class="line">    <span class="attribute">android:exported</span>=<span class="value">"true"</span></span><br><span class="line">    <span class="attribute">android:process</span>=<span class="value">":remote"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"com.aspook.remote.ACTION_BIND"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>核心一句为<code>android:process=&quot;:remote&quot;</code>，将该Service置于另一个进程之中，从而可以在同一个App中模拟进程间通信。</p>
<h4 id="u521B_u5EFA_u4E00_u4E2AActivity_u6A21_u62DFClient_u8FDB_u7A0B"><a href="#u521B_u5EFA_u4E00_u4E2AActivity_u6A21_u62DFClient_u8FDB_u7A0B" class="headerlink" title="创建一个Activity模拟Client进程"></a>创建一个Activity模拟Client进程</h4><p>该Activity默认就是该App所在进程了，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * demo for IPC by Messenger</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button btn_start;</span><br><span class="line">    <span class="keyword">private</span> Button btn_bind;</span><br><span class="line">    <span class="keyword">private</span> Button btn_send;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mBound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Messenger mRemoteMessenger = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mRemoteConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            mRemoteMessenger = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">            mBound = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">            mRemoteMessenger = <span class="keyword">null</span>;</span><br><span class="line">            mBound = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_messenger);</span><br><span class="line"></span><br><span class="line">        findViews();</span><br><span class="line">        setListeners();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        unbindService(mRemoteConnection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findViews</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        btn_start = (Button) findViewById(R.id.btn_start);</span><br><span class="line">        btn_bind = (Button) findViewById(R.id.btn_bind);</span><br><span class="line">        btn_send = (Button) findViewById(R.id.btn_send);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        btn_start.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// start Remote Service first</span></span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(MessengerActivity.<span class="keyword">this</span>, RemoteService.class);</span><br><span class="line">                startService(intent);</span><br><span class="line">                btn_start.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        btn_bind.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// bind the Remote Service, if the Remote service run in another App, you should run the App and start the service first</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bindRemoteService();</span><br><span class="line">                    btn_bind.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        btn_send.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (mBound) &#123;</span><br><span class="line">                    Handler mClientHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">                        <span class="annotation">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">                            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                                <span class="keyword">case</span> MessageConstant.SERVER_TO_CLIENT:</span><br><span class="line">                                    Toast.makeText(MessengerActivity.<span class="keyword">this</span>, <span class="string">"Hello Client:"</span> + msg.arg2, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">default</span>:</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Message msg = Message.obtain(<span class="keyword">null</span>, MessageConstant.CLIENT_TO_SERVER, <span class="number">66</span>, <span class="number">88</span>);</span><br><span class="line">                        <span class="comment">// Messenger of client sended to server is used for sending message to client</span></span><br><span class="line">                        msg.replyTo = <span class="keyword">new</span> Messenger(mClientHandler);</span><br><span class="line">                        mRemoteMessenger.send(msg);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Toast.makeText(MessengerActivity.<span class="keyword">this</span>, <span class="string">"Service not bind"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * bind service</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindRemoteService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Method one</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.aspook.remote.ACTION_BIND"</span>);<span class="comment">// 5.0+ need explicit intent</span></span><br><span class="line">        intent.setPackage(<span class="string">"com.aspook.androidnotes"</span>); <span class="comment">// the package name of Remote Service</span></span><br><span class="line">        bindService(intent, mRemoteConnection, BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码逻辑也很简单，界面有3个按钮，操作如下：</p>
<ol>
<li>先启动Server端的Service，暂且叫做启动远程Service</li>
<li>绑定远程Service</li>
<li>Client向Servcie端发送消息，并接收返回的消息</li>
</ol>
<p>需要注意的有如下几点：</p>
<ol>
<li>绑定远程Service后，Client端才拿到了Server端的Messenger引用。</li>
<li>Client端的Messenger需要关联自己的Handler，用来处理从Server端收到的消息。这里也需要注意，理论上如果Server端与Client端交互也是耗时的话，也需要开子线程，这个例子中由于只是显示下消息，直接放在UI线程了。</li>
<li>如果需要双向通信，Client端需要通过Message的replyTo参数将自己的Messenger发到Server端。</li>
<li>Android 5.0+要求绑定Service时必须使用显式Intent，可以通过设置包名的方式来解决，注意我是在同一个App中开的两个进程，因此包名相同，但如果远程Service位于另一个App，则应该填写其所在App的包名。</li>
<li>Client端收到回复消息后，Toast“Hello client”及两个整数之和。</li>
</ol>
<h4 id="u793A_u4F8B_u6548_u679C_u6F14_u793A"><a href="#u793A_u4F8B_u6548_u679C_u6F14_u793A" class="headerlink" title="示例效果演示"></a>示例效果演示</h4><p>以上示例的进程间通信效果演示如下：</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/imgs/Messenger%20IPC.gif" alt=""></p>
<h3 id="Messenger_u8FDB_u7A0B_u95F4_u901A_u4FE1_u539F_u7406_u5206_u6790"><a href="#Messenger_u8FDB_u7A0B_u95F4_u901A_u4FE1_u539F_u7406_u5206_u6790" class="headerlink" title="Messenger进程间通信原理分析"></a>Messenger进程间通信原理分析</h3><p>关于Service的启动、绑定不必多说，先从Client端通过绑定远程Service获取Server端的Messenger入手，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ServiceConnection mRemoteConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">        mRemoteMessenger = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">        mBound = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">        mRemoteMessenger = <span class="keyword">null</span>;</span><br><span class="line">        mBound = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接着来看<code>mRemoteMessenger = new Messenger(service);</code>的源码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Create a Messenger from a raw IBinder, which had previously been</span><br><span class="line"> * retrieved with &#123;<span class="doctag">@link</span> #getBinder&#125;.</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> target The IBinder this Messenger should communicate with.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(IBinder target)</span> </span>&#123;</span><br><span class="line">    mTarget = IMessenger.Stub.asInterface(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到该构造方法的参数IBinder，就是远程Service中onBind返回的，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Nullable</span></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMessenger.getBinder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看这一句代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mTarget = IMessenger.Stub.asInterface(target);</span><br></pre></td></tr></table></figure>
<p>mTarget是IMessenger对象，看起来越来越像AIDL的写法了，其实不能说像，本来就是AIDL。于是猜想源码必定中有一个名为IMessenger.aidl的文件，它应该定义了发送消息的相关接口。果然在源码目录 “/<a href="http://androidxref.com/7.0.0_r1/xref/frameworks/" target="_blank" rel="external">frameworks</a>/<a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/" target="_blank" rel="external">base</a>/<a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/core/" target="_blank" rel="external">core</a>/<a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/core/java/" target="_blank" rel="external">java</a>/<a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/core/java/android/" target="_blank" rel="external">android</a>/<a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/core/java/android/os/" target="_blank" rel="external">os</a>/”下找到了IMessenger.aidl文件，其内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> android.os;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">oneway <span class="class"><span class="keyword">interface</span> <span class="title">IMessenger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(in Message msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此可知Messenger只是帮我们省去了写AIDL的工作而已，底层还是AIDL。</p>
<p>再来看Messenger是如何发送消息的，即Messenger的send方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Send a Message to this Messenger's Handler.</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> message The Message to send.  Usually retrieved through</span><br><span class="line"> * &#123;<span class="doctag">@link</span> Message#obtain() Message.obtain()&#125;.</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@throws</span> RemoteException Throws DeadObjectException if the target</span><br><span class="line"> * Handler no longer exists.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    mTarget.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过注释可知，Messenger会将消息发送到其关联的Handler，且Handler不存在时会报异常，这就是我们无论是创建客户端还是服务端Messenger时都为其创建了一个Handler的原因。</p>
<p>另外上述示例中为了简便，只是在进程间传递了基本类型的值，其实类似单进程的消息机制，也可以传递Bundle数据，但注意需要序列化，具体说明可参考Message源码的基本字段支撑。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/09/24/Android消息机制源码解析（四）——消息队列MessageQueue/">Android消息机制源码解析（四）——消息队列MessageQueue</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-09-24
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>MessageQueue是Android消息机制系列文章的最后一个小节，MessageQueue的主要作用是按一定规则维护一个消息队列，并能够添加消息、取出消息、移除消息等。</p>
<h3 id="MessageQueue_u5B9A_u4E49_u53CA_u4E3B_u8981_u5C5E_u6027_u5B57_u6BB5"><a href="#MessageQueue_u5B9A_u4E49_u53CA_u4E3B_u8981_u5C5E_u6027_u5B57_u6BB5" class="headerlink" title="MessageQueue定义及主要属性字段"></a>MessageQueue定义及主要属性字段</h3><p>来看下MessageQueue是怎样定义的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是一些重要的属性字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// True if the message queue can be quit.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mQuitAllowed;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> mPtr; <span class="comment">// used by native code</span></span><br><span class="line">Message mMessages;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class="keyword">new</span> ArrayList&lt;IdleHandler&gt;();</span><br><span class="line"><span class="keyword">private</span> IdleHandler[] mPendingIdleHandlers;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mQuitting;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Indicates whether next() is blocked waiting in pollOnce() with a non-zero timeout.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mBlocked;</span><br></pre></td></tr></table></figure>
<p>mQuitAllowed注释已经很清楚了，这个值实际上是在Looper构造函数中传过来的；mPtr注释也说明是在native代码里使用的，后面会详细分析。mMessage可以理解为消息队列的头部；mIdelHandlers存储了一些闲置的Handler；mPendingIdelHandlers是一个数组对象；mQuitting用来表示该队列是否退出；mBlocked布尔值表示next()方法是否阻塞了。</p>
<h3 id="MessageQueue_u7684Native_u65B9_u6CD5"><a href="#MessageQueue_u7684Native_u65B9_u6CD5" class="headerlink" title="MessageQueue的Native方法"></a>MessageQueue的Native方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeDestroy</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativePollOnce</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> timeoutMillis)</span></span>; <span class="comment">/*non-static for callbacks*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeWake</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">nativeIsIdling</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>从方法名称上可以理解该方法的作用，以nativeInit()为例，它被调用是在MessageQueue构造函数中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是否有点眼熟，MessageQueue的初始化就是在Looper的构造函数中调用的。nativeInit()是在C++层实现的，具体代码如下：</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/imgs/nativeInit" alt=""></p>
<p>从native代码可以看到MessageQueue名义上为消息队列，但真正的队列是在native层创建的，最后会将nativeMessageQueue转成mPtr，在需要获取nativeMessageQueue的时候再将mPtr转回去。其他几个本地方法知道其作用即可，这里不再解释源码。</p>
<h3 id="u6D88_u606F_u7684_u5165_u961F_u903B_u8F91"><a href="#u6D88_u606F_u7684_u5165_u961F_u903B_u8F91" class="headerlink" title="消息的入队逻辑"></a>消息的入队逻辑</h3><p>在分析Handler的时候，知道发送一条消息后，实际上是把消息添加到消息队列中，它的具体实现逻辑是在MessageQueue中，下面就来看一下是怎么做的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            Log.w(<span class="string">"MessageQueue"</span>, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较容易理解，首先判断该消息有无Handler以及是否正在使用，之后如果消息队列未退出的话，则进行入队操作。首先会将消息标记为正在使用，然后给when字段赋值，如果原队列为空，或者要插入消息的when字段为0或小于队列头部消息的when，则将消息插入到队列头部，否则按照when的大小插入到消息队列的合适位置。消息入队之后，如果有需要，会唤醒队列，调用的是本地方法nativeWake(mPtr)。</p>
<h3 id="u6D88_u606F_u7684_u51FA_u961F_u903B_u8F91"><a href="#u6D88_u606F_u7684_u51FA_u961F_u903B_u8F91" class="headerlink" title="消息的出队逻辑"></a>消息的出队逻辑</h3><p>再来看Looper是怎样从消息队列取出消息的，即消息的出队逻辑next()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                do &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(<span class="string">"MessageQueue"</span>, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(<span class="string">"MessageQueue"</span>, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码虽然很长，但我们把握主要逻辑即可，主要是for循环里的逻辑，其他为辅助代码。这个for循环也是一个无限循环，之前讲Looper的loop()时说到过next()可能会阻塞，就是这里了。消息出队的实现在for循环中的同步代码块中，如果取到消息则返回给Looper处理，如果没有消息则阻塞在这里，还有一种情况会造成等待，即消息的执行时间还未到，此时会重新设置下一次轮训的时间，这是根据when字段判断的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u4ECE_u6D88_u606F_u961F_u5217_u5220_u9664_u6D88_u606F"><a href="#u4ECE_u6D88_u606F_u961F_u5217_u5220_u9664_u6D88_u606F" class="headerlink" title="从消息队列删除消息"></a>从消息队列删除消息</h3><p>MessageQueue提供了remove系列方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(Handler h, <span class="keyword">int</span> what, Object object)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(Handler h, Runnable r, Object object)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title">removeCallbacksAndMessages</span><span class="params">(Handler h, Object object)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeAllMessagesLocked</span><span class="params">()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeAllFutureMessagesLocked</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>前三个是根据参数来从消息队列移除消息，removeAllMessagesLocked()为移除所有消息，remvoeAllFutureMessagesLocked()则是仅移除那些还未执行的消息，此刻是否想起了上一节Looper的quit()和quitSafely()呢？</p>
<h3 id="u6D88_u606F_u961F_u5217_u7684_u9000_u51FA"><a href="#u6D88_u606F_u961F_u5217_u7684_u9000_u51FA" class="headerlink" title="消息队列的退出"></a>消息队列的退出</h3><p>上一节说到Looper的退出实际上是调用了MessageQueue的quit方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">(<span class="keyword">boolean</span> safe)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mQuitAllowed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Main thread not allowed to quit."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mQuitting = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (safe) &#123;</span><br><span class="line">            removeAllFutureMessagesLocked();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            removeAllMessagesLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting was previously false.</span></span><br><span class="line">        nativeWake(mPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，注意会将mQuitting变量置为true。</p>
<p>MessageQueue主要的内容就是以上这些，分析源码应当宏观把握，了解主要逻辑框架而不必拘泥于代码的细节实现，否则可能会陷入理解代码的汪洋大海，苦不堪言且效果不佳。</p>
<p>到此Android消息机制相关的四节内容都讲完了，相信大家已经从原理上对Android消息机制有了比较深刻的了解，这几节内容有很多交叉和依赖，希望能够融会贯通，灵活运用，写出更好的应用。</p>
<p>本文最初于2015年12月15日发布于个人<a href="http://blog.csdn.net/ahence/article/details/50312353" target="_blank" rel="external">CSDN博客</a>。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/09/24/Android消息机制源码解析（三）——消息循环器Looper/">Android消息机制源码解析（三）——消息循环器Looper</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-09-24
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>本节来分析Looper，Looper可以理解为一个消息循环器，不断从消息队列中取出消息，然后交给Handler处理。如果一个线程中有多个Handler，则会根据Message的target属性来将消息处理任务分发到特定的Handler。如果消息队列中没有消息了，那么Looper就会等待，直到有消息进来，下面看一下Looper的源码实现。</p>
<h3 id="Looper_u5B9A_u4E49_u4E0E_u4E3B_u8981_u5B57_u6BB5"><a href="#Looper_u5B9A_u4E49_u4E0E_u4E3B_u8981_u5B57_u6BB5" class="headerlink" title="Looper定义与主要字段"></a>Looper定义与主要字段</h3><p>Looper类的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到Looper类被定义为final类型，则此类不可以被继承。</p>
<p>Looper主要属性字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sThreadLocal.get() will return null unless you've called prepare().</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  <span class="comment">// guarded by Looper.class</span></span><br><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line"><span class="keyword">final</span> Thread mThread;</span><br></pre></td></tr></table></figure>
<p>这里涉及到一个叫ThreadLocal的东西，ThreadLocal的作用简单说就是可以在多个线程中被共享，但是在ThreadLocal中却可以保存各个线程的值，在不同线程中访问时，返回的也是不同线程保存的值，其实现源码也比较简单，有兴趣的同学可以自己看一下。ThreadLocal很有用，在Looper中，sThreadLocal用来保存每个线程的Looper对象，同时也可以从中取出各个线程的Looper。sMainLooper表示主线程的Looper对象；mQueue表示消息队列；mThread表示当前线程。</p>
<h3 id="Looper_u521D_u59CB_u5316"><a href="#Looper_u521D_u59CB_u5316" class="headerlink" title="Looper初始化"></a>Looper初始化</h3><p>接下来分析如何初始化一个Looper，答案是通过prepare()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/** Initialize the current thread as a looper.</span><br><span class="line">  * This gives you a chance to create handlers that then reference</span><br><span class="line">  * this looper, before actually starting the loop. Be sure to call</span><br><span class="line">  * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</span><br><span class="line">  * &#123;<span class="doctag">@link</span> #quit()&#125;.</span><br><span class="line">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上述代码中的异常提示“Only one Looper may be created per thread”，它告诉我们，每个线程只能有一个Looper，通过sThreadLocal的set()和get()可以设置与获取到当前线程的Looper。再看下Looper的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中布尔型的参数表示该Looper是否可以退出，此值会传到MessageQueue中，后面一节会讲到。上述代码实际上给Looper绑定了一个MessageQueue和Thread，既然一个线程只有一个Looper，也就只有一个MessageQueue。</p>
<h3 id="u4E3B_u7EBF_u7A0B_u7684Looper"><a href="#u4E3B_u7EBF_u7A0B_u7684Looper" class="headerlink" title="主线程的Looper"></a>主线程的Looper</h3><p>之前提到在主线程创建Handler时不需要手动创建Looper，那么主线程的Looper又是如何被创建的呢？先看如下的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Initialize the current thread as a looper, marking it as an</span><br><span class="line"> * application's main looper. The main looper for your application</span><br><span class="line"> * is created by the Android environment, so you should never need</span><br><span class="line"> * to call this function yourself.  See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns the application's main looper, which lives in the main thread of the application.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">getMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> sMainLooper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>prepareMainLooper()就是为主线程创建Looper，此函数就是在主线程ActivityThread中被调用的；getMainLooper()则可以返回主线程的Looper对象。</p>
<h3 id="Looper_u63D0_u4F9B_u7684_u76F8_u5173_u65B9_u6CD5"><a href="#Looper_u63D0_u4F9B_u7684_u76F8_u5173_u65B9_u6CD5" class="headerlink" title="Looper提供的相关方法"></a>Looper提供的相关方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="annotation">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法返回当前线程的Looper。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="annotation">@NonNull</span> <span class="function">MessageQueue <span class="title">myQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> myLooper().mQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法返回当前线程的Looper对应的消息队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCurrentThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread() == mThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法用来判断当前线程是否为Looper所在的线程。</p>
<h3 id="Looper_u8FD0_u884C_u539F_u7406"><a href="#Looper_u8FD0_u884C_u539F_u7406" class="headerlink" title="Looper运行原理"></a>Looper运行原理</h3><p>通过以上源码分析，大家已经了解如何创建一个Looper了，那么Looper创建好之后，是怎么运转的呢，它是怎样从消息队列不断获取消息的呢？下面请出Looper最重要的loop()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Run the message queue in this thread. Be sure to call</span><br><span class="line"> * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                    msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">        <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                    + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                    + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                    + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                    + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先拿到当前线程的Looper，再得到该Looper对应的MessageQueue；接下来Binder相关的两句是关于进程间通信的，不影响我们理解。最重要的逻辑在for循环里，这是一个无限循环，首先从消息队列取消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Message msg = queue.next(); <span class="comment">// might block</span></span><br></pre></td></tr></table></figure>
<p>注意后边的注释语句，next()的具体实现会在下一节MessageQueue中介绍，这个方法可能会阻塞，理解这一点非常重要，阻塞说明即会等待，当有消息时就会被唤醒，而等待时并不会消耗太多资源，所以并不会造成卡死。接下来的if语句说明跳出循环的唯一条件是msg为null，接下来会提到的Looper的quit()方法，其实质就是调用MessageQueue的quit()，让next()返回null，这样Looper就会跳出循环了。如果Looper从消息队列中获取的消息不为null，则分发给此消息对应的Handler处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg.target.dispatchMessage(msg);</span><br></pre></td></tr></table></figure>
<p>Handler的dispatchMessage(Message msg)就是在这个地方调用的。最后一行代码是Message对象的回收。需要提醒一下，创建Looper之后，必须调用其loop()，才能将其启动起来。</p>
<h3 id="u9000_u51FALooper"><a href="#u9000_u51FALooper" class="headerlink" title="退出Looper"></a>退出Looper</h3><p>最后是Looper的退出方法，有两个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mQueue.quit(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mQueue.quit(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到都是调用了MessageQueue的退出方法，它们的区别时，直接退出则loop()不再处理任何消息马上终止，而安全退出时loop()会执行完目前已经在处理的消息，之后才终止。</p>
<p>Looper的主要源码已经分析完了，需要明白的是一个线程只有一个Looper、一个MessageQueue，但可以有多个Handler。最后一节《Android消息机制源码解析（四）——消息队列MessageQueue》将分析Android消息机制的最后一部分内容。</p>
<p>本文最初于2015年12月14日发布于个人<a href="http://blog.csdn.net/ahence/article/details/50300021" target="_blank" rel="external">CSDN博客</a>。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/09/24/Android消息机制源码解析（二）——消息执行者Handler/">Android消息机制源码解析（二）——消息执行者Handler</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-09-24
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>这一节来分析Handler的源码实现，Handler从字面理解就是处理程序、处理器的意思，在Android消息机制中它扮演着执行者的角色，消息的发送、接收、处理都是由Handler来完成的，它也是跟开发者打交道最多的，因此我们更有必要深入了解Handler的实现原理。</p>
<h3 id="Handler_u5B9A_u4E49_u53CA_u4E3B_u8981_u5B57_u6BB5"><a href="#Handler_u5B9A_u4E49_u53CA_u4E3B_u8981_u5B57_u6BB5" class="headerlink" title="Handler定义及主要字段"></a>Handler定义及主要字段</h3><p>首先是Handler类的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Handler有以下几个主要属性字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line"><span class="keyword">final</span> Looper mLooper;</span><br><span class="line"><span class="keyword">final</span> Callback mCallback;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> mAsynchronous;</span><br><span class="line">IMessenger mMessenger;</span><br></pre></td></tr></table></figure>
<p>mQueue是一个MessageQueue对象，第一节讲Message的时候提到过，发送的消息会放到一个消息队列里面，就是它了，第四节会详细讲解MessageQueue；mLooper是一个Looper对象，可以理解为一个循环器，它不断从消息队列中将消息取出来，交给Handler处理，第三节也会详细分析其实现原理，暂时理解它的作用就行；mCallBack是Handler中定义的一个CallBack接口，下文会讲起具体作用；mAsynchronous表示是否为异步处理的布尔值，一般在调用Handler的构造函数时会给其赋值，默认都为false，如果设置为true，其本质会调用第一节中Message的setAsynchronous(boolean)方法，将消息设为异步消息；mMessenger是用来进程间通信的，本文暂不作过多解释。</p>
<h3 id="Handler_u7684_u6784_u9020_u51FD_u6570"><a href="#Handler_u7684_u6784_u9020_u51FD_u6570" class="headerlink" title="Handler的构造函数"></a>Handler的构造函数</h3><p>Handler源码中共提供了7个无参或有参的构造函数，罗列如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span><br><span class="line"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="keyword">boolean</span> async)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span></span></span><br></pre></td></tr></table></figure>
<p>上述几个构造函数，你可以根据需求使用任何一个来创建Handler实例，需要注意的是一个Handler必须要对应一个Looper。一个线程中只能有一个Looper，但可以有多个Handler，虽然有的构造函数没有Looper参数，那是因为在主线程中使用Handler时不需要开发者自己创建Looper，ActivityThread已经为我们创建好了，具体源码在ActivityThread的main()方法中，有兴趣的可以去验证一下。如果在子线程中创建Handler对象，则必须要提供Looper对象，至于Looper怎样创建，在下一节会详细说明。其他参数如CallBack及异步标识async就很好理解了。</p>
<h3 id="Handler_u83B7_u53D6Message_u7684_u65B9_u6CD5"><a href="#Handler_u83B7_u53D6Message_u7684_u65B9_u6CD5" class="headerlink" title="Handler获取Message的方法"></a>Handler获取Message的方法</h3><p>Handler提供了obtainMessage()系列方法用来返回一个Message对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">(<span class="keyword">int</span> what)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, Object obj)</span></span></span><br></pre></td></tr></table></figure>
<p>这一系列方法内部实质上是调用Message的obtain()系列方法，从消息池中获取一个Message，在第一节也提到过。</p>
<h3 id="Handler_u53D1_u9001_u6D88_u606F"><a href="#Handler_u53D1_u9001_u6D88_u606F" class="headerlink" title="Handler发送消息"></a>Handler发送消息</h3><p>下面是最重要的发送消息环节了，可以利用Handler发送Runnable或Message，且各自对应一系列同名方法，如发送Runnable的方法主要有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span><span class="params">(Runnable r, <span class="keyword">long</span> uptimeMillis)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span><span class="params">(Runnable r, Object token, <span class="keyword">long</span> uptimeMillis)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(Runnable r, <span class="keyword">long</span> delayMillis)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtFrontOfQueue</span><span class="params">(Runnable r)</span></span></span><br></pre></td></tr></table></figure>
<p>从上述函数名可以很好理解其含义，postAtTime()表示在某个特定时间点发送；postDelayed()表示延迟多久发送消息；postAtFrontOfQueue()表示将消息插入到队列头部。</p>
<p>发送一个Runnable时，实质上会将Runnable转换成一个Message对象。还记得第一节分析Message时的Runnable callback字段吗？正是通过构造一个Message对象，将所发送的Runnable赋值给了Message的callback字段，详细代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送Message的一系列方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessage</span><span class="params">(<span class="keyword">int</span> what)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageAtTime</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> uptimeMillis)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtFrontOfQueue</span><span class="params">(Message msg)</span></span></span><br></pre></td></tr></table></figure>
<p>前边几个方法最终会调用到sendMessageAtTime()，来看一下其具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到最终调用enqueueMessage(queue, msg, uptimeMillis)方法，顾名思义，就是将该消息添加到队列中。来看下这个方法的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果构造Handler时，设置了async参数为true，则会调用消息的msg.setAsynchronous(true)方法，最终的入队操作实际上是在MessageQueue中实现的，第四节会详细分析。</p>
<p>postAtFrontOfQueue(Runnable r)最终会调用sendMessageAtFrontOfQueue(Message msg)，内部也会调用enqueueMessage(queue, msg, uptimeMillis)方法进行入队操作，只不过uptimeMillis值为0，这样就可以将消息放到队列头部，顺便提一下，这里的uptimeMillis对应着Message里的when字段。</p>
<h3 id="Handler_u5220_u9664_u6D88_u606F"><a href="#Handler_u5220_u9664_u6D88_u606F" class="headerlink" title="Handler删除消息"></a>Handler删除消息</h3><p>既然Handler可以发送Runnable和Message，因此它还提供了相关的删除方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeCallbacks</span><span class="params">(Runnable r)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeCallbacks</span><span class="params">(Runnable r, Object token)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(<span class="keyword">int</span> what)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(<span class="keyword">int</span> what, Object object)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeCallbacksAndMessages</span><span class="params">(Object token)</span></span></span><br></pre></td></tr></table></figure>
<p>其内部实现都是一样的，都是调用MessageQueue的相关删除方法，将消息从队列中移除，详细内容待第四节分析。</p>
<h3 id="u6D88_u606F_u63A5_u6536_u4E0E_u5904_u7406"><a href="#u6D88_u606F_u63A5_u6536_u4E0E_u5904_u7406" class="headerlink" title="消息接收与处理"></a>消息接收与处理</h3><p>消息发送和删除已经分析完了，接下来就是消息接收和处理了，先看相关源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Callback interface you can use when instantiating a Handler to avoid</span><br><span class="line"> * having to implement your own subclass of Handler.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> msg A &#123;<span class="doctag">@link</span> android.os.Message Message&#125; object</span><br><span class="line"> * <span class="doctag">@return</span> True if no further handling is desired</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Subclasses must implement this to receive messages.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Handle system messages here.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个是Callback接口的定义，看注释可以知道，在某些情况下如果不想实现Handler的子类，则可以通过实现该接口来处理收到的消息。</p>
<p>第二个是handleMessage(Message msg)，这个方法是个空方法，需要在子类实现具体的处理逻辑，我们一般多采用这种方法，创建一个Handler子类，通过重写handleMessage(Message msg)方法来实现自己的消息处理逻辑，当然上述两种方法都是可以的，看自己的需要了。</p>
<p>第三个是dispatchMessage(Message msg)了，也就是消息处理的逻辑。它的执行过程为，如果该消息有callback（也就是之前提到的Runnable对象），则响应callback，具体实现为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来判断是否实现了自定义的Callback接口，如果实现了则响应该接口回调，如果没有，则响应子类的handleMessage(msg)方法。</p>
<p>需要特别注意的是handleMessage(Message msg)是在Looper中被调用的，前面简单介绍过，Looper可以理解为消息循环器，作用是不断从MessageQueue中取出消息，交给Handler处理，就是调用了这个方法。因为一个线程只能有一个Looper，如果该Handler是在主线程创建的，那么Looper也是运行在主线程的，同样handleMessage(Message msg)也就运行在主线程了，我们常用的使用Handler消息机制更新UI就是这个原理。</p>
<p>Handler的主要内容就是这些，比较容易理解，下一节会继续分析Looper，请关注《Android消息机制源码解析（三）——消息循环器Looper》。</p>
<p>本文最初于2015年12月14日发布于个人<a href="http://blog.csdn.net/ahence/article/details/50293531" target="_blank" rel="external">CSDN博客</a>。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/09/24/Android消息机制源码解析（一）——消息载体Message/">Android消息机制源码解析（一）——消息载体Message</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-09-24
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>说到Android的消息机制，大家再熟悉不过了，几乎每个逻辑界面中都会涉及到，Activity的生命周期回调也是通过系统消息机制完成的，可见消息机制在Android中的重要性。在应用层，一般我们都是使用Handler来发送、处理消息，从工作线程切换到主线程来更新UI。往往开发者只跟Handler、Message打交道就能满足需求了，但它们背后的实现原理是怎样的呢？为了加深理解，深入学习Android设计理念，同时也希望给初学者带来一些帮助，下面会从源码角度来分析Android的消息机制，鉴于篇幅原因，大致分为如下四个小节：</p>
<ol>
<li>Andorid消息载体Message</li>
<li>Android消息执行者Handler</li>
<li>Android消息循环器Looper</li>
<li>Android消息队列MessageQueue</li>
</ol>
<p>直入正题，先来看Android消息载体Message。</p>
<h3 id="Message_u5B9A_u4E49_u4E0E_u5E8F_u5217_u5316"><a href="#Message_u5B9A_u4E49_u4E0E_u5E8F_u5217_u5316" class="headerlink" title="Message定义与序列化"></a>Message定义与序列化</h3><p>大家都知道Handler发送的是消息，这里的消息对应的正是Message对象，来看一下源码中Message的定义与实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span></span>&#123;</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先可以看到Message实现了Parcelable接口，那么接下来就必然会实现序列化需要的几个方法，序列化部分代码不需要过多解释，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Message&gt; CREATOR</span><br><span class="line">        = <span class="keyword">new</span> Parcelable.Creator&lt;Message&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">createFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        msg.readFromParcel(source);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Message[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message[size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't marshal callbacks across processes."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dest.writeInt(what);</span><br><span class="line">    dest.writeInt(arg1);</span><br><span class="line">    dest.writeInt(arg2);</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Parcelable p = (Parcelable)obj;</span><br><span class="line">            dest.writeInt(<span class="number">1</span>);</span><br><span class="line">            dest.writeParcelable(p, flags);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't marshal non-Parcelable objects across processes."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dest.writeInt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dest.writeLong(when);</span><br><span class="line">    dest.writeBundle(data);</span><br><span class="line">    Messenger.writeMessengerOrNullToParcel(replyTo, dest);</span><br><span class="line">    dest.writeInt(sendingUid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">    what = source.readInt();</span><br><span class="line">    arg1 = source.readInt();</span><br><span class="line">    arg2 = source.readInt();</span><br><span class="line">    <span class="keyword">if</span> (source.readInt() != <span class="number">0</span>) &#123;</span><br><span class="line">        obj = source.readParcelable(getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    when = source.readLong();</span><br><span class="line">    data = source.readBundle();</span><br><span class="line">    replyTo = Messenger.readMessengerOrNullFromParcel(source);</span><br><span class="line">    sendingUid = source.readInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Message_u4E3B_u8981_u5C5E_u6027_u5B57_u6BB5"><a href="#Message_u4E3B_u8981_u5C5E_u6027_u5B57_u6BB5" class="headerlink" title="Message主要属性字段"></a>Message主要属性字段</h3><p>下面重量级的嘉宾开始登场了，之所以把Message称为消息的载体，是因为Message是对消息内容的一个封装，根据平时的开发经验，大家知道Message可以传递一些数据，比如整型、Bundle以及Object，那么Message为什么拥有这种能力呢？来看下Message的几个重要属性字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> what;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg1; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg2;</span><br><span class="line"><span class="keyword">public</span> Object obj;</span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">long</span> when;</span><br><span class="line"><span class="comment">/*package*/</span> Bundle data;</span><br><span class="line"><span class="comment">/*package*/</span> Handler target;</span><br><span class="line"><span class="comment">/*package*/</span> Runnable callback;</span><br></pre></td></tr></table></figure>
<p>相信大家对前边几个字段非常熟悉，what是开发者自定义的一个整型标识，作用就是接收者（接收者就是Handler了）收到消息时可以知道此消息的来源与用途；有时候一个消息仅需要简单传递一些轻量级的整数，此时arg1和arg2就可以派上用场了，从而不必使用Bundle，可以节省开销；Message还可以利用Object来传递任意数据，但在用于进程间通讯时，如object实现了Parceable则必须保证不为空；当然最常用的是通过Bundle来传递数据了，即上面第6个字段；when用来存储消息何时执行；target实际上是一个Handler,表示该消息是由谁发送的；此外Message还有一个callback字段，本质上是一个Runnable，用来支持发送Runnable类型的消息，如Handler中的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数Runnable最终被赋给消息的上述callback字段。</p>
<p>Android中的Message对象是按链表结构存储的，这样就可以利用消息池，从而减少对象的创建，提高性能，具体有如下相关字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sometimes we store linked lists of these things</span></span><br><span class="line"><span class="comment">/*package*/</span> Message next;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> gCheckRecycle = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>从字段名称很容易理解，sPool可以理解为消息链表的头部，next指向下一条消息，其中默认消息池初始值为0，最大容量为50；gCheckRecycle是一个用来辅助回收消息的辅助变量。</p>
<p>此外，Message还有如下两个字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Optional Messenger where replies to this message can be sent.  The</span><br><span class="line"> * semantics of exactly how this is used are up to the sender and</span><br><span class="line"> * receiver.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> Messenger replyTo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Optional field indicating the uid that sent the message.  This is</span><br><span class="line"> * only valid for messages posted by a &#123;<span class="doctag">@link</span> Messenger&#125;; otherwise,</span><br><span class="line"> * it will be -1.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> sendingUid = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这两个字段是用来进程间通讯的，这里就不再展开。</p>
<h3 id="Message_u5BF9_u8C61_u7684_u521B_u5EFA"><a href="#Message_u5BF9_u8C61_u7684_u521B_u5EFA" class="headerlink" title="Message对象的创建"></a>Message对象的创建</h3><p>Message的主要属性字段都介绍完了，那么如何创建一个Message呢？尽管Message提供了public的无参构造函数，但是并不建议通过构造函数创建Message对象。很多无经验的开发者往往会new一个Message，这是不可取的，应该特别注意。Message类为我们提供了obtain()及多个同名方法来从消息池中获取一个Message，这样就可以利用消息池中回收的对象，避免重新创建对象，以节省开销。来看一下obtain()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Return a new Message instance from the global pool. Allows us to</span><br><span class="line"> * avoid allocating new objects in many cases.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;</span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，sPoolSync是用来保证线程同步的，上述代码仅在消息池中没有可用对象时才通过无参构造方法创建对象，否则就从消息池中返回一个Message对象。obtain()其他同名方法原理也一样，只不过会将参数赋值给获取到的Message各个字段（最初提到的what、arg1、arg2、obj、target等属性字段），如带Handler参数的obtain()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h)</span> </span>&#123;</span><br><span class="line">    Message m = obtain();</span><br><span class="line">    m.target = h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如带有Handler、what、obj三个参数的obtain()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what, Object obj)</span> </span>&#123;</span><br><span class="line">    Message m = obtain();</span><br><span class="line">    m.target = h;</span><br><span class="line">    m.what = what;</span><br><span class="line">    m.obj = obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他类似，就不再一一列举。</p>
<p>分析到这里，事先提一下，除了使用Message类的obtain()相关方法获取消息对象之外，也可以使用Handler类提供的obtainMessage()系列方法，其内部实现则是调用了Message的obtain()系列方法，等第二节讲到Handler时会详细说明。</p>
<h3 id="Message_u7684_u76F8_u5173_u65B9_u6CD5"><a href="#Message_u7684_u76F8_u5173_u65B9_u6CD5" class="headerlink" title="Message的相关方法"></a>Message的相关方法</h3><p>Message类提供了几个set方法，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Handler target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果obtain()方法中没有传递Handler参数，则可以使用上述方法设置，明确该消息由谁来发送和接收。指定消息的Handler后，还有一个sendToTarget():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Sends this Message to the Handler specified by &#123;<span class="doctag">@link</span> #getTarget&#125;.</span><br><span class="line"> * Throws a null pointer exception if this field has not been set.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendToTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    target.sendMessage(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释已经写的很清楚了，如果一个消息未指定Handler，则调用此方法会报空指针。我们在开发时需要发送一个消息，往往会这样写：</p>
<p><code>Message message = Message.obtain(mHandler, what, obj);</code></p>
<p><code>message.sendToTarget();</code></p>
<p>sendToTarget()实际上会调用Handler中发送消息的方法，最终会将消息添加到一个队列中，当然发送消息也可以直接使用Handler的sendMessage系列方法，这些内容在后面会详细介绍。</p>
<p>如果需要使用Bundle来发送消息，那么当封装好Bundle后，可以利用以下方法将Bundle保存到消息中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Bundle data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样Message类还提供了一系列获取对象属性的方法，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Return the targeted delivery time of this message, in milliseconds.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getWhen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> when;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法返回消息的执行时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Handler <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法返回发送、接收消息的Handler对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Runnable <span class="title">getCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法返回Runnable对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bundle <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> Bundle();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法返回一个Bundle,如果为空则会创建一个新的对象返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bundle <span class="title">peekData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法则不管Bundle是否为空，直接返回。</p>
<h3 id="Message_u5BF9_u8C61_u7684_u56DE_u6536"><a href="#Message_u5BF9_u8C61_u7684_u56DE_u6536" class="headerlink" title="Message对象的回收"></a>Message对象的回收</h3><p>来再看一下消息回收的源码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Recycles a Message that may be in-use.</span><br><span class="line"> * Used internally by the MessageQueue and Looper when disposing of queued Messages.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">    <span class="comment">// Clear out all other details.</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = -<span class="number">1</span>;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较容易理解，就是消息的各个属性置为初始值，同时消息池数量在未超限时加1。</p>
<h3 id="u5F02_u6B65_u6D88_u606F"><a href="#u5F02_u6B65_u6D88_u606F" class="headerlink" title="异步消息"></a>异步消息</h3><p>最后简单说一下异步消息，一般情况下发送的消息都是同步的，在某些情况下可能会用到异步消息，比如View的刷新。异步消息顾名思义，它不会受同步消息的顺序限制，因此可能引发不可预知的情况，所以建议慎用。如果需要将某个消息设置为异步执行，可调用如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsynchronous</span><span class="params">(<span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        flags |= FLAG_ASYNCHRONOUS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flags &amp;= ~FLAG_ASYNCHRONOUS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中flag是一个int型的标识字段，如果想判断某个消息是否为异步消息，调用如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAsynchronous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (flags &amp; FLAG_ASYNCHRONOUS) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Message源码比较简单，逻辑也很清楚，总结一下，主要是Message的一些重要的属性字段、Message的链表特性以及如何利用obtain()系列方法高效创建一个Message对象等。Android消息的载体Message我们已经彻底搞清楚了，那么这些构造好的消息又是如何发送出去的呢，它们又是如何被接收和处理的？请看《Android消息机制源码解析（二）——消息执行者Handler》。</p>
<p>本文最初于2015年12月13日发布于个人<a href="http://blog.csdn.net/ahence/article/details/50287817" target="_blank" rel="external">CSDN博客</a>。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/09/08/Java内存分配策略——《深入理解Java虚拟机》笔记/">Java内存分配策略——《深入理解Java虚拟机》笔记</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-09-08
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Java/">Java</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h3 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h3><p>Java自动内存管理包含两方面的含义：给对象分配内存以及回收分配给对象的内存。</p>
<p>Java对象的内存分配主要是指在堆上分配（也有经过JIT编译后被拆散为标量类型并间接地在栈上分配的情况），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，则将按线程优先在TLAB（Thread Local Allocation Buffer）上分配。少数情况下也可能会直接分配在老年代中，分配的规则并非百分百固定，其细节取决于JVM使用的是哪一种垃圾收集器组合以及虚拟机中内存相关参数的设置。</p>
<h3 id="u5E38_u89C1_u5185_u5B58_u5206_u914D_u7B56_u7565"><a href="#u5E38_u89C1_u5185_u5B58_u5206_u914D_u7B56_u7565" class="headerlink" title="常见内存分配策略"></a>常见内存分配策略</h3><h4 id="u5BF9_u8C61_u4F18_u5148_u5728Eden_u533A_u5206_u914D"><a href="#u5BF9_u8C61_u4F18_u5148_u5728Eden_u533A_u5206_u914D" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h4><p>多数情况下，对象在新生代Eden区中分配，当Eden区没有足够的空间时，虚拟机将发起一次Minor GC。Minor GC即新生代GC，指发生在新生代的垃圾收集动作，因为Java对象大都是朝生夕死，因此Minor GC会比较频繁且速度也较快。</p>
<p>相应地，发生在老年代的GC称为Full GC或Major GC，此种GC一般比Minor GC慢10倍以上。</p>
<h4 id="u5927_u5BF9_u8C61_u76F4_u63A5_u8FDB_u5165_u8001_u5E74_u4EE3"><a href="#u5927_u5BF9_u8C61_u76F4_u63A5_u8FDB_u5165_u8001_u5E74_u4EE3" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>所谓大对象，是指需要大量连续内存空间的Java对象，典型的大对象就是那种很长的字符串或数组。大对象对虚拟机的内存分配来说是一个坏消息，尤其是那些生命周期非常短的大对象，我们在写程序时一定要注意避免声明此类大对象。经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来分配给这些对象。</p>
<p>虚拟机提供了-XX:PretenureSizeThreshold参数，当大于此参数值的对象直接在老年代进行分配，这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。</p>
<h4 id="u957F_u671F_u5B58_u6D3B_u5BF9_u8C61_u8FDB_u5165_u8001_u5E74_u4EE3"><a href="#u957F_u671F_u5B58_u6D3B_u5BF9_u8C61_u8FDB_u5165_u8001_u5E74_u4EE3" class="headerlink" title="长期存活对象进入老年代"></a>长期存活对象进入老年代</h4><p>既然虚拟机采用分代收集的思想来管理内存，那就需要知道哪些对象应该放在新生代，哪些对象应该放在老年代，因此虚拟机给每个对象定义了一个年龄计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间，同时将对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，对象年龄就加1，当对象年龄到达15（默认为15）后就被移到老年代。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。</p>
<h4 id="u5BF9_u8C61_u5E74_u9F84_u52A8_u6001_u5224_u5B9A"><a href="#u5BF9_u8C61_u5E74_u9F84_u52A8_u6001_u5224_u5B9A" class="headerlink" title="对象年龄动态判定"></a>对象年龄动态判定</h4><p>为了更好地适应不同应用程序的内存情况，虚拟机并非永远要求对象的年龄必须达到了MaxTenuringThreshold的值才能被移动到老年代，如果在Survivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而无需等到达到MaxTenuringThreshold值。</p>
<h4 id="u7A7A_u95F4_u5206_u914D_u62C5_u4FDD"><a href="#u7A7A_u95F4_u5206_u914D_u62C5_u4FDD" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，则此次Minor GC是安全的；如果小于，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。</p>
<p>上面提到了Minor GC依然会有风险，是因为新生代采用复制收集算法，假如大量对象在Minor GC后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间是比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代。老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象，但一共有多少对象在内存回收后存活下来是不可预知的，因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间。</p>
<p>取平均值仍然是一种概率性的事件，如果某次Minor GC后存活对象陡增，远高于平均值的话，必然导致担保失败，如果出现了分配担保失败，就只能在失败后重新发起一次Full GC。虽然存在发生这种情况的概率，但大部分时候都是能够成功分配担保的，这样就避免了过于频繁执行Full GC。</p>
<p>在JDK 6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保，规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升到老年代对象大小的平均值，就会进行Minor GC，否则就执行Full GC。</p>
<p>参考文献《深入理解Java虚拟机》</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/28/垃圾收集器与常用垃圾收集算法/">垃圾收集器与常用垃圾收集算法</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-08-28
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Java/">Java</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h3 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h3><p>垃圾收集器（Garbage Collection, GC）的历史要比Java久远，且并非Java独有，GC主要完成以下三件事情：</p>
<ol>
<li>哪些内存需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ol>
<p>对于Java内存运行时区域的各个部分，程序计数器、虚拟机栈、本地方法栈3个线程私有区域是随线程而生，又随线程而灭，因此这几个区域的内存分配和回收都具备确定性，不需要考虑垃圾回收的问题。而Java堆和方法区这两个线程共享区的内存是动态分配的，因此垃圾收集器主要关注的是这部分的内存，这里也是垃圾回收的主战场。</p>
<h3 id="u5982_u4F55_u5224_u65AD_u5BF9_u8C61_u6B7B_u4EA1"><a href="#u5982_u4F55_u5224_u65AD_u5BF9_u8C61_u6B7B_u4EA1" class="headerlink" title="如何判断对象死亡"></a>如何判断对象死亡</h3><h4 id="u5F15_u7528_u8BA1_u6570_u7B97_u6CD5"><a href="#u5F15_u7528_u8BA1_u6570_u7B97_u6CD5" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>原理：给对象添加一个引用计数器，当有一个地方引用它时，计数器加1，当引用结束时，计数器减1，任何时候当引用计数为0时，则认为该对象没有被使用，可以被回收。</p>
<p>引用计数算法实现简单，效率也很高，也有很多技术中都使用该算法来管理内存。但Java虚拟机却没有使用该算法，最主要的原因它很难解决对象之间互相循环引用的问题。例如下面示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中objA与objB互相引用，如果Java虚拟机采用引用计数算法，发生GC时，objA、objB将无法被回收。测试可知，上述Java代码在GC时是可以回收内存的，因此可从侧面证明Java虚拟机并非用的引用计数算法。</p>
<h4 id="u53EF_u8FBE_u6027_u5206_u6790_u7B97_u6CD5"><a href="#u53EF_u8FBE_u6027_u5206_u6790_u7B97_u6CD5" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>其实在Java、C#等主流语言中，使用的都是可达性分析（Reachability）算法来判定对象是否存活的。该算法基本思路是通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径叫做引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，用图论原理来说，即GC Roots到这个对象是不可达的，则以此判断该对象是不可用的。</p>
<p>可达性分析原理示意图（来自Google I/O）</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/imgs/gc.png" alt=""></p>
<p>在Java语言中，可作为GC Roots的对象有以下几种：</p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
</ol>
<h3 id="u5E38_u7528_u7684_u5783_u573E_u6536_u96C6_u7B97_u6CD5"><a href="#u5E38_u7528_u7684_u5783_u573E_u6536_u96C6_u7B97_u6CD5" class="headerlink" title="常用的垃圾收集算法"></a>常用的垃圾收集算法</h3><h4 id="u6807_u8BB0-_u6E05_u9664_u7B97_u6CD5"><a href="#u6807_u8BB0-_u6E05_u9664_u7B97_u6CD5" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>标记-清除（Mark-Sweep）算法是最基础的垃圾手机算法，其分为两个阶段：首先标记出所需要回收的对象，然后在标记完成后统一回收所有被标记的对象。</p>
<p>标记-清除算法的不足：</p>
<ol>
<li>效率问题，标记和清除两个过程的效率都不高</li>
<li>空间问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多可能导致以后要为大对象分配内存时，如果找不到足够的连续内存而不得不触发另一次垃圾收集动作。</li>
</ol>
<p>标记-清除算法原理示意图（来自《深入理解Java虚拟机》）</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/imgs/mark-sweep.png" alt=""></p>
<h4 id="u590D_u5236_u7B97_u6CD5"><a href="#u590D_u5236_u7B97_u6CD5" class="headerlink" title="复制算法"></a>复制算法</h4><p>复制（Copying）算法为了解决上述算法的效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清空。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p>
<p>复制算法原理示意图（来自《深入理解Java虚拟机》）</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/imgs/Copying.png" alt=""></p>
<p>现代商业虚拟机都采用这种收集算法来回收新生代，但按上述原理，将内存缩小为原来的一半使用，这种代价有点太大了。IBM研究证明，98%的对象是“朝生夕死”，所以不必按1:1来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中一块Survivor。当回收内存时，将Eden和第一块Survivor中还存活的对象一次性地复制到第二块Survivor中，然后清理掉Eden和第一块Survivor空间。HotSpot虚拟机默认Eden与Survivor空间的大小比例为8:1，一旦第二块Survivor不足以容纳Eden与第一块Survivor复制过来的存活对象时，这些对象将通过分配担保机制进入老年代。</p>
<h4 id="u6807_u8BB0-_u6574_u7406_u7B97_u6CD5"><a href="#u6807_u8BB0-_u6574_u7406_u7B97_u6CD5" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>复制收集算法在对象存活率较高时就要频繁进行复制操作，导致效率变低，因此在老年代一般不选用这种算法。根据老年代的特点，有人提出了标记-整理（Mark-Compact）算法，标记过程跟标记-清除算法的一样，但后续步骤不是直接将可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>标记-整理算法原理示意图（来自《深入理解Java虚拟机》）</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/imgs/mark-compact.png" alt=""></p>
<h4 id="u5206_u4EE3_u6536_u96C6_u7B97_u6CD5"><a href="#u5206_u4EE3_u6536_u96C6_u7B97_u6CD5" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>当前虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法。算法思想是跟根据对象存活周期的不同将内存划分为几块，一般将Java堆划分为新生代和老年代，这样可以根据各个年代的特点采用最合适的垃圾收集算法。</p>
<p>在新生代中，每次垃圾收集时都有大量对象死亡，只有少量存活，因此优选复制算法，这样只需要付出少量对象的复制成本就可以完成收集；而对于老年代，因为对象存活率高，且没有额外的空间对它进行分配担保，就更适合使用标记-清理或标记-整理算法来进行回收。</p>
<p>参考资料《深入理解Java虚拟机》</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/25/理解Java对象克隆/">理解Java对象克隆</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-08-25
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Java/">Java</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h3 id="u7B80_u5355_u7684_u5BF9_u8C61_u62F7_u8D1D"><a href="#u7B80_u5355_u7684_u5BF9_u8C61_u62F7_u8D1D" class="headerlink" title="简单的对象拷贝"></a>简单的对象拷贝</h3><p>在应用开发中，有时候需要得到一个对象的副本，然后对该副本做一些修改而不影响原始对象，可能大家会想到像下面示例中这样做。</p>
<p>假设定义一个Person对象，只有name和age两个字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按如下方法进行对象拷贝：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person original = <span class="keyword">new</span> Person(<span class="string">"paul"</span>, <span class="number">18</span>);</span><br><span class="line">        Person copy = original;</span><br><span class="line">        copy.age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"original-name:"</span> + original.name + <span class="string">",age:"</span> + original.age);</span><br><span class="line">        System.out.println(<span class="string">"copy-name:"</span> + copy.name + <span class="string">",age:"</span> + copy.age);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>original-name:paul,age:20<br>copy-name:paul,age:20</p>
</blockquote>
<p>经测试发现，对拷贝对象做的修改，也导致原始对象发生了改变。其实拷贝变量与原始变量都指向了同一个引用，改变一个变量所引用的对象都将对另一个变量产生影响。我们可以打印original对象与copy对象的hashcode，就会发现它们的值相同，从而证明它们确实指向同一个引用，因此此法不通。</p>
<h3 id="u5BF9_u8C61_u514B_u9686"><a href="#u5BF9_u8C61_u514B_u9686" class="headerlink" title="对象克隆"></a>对象克隆</h3><p>此时也许你想到了clone方法，但clone没法直接调用，它是Object的一个protected方法，可重新为Person类定义一个public的clone方法，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意还必须为Person类实现Cloneable接口，否则将报<code>java.lang.CloneNotSupportedException</code>异常。需要知道的是Cloneable接口是Java提供的几个标记接口之一，所谓标记接口，就是该接口没有方法让实现类来实现，使用该接口的唯一目的便是可以利用instanceof进行类型检验，如：</p>
<blockquote>
<p>if (obj instanceof Cloneable)</p>
</blockquote>
<p>此时我们再来克隆一个对象，继续测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Person original = <span class="keyword">new</span> Person(<span class="string">"paul"</span>, <span class="number">18</span>);</span><br><span class="line">Person copy = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    copy = original.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">copy.age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"original-name:"</span> + original.name + <span class="string">",age:"</span> + original.age);</span><br><span class="line">System.out.println(<span class="string">"copy-name:"</span> + copy.name + <span class="string">",age:"</span> + copy.age);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>original-name:paul,age:18<br>copy-name:paul,age:20</p>
</blockquote>
<p>终于发现，当修改克隆得到的对象的年龄，不会对原始对象的年龄产生影响了，通过打印两个对象的hashcode，可知它们是两个不同的对象，也许此刻你觉得已经找到终极解决方案了！</p>
<p>但是，不要高兴得太早，没那么简单……</p>
<h3 id="u6D45_u62F7_u8D1D_u4E0E_u6DF1_u62F7_u8D1D"><a href="#u6D45_u62F7_u8D1D_u4E0E_u6DF1_u62F7_u8D1D" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h3><p>假如当Person对象中又包含了子对象的引用，如下面的示例，为Person对象添加一个Pet字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> Pet pet;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中Pet类定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String nickName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pet</span><span class="params">(String nickName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nickName = nickName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Person original = <span class="keyword">new</span> Person(<span class="string">"paul"</span>, <span class="number">18</span>);</span><br><span class="line">original.pet = <span class="keyword">new</span> Pet(<span class="string">"mimi"</span>);</span><br><span class="line"></span><br><span class="line">Person copy = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    copy = original.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">copy.age = <span class="number">20</span>;</span><br><span class="line">copy.pet.nickName = <span class="string">"beibei"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"original-name:"</span> + original.name + <span class="string">",age:"</span> + original.age + <span class="string">",Pet nickName:"</span> + original.pet.nickName);</span><br><span class="line">System.out.println(<span class="string">"copy-name:"</span> + copy.name + <span class="string">",age:"</span> + copy.age + <span class="string">",Pet nickName:"</span> + copy.pet.nickName);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"original-pet hashcode:"</span> + original.pet.hashCode());</span><br><span class="line">System.out.println(<span class="string">"copy-pet hashcode:"</span> + copy.pet.hashCode());</span><br><span class="line">System.out.println(<span class="string">"original hashcode:"</span> + original.hashCode());</span><br><span class="line">System.out.println(<span class="string">"copy hashcode:"</span> + copy.hashCode());</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>original-name:paul,age:18,Pet nickName:beibei<br>copy-name:paul,age:20,Pet nickName:beibei<br>original-pet hashcode:7643448<br>copy-pet hashcode:7643448<br>original hashcode:1761895363<br>copy hashcode:513775457</p>
</blockquote>
<p>可见，通过克隆得到的Person对象的age字段的修改不会对原始对象产生影响，但当把克隆得到的Person对象的Pet的昵称从“mimi”改为了“beibei”，结果导致原始对象的Pet的昵称也变成了“beibei”，通过克隆对象与原始对象的Pet的hashcode值均为7643448可知，两个对象所引用的Pet其实是同一个对象。</p>
<p>到这里是否觉得有点乱了？clone()本身是Object的方法，而Object类其实对具体的类对象一无所知，所以就会将各个域进行对应的拷贝。如果对象中的所有数据域都属于数值或基本数据类型，这样的拷贝是没有问题的。但是如果对象中包含了对子对象的引用，拷贝的结果会将两个域引用到同一个子对象，导致原始对象与克隆对象共享这部分数据。</p>
<p>默认的克隆其实是浅拷贝（shallow copy），它不会克隆包含在对象中的内部对象，上述场景就是由于我们使用了浅拷贝。当然如果对象中的内部对象是不可变的，那么使用浅拷贝也无所谓，但是如果对象中的内部对象是可变的，如上述示例Person中的Pet，那么使用浅拷贝进行克隆就会出现问题。此时就需要我们重定义clone，实现所谓的深拷贝（deep copy）。</p>
<p>实现深拷贝的方案如下，首先为Pet类重定义clone方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String nickName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pet</span><span class="params">(String nickName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nickName = nickName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Pet) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后改写Person中的clone方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> Pet pet;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person person = (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">        person.pet = pet.clone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码不变，依然如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Person original = <span class="keyword">new</span> Person(<span class="string">"paul"</span>, <span class="number">18</span>);</span><br><span class="line">original.pet = <span class="keyword">new</span> Pet(<span class="string">"mimi"</span>);</span><br><span class="line"></span><br><span class="line">Person copy = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    copy = original.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">copy.age = <span class="number">20</span>;</span><br><span class="line">copy.pet.nickName = <span class="string">"beibei"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"original-name:"</span> + original.name + <span class="string">",age:"</span> + original.age + <span class="string">",Pet nickName:"</span> + original.pet.nickName);</span><br><span class="line">System.out.println(<span class="string">"copy-name:"</span> + copy.name + <span class="string">",age:"</span> + copy.age + <span class="string">",Pet nickName:"</span> + copy.pet.nickName);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"original-pet hashcode:"</span> + original.pet.hashCode());</span><br><span class="line">System.out.println(<span class="string">"copy-pet hashcode:"</span> + copy.pet.hashCode());</span><br><span class="line">System.out.println(<span class="string">"original hashcode:"</span> + original.hashCode());</span><br><span class="line">System.out.println(<span class="string">"copy hashcode:"</span> + copy.hashCode());</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>original-name:paul,age:18,Pet nickName:mimi<br>copy-name:paul,age:20,Pet nickName:beibei<br>original-pet hashcode:179704568<br>copy-pet hashcode:932666694<br>original hashcode:7643448<br>copy hashcode:1761895363</p>
</blockquote>
<p>可以看到，此时修改克隆对象的Pet的nickName，仅会影响到克隆对象，不会再影响原始对象的值了。再次对比克隆对象与原始对象的Pet的哈希值，可知现在它们已经是两个不同的对象了，也证明了我们实现了对子对象的深拷贝。</p>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>其实克隆的应用场景并不多，但我们也应谨慎使用克隆，一旦为某个类实现了clone方法，那么就意味着可以为它克隆对象。另外如果需要实现深拷贝，那么还需要重新实现clone方法。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/24/Java内存模型——《深入理解Java虚拟机》笔记/">Java内存模型——《深入理解Java虚拟机》笔记</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-08-24
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Java/">Java</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h3 id="Java_u5185_u5B58_u6A21_u578B_u6982_u8FF0"><a href="#Java_u5185_u5B58_u6A21_u578B_u6982_u8FF0" class="headerlink" title="Java内存模型概述"></a>Java内存模型概述</h3><p>Java运行在JVM上，通常说的Java内存模型是指在Java虚拟机上的内存分配模型。</p>
<p>Java虚拟机在执行Java程序时会把它管理的内存划分为几个不同的数据区域。这些区域有各自的用途以及创建、销毁时间，有的区域随着虚拟机进程的启动而存在，有的区域则随着用户线程的启动而建立，随着用户线程的结束而销毁。根据《Java虚拟机规范（Java SE 7版）》，Java虚拟机中存在的几块内存区域如下图：</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/imgs/Jvm.jpg" alt=""></p>
<p>其中线程私有的数据区有：</p>
<ol>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ol>
<p>线程共享的数据区有：</p>
<ol>
<li>堆</li>
<li>方法区</li>
</ol>
<h3 id="u8FD0_u884C_u65F6_u6570_u636E_u533A_u57DF"><a href="#u8FD0_u884C_u65F6_u6570_u636E_u533A_u57DF" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><h4 id="u7A0B_u5E8F_u8BA1_u6570_u5668"><a href="#u7A0B_u5E8F_u8BA1_u6570_u5668" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器（Program Counter Register）是一块很小的内存区域，可以看做当前线程所执行的字节码的行号指示器。</p>
<p>那么为什么程序计数器需要线程私有呢？由于JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个特定时刻，一个处理器或一个内核（如多核心处理器）都只会执行一条线程中的指令。因此，为了线程切换后能够恢复到上次执行的位置，每个线程就需要维护一个独立的程序计数器，这样各线程间就可以互不影响。</p>
<p>如果线程正在执行一个Java方法，那么该计数器记录的就是正在执行的虚拟机字节码指令的地址，如果正在执行的是一个Native方法，那么这个计数器的值则为空（Undefined）。</p>
<h4 id="u865A_u62DF_u673A_u6808"><a href="#u865A_u62DF_u673A_u6808" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>Java虚拟机栈也是线程私有的，因此它与线程的生命周期一致。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用来存储局部变量表、操作数栈、动态链接、方法出口等信息。当一个方法调用时，就对应着一个栈帧在虚拟机中入栈，当该方法执行完成时就对应着该栈帧在虚拟机中的出栈过程。</p>
<p>我们经常说的堆和栈，其中的“栈”就是指这里的虚拟机栈，或者指虚拟机栈中的局部变量表部分。局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用及ReturnAddress类型。</p>
<p>其中对象引用，即Reference类型，它不等同于对象本身，它可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置。ReturnAddress类型指向了一条字节码指令的地址。</p>
<p>局部变量表所需的空间在编译期间分配完成，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<h4 id="u672C_u5730_u65B9_u6CD5_u6808"><a href="#u672C_u5730_u65B9_u6CD5_u6808" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈与虚拟机栈的作用类似，主要区别是虚拟机栈为Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。有些虚拟机实现中，直接把虚拟机栈与本地方法栈合二为一，如Sun HotSpot虚拟机。</p>
<h4 id="Java_u5806"><a href="#Java_u5806" class="headerlink" title="Java堆"></a>Java堆</h4><p>对于多数应用来说，Java堆（Java Heap）是虚拟机所管理的内存分区中最大的一块，我们通常说的“堆”就是这块区域。Java堆是被所有线程共享的内存区域，因此在虚拟机启动时就被创建，此区域的唯一作用就是存放对象实例，几乎所有的对象实例都在这里分配内存。不过随着技术的发展，如JIT即时编译器的发展与逃逸分析技术的成熟，栈上分配、标量替换优化技术也可能导致并非所有对象都得在堆上分配，也可能在栈上临时分配对象。</p>
<p>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，既可以实现成固定大小的，也可以是可扩展的，当前主流的虚拟机都是按照可扩展来实现的，通过-Xmx和-Xms控制。</p>
<p>Java堆是垃圾收集的主要区域，因此也被称为“GC堆”。</p>
<p>从内存回收角度来看，由于垃圾收集器的分代收集算法，Java堆又可分为新生代和老年代，新生代又细分为Eden、From Survivor、To Survivor等区域，这样做的目的是为了更高效地进行内存回收。</p>
<p>从内存分配角度来看，Java堆可以划分为多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），这样划分的目的是为了更快地分配内存。</p>
<h4 id="u65B9_u6CD5_u533A"><a href="#u65B9_u6CD5_u533A" class="headerlink" title="方法区"></a>方法区</h4><p>方法区也是线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或可扩展外，还可以选择不实现垃圾收集。一般来说，方法区的垃圾回收效率及效果都难以让人满意，这个区域的内存回收主要是针对常量池的回收和对类型的卸载，条件相当苛刻，但这部分的内存回收确实是有必要的。</p>
<h4 id="u8FD0_u884C_u65F6_u5E38_u91CF_u6C60"><a href="#u8FD0_u884C_u65F6_u5E38_u91CF_u6C60" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。此区域用于存储编译期生成的各种字面量和符号引用。</p>
<p>运行时常量池相对于Class文件常量池（Constant Pool Table）的一个重要特性是具备动态性，即Java语言不要求常量一定要在编译期间产生，也就是并非预置入Class文件中常量池的内容才能进入方法区的运行时常量池，运行期间也可以将新的常量放入池中，如String类的intern()方法，当调用intern()时，发现某字符串常量在该常量池中不存在，这时才将该常量入池，然后返回其引用，这就是在运行期间入池的一个示例。</p>
<h3 id="u5404_u6570_u636E_u533A_u5F02_u5E38"><a href="#u5404_u6570_u636E_u533A_u5F02_u5E38" class="headerlink" title="各数据区异常"></a>各数据区异常</h3><h4 id="u7A0B_u5E8F_u8BA1_u6570_u5668-1"><a href="#u7A0B_u5E8F_u8BA1_u6570_u5668-1" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>此内存区域是唯一一个在Java虚拟机规范中没有规定任何异常情况的区域。</p>
<h4 id="u865A_u62DF_u673A_u6808-1"><a href="#u865A_u62DF_u673A_u6808-1" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>在此区域中，Java虚拟机规范定义了两种异常情况：</p>
<ol>
<li>StackOverflowError：当线程请求的栈深度大于虚拟机所允许的深度，将抛出此异常，如递归调用，这个很常见。</li>
<li>OutOfMemoryError：当虚拟机栈动态扩展时（当前大部分虚拟机都支持动态扩展，也允许指定固定长度的虚拟机栈），如果无法申请到足够的内存，就会抛出此异常。</li>
</ol>
<h4 id="u672C_u5730_u65B9_u6CD5_u6808-1"><a href="#u672C_u5730_u65B9_u6CD5_u6808-1" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>跟虚拟机栈一样，本地方法栈也存在两种异常情况：</p>
<ol>
<li>StackOverflowError</li>
<li>OutOfMemoryError</li>
</ol>
<h4 id="Java_u5806-1"><a href="#Java_u5806-1" class="headerlink" title="Java堆"></a>Java堆</h4><p>Java虚拟机规范规定堆区域可发生以下异常：</p>
<ol>
<li>OutOfMemoryError：当堆中没有足够的内存来为实例分配，并且堆也无法扩展，此时就会报出该异常。</li>
</ol>
<h4 id="u65B9_u6CD5_u533A-1"><a href="#u65B9_u6CD5_u533A-1" class="headerlink" title="方法区"></a>方法区</h4><p>根据虚拟机规范，此区域有如下异常：</p>
<ol>
<li>OutOfMemoryError：当方法区无法满足内存分配需求时，将抛出此异常。</li>
</ol>
<h4 id="u8FD0_u884C_u65F6_u5E38_u91CF_u6C60-1"><a href="#u8FD0_u884C_u65F6_u5E38_u91CF_u6C60-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>由于常量池是方法区的一部分，其内存大小必然受到方法区的限制，因此当常量池无法再申请到足够内存时，也会抛出OutOfMemoryError异常。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/18/从一个崩溃再谈Context/">从一个崩溃再谈Context</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-08-18
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h4 id="u5F02_u5E38_u4FE1_u606F"><a href="#u5F02_u5E38_u4FE1_u606F" class="headerlink" title="异常信息"></a>异常信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">AndroidRuntime: FATAL EXCEPTION: main Process: com.aspook.contexttest, PID: <span class="number">22578</span></span><br><span class="line">  android.util.AndroidRuntimeException: <span class="function">Calling <span class="title">startActivity</span><span class="params">()</span> from outside of an Activity  context requires the FLAG_ACTIVITY_NEW_TASK flag. Is <span class="keyword">this</span> really what you want?</span><br><span class="line">      at android.app.ContextImpl.<span class="title">startActivity</span><span class="params">(ContextImpl.java:<span class="number">672</span>)</span></span><br><span class="line">      at android.app.ContextImpl.<span class="title">startActivity</span><span class="params">(ContextImpl.java:<span class="number">659</span>)</span></span><br><span class="line">      at android.content.ContextWrapper.<span class="title">startActivity</span><span class="params">(ContextWrapper.java:<span class="number">331</span>)</span></span><br><span class="line">      at android.widget.TextView.<span class="title">shareSelectedText</span><span class="params">(TextView.java:<span class="number">9493</span>)</span></span><br><span class="line">      at android.widget.TextView.<span class="title">onTextContextMenuItem</span><span class="params">(TextView.java:<span class="number">9211</span>)</span></span><br><span class="line">      at android.widget.Editor$TextActionModeCallback.<span class="title">onActionItemClicked</span><span class="params">(Editor.java:<span class="number">3249</span>)</span></span><br><span class="line">      at com.android.internal.policy.PhoneWindow$DecorView$ActionModeCallback2Wrapper.<span class="title">onActionItemClicked</span><span class="params">(PhoneWindow.java:<span class="number">3540</span>)</span></span><br><span class="line">      at com.android.internal.view.FloatingActionMode$3.<span class="title">onMenuItemSelected</span><span class="params">(FloatingActionMode.java:<span class="number">85</span>)</span></span><br><span class="line">      at com.android.internal.view.menu.MenuBuilder.<span class="title">dispatchMenuItemSelected</span><span class="params">(MenuBuilder.java:<span class="number">761</span>)</span></span><br><span class="line">      at com.android.internal.view.menu.MenuItemImpl.<span class="title">invoke</span><span class="params">(MenuItemImpl.java:<span class="number">152</span>)</span></span><br><span class="line">      at com.android.internal.view.menu.MenuBuilder.<span class="title">performItemAction</span><span class="params">(MenuBuilder.java:<span class="number">904</span>)</span></span><br><span class="line">      at com.android.internal.view.menu.MenuBuilder.<span class="title">performItemAction</span><span class="params">(MenuBuilder.java:<span class="number">894</span>)</span></span><br><span class="line">      at com.android.internal.view.FloatingActionMode$4.<span class="title">onMenuItemClick</span><span class="params">(FloatingActionMode.java:<span class="number">111</span>)</span></span><br><span class="line">      at com.android.internal.widget.FloatingToolbar$FloatingToolbarMainPanel$1.<span class="title">onClick</span><span class="params">(FloatingToolbar.java:<span class="number">1015</span>)</span></span><br><span class="line">      at android.view.View.<span class="title">performClick</span><span class="params">(View.java:<span class="number">5204</span>)</span></span><br><span class="line">      at android.view.View$PerformClick.<span class="title">run</span><span class="params">(View.java:<span class="number">21155</span>)</span></span><br><span class="line">      at android.os.Handler.<span class="title">handleCallback</span><span class="params">(Handler.java:<span class="number">739</span>)</span></span><br><span class="line">      at android.os.Handler.<span class="title">dispatchMessage</span><span class="params">(Handler.java:<span class="number">95</span>)</span></span><br><span class="line">      at android.os.Looper.<span class="title">loop</span><span class="params">(Looper.java:<span class="number">148</span>)</span></span><br><span class="line">      at android.app.ActivityThread.<span class="title">main</span><span class="params">(ActivityThread.java:<span class="number">5422</span>)</span></span><br><span class="line">      at java.lang.reflect.Method.<span class="title">invoke</span><span class="params">(Native Method)</span></span><br><span class="line">      at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.<span class="title">run</span><span class="params">(ZygoteInit.java:<span class="number">726</span>)</span></span><br><span class="line">      at com.android.internal.os.ZygoteInit.<span class="title">main</span><span class="params">(ZygoteInit.java:<span class="number">616</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>上面是整个异常的堆栈信息，我们先来看主要的部分：</p>
<blockquote>
<p>android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity  context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?</p>
</blockquote>
<p>这个异常相信大家都见过，也知道其发生的原因以及如何修复。不过我猜测大家遇到此异常多是因为在自己的代码里没有用Activity的上下文去startActivity且没有添加FLAG_ACTIVITY_NEW_TASK这个flag。而我遇到的这个异常却不是由于人为使用错误的Context去startActivity造成的，而是系统自己调用startActivity引起的。</p>
<h4 id="u539F_u56E0_u5206_u6790"><a href="#u539F_u56E0_u5206_u6790" class="headerlink" title="原因分析"></a>原因分析</h4><p>其实从用代码去启动Activity的层面上讲，自己写的话不会犯上述错误。情况是这样的，对于一个EditText，长按其内容可以弹出系统的上下文菜单，支持复制、全选等，然后在新的系统里面开始支持分享了。当选中一些文本，点击分享的时候，本应该调起系统的分享界面，而这时候就报此异常了，异常堆栈信息也指出了该事实：</p>
<blockquote>
<p>at android.widget.TextView.shareSelectedText(TextView.java:9493)</p>
</blockquote>
<p>由于老版本的Android不支持分享功能，所以一直没有发现该异常，最根本原因还是由于代码写的有问题。</p>
<p>下面就来复现一下这个异常。</p>
<ol>
<li><p>界面很简单，就一个EditText</p>
</li>
<li><p>界面布局利用LayoutInflater引入，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    LayoutInflater mLayoutInflater = LayoutInflater.from(getApplicationContext());</span><br><span class="line">    View root = mLayoutInflater.inflate(R.layout.activity_second, <span class="keyword">null</span>);</span><br><span class="line">    setContentView(root);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>最终效果如下图：</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/imgs/exception_share.jpg" alt=""></p>
<p>上述代码乍一看没什么问题，如果不使用长按分享功能，也一切正常。但选中文本后进行分享，当调起系统分享界面时就发生了崩溃。我们可能有以下经验：</p>
<p>在Activity中通过startActivity(intent)可以正常启动另一Activity，而通过getApplicationContext().startActivity(intent)则会报上述相同错误（如果没设置FLAG_ACTIVITY_NEW_TASK的话）。因此可以判断原因必定是由于使用了错误的Context引起。仔细检查上述代码，并没有显式调用startActivity的代码，只有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflater mLayoutInflater = LayoutInflater.from(getApplicationContext());</span><br></pre></td></tr></table></figure>
<p>这一句引入了Context对象，因此可以推断是通过LayoutInflater引入布局时错用了Application的Context，而这里应该使用Activity的上下文对象。</p>
<p>将上面错误代码改写如下后，果然不再报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflater mLayoutInflater = LayoutInflater.from(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>关于Context的分析及使用，网上已有太多文章，这里就不再分析，请参考<a href="http://www.jianshu.com/p/94e0f9ab3f1d/" target="_blank" rel="external">Context都没弄明白，还怎么做Android开发？</a>或者自己去看源码，下面也是来自这篇文章的一张总结图片：</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/imgs/context.png" alt=""></p>
<h4 id="u5228_u6839_u95EE_u5E95"><a href="#u5228_u6839_u95EE_u5E95" class="headerlink" title="刨根问底"></a>刨根问底</h4><p>既然我们知道原因是由于LayoutInflater时传入了错误的Context，那么LayoutInflater中的Context是怎样传到TextView（EditView继承自TextView）中的呢？</p>
<p>从错误日志信息</p>
<blockquote>
<p>at android.widget.TextView.shareSelectedText(TextView.java:9493)</p>
</blockquote>
<p>定位到TextView的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shareSelectedText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String selectedText = getSelectedText();</span><br><span class="line">    <span class="keyword">if</span> (selectedText != <span class="keyword">null</span> &amp;&amp; !selectedText.isEmpty()) &#123;</span><br><span class="line">        Intent sharingIntent = <span class="keyword">new</span> Intent(android.content.Intent.ACTION_SEND);</span><br><span class="line">        sharingIntent.setType(<span class="string">"text/plain"</span>);</span><br><span class="line">        sharingIntent.removeExtra(android.content.Intent.EXTRA_TEXT);</span><br><span class="line">        sharingIntent.putExtra(android.content.Intent.EXTRA_TEXT, selectedText);</span><br><span class="line">        getContext().startActivity(Intent.createChooser(sharingIntent, <span class="keyword">null</span>));</span><br><span class="line">        stopTextActionMode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>倒数第二行<code>getContext().startActivity(Intent.createChooser(sharingIntent, null));</code>就是这里调用的系统分享界面。</p>
<p>接着看getContext()，定位到View.java源码中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns the context the view is running in, through which it can</span><br><span class="line"> * access the current theme, resources, etc.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span> The view's Context.</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@ViewDebug</span>.<span class="function">CapturedViewProperty</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Context <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续跟踪发现，mContext是在View的构造函数中赋值的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Simple constructor to use when creating a view from code.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> context The Context the view is running in, through which it can</span><br><span class="line"> *        access the current theme, resources, etc.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们接下来就是要分析LayoutInflater生成View的过程了，主要代码都在LayoutInflater.java中，逻辑细节比较繁琐，但最终是通过反射调用View的构造函数创建一个View对象，因此Context就传到了View中。如果对LayoutInflater生成View的流程感兴趣，可以参考<a href="https://github.com/peerless2012/SourceAnalysis/blob/master/Android/FrameWork/LayoutInflater%26LayoutInflaterCompat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md" target="_blank" rel="external">LayoutInflater&amp;LayoutInflaterCompat源码解析</a>，这里不再分析，对于LayoutInflater生成View的需求，建议使用Activity的上下文对象，除了可以避免上述隐藏的崩溃外，还可以让视图的主题跟Activity保持一致，如果使用Application的上下文，则视图的主题为应用的主题，可能会造成不一致。</p>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    
    
      <a class="next" href="/page/3/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">AN</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Android高性能编码最佳实践"/>




  <meta name="keywords" content="高性能编码, ASPOOK" />










  <link rel="alternative" href="/default" title="ASPOOK" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://aspook.com/2017/01/19/Android高性能编码最佳实践/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />






  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> Android高性能编码最佳实践 - ASPOOK </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">ASPOOK</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">ASPOOK</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Android高性能编码最佳实践
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-01-19
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Android/">Android</a>
            
          </div>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#u907F_u514D_u521B_u5EFA_u4E0D_u5FC5_u8981_u7684_u5BF9_u8C61"><span class="toc-text">避免创建不必要的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u4F18_u5148_u4F7F_u7528Static_u65B9_u6CD5"><span class="toc-text">优先使用Static方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u4F7F_u7528static_u548Cfinal_u6765_u4FEE_u9970_u5E38_u91CF"><span class="toc-text">使用static和final来修饰常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u907F_u514D_u5185_u90E8_u7684Getters/Setters"><span class="toc-text">避免内部的Getters/Setters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u4F7F_u7528_u589E_u5F3A_u7684for_u5FAA_u73AF_u8BED_u6CD5"><span class="toc-text">使用增强的for循环语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5BF9_u4E8E_u79C1_u6709_u5185_u90E8_u7C7B_uFF0C_u4F7F_u7528_u5305_u8BBF_u95EE_u6743_u9650_u4EE3_u66FF_u79C1_u6709_u8BBF_u95EE_u6743_u9650"><span class="toc-text">对于私有内部类，使用包访问权限代替私有访问权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u907F_u514D_u4F7F_u7528_u6D6E_u70B9_u578B"><span class="toc-text">避免使用浮点型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u4E86_u89E3_u5E76_u4F7F_u7528Library"><span class="toc-text">了解并使用Library</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u8C28_u614E_u4F7F_u7528Native_u65B9_u6CD5"><span class="toc-text">谨慎使用Native方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u6027_u80FD_u795E_u8BDD"><span class="toc-text">性能神话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u6301_u7EED_u8861_u91CF"><span class="toc-text">持续衡量</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p>本文主要讲一些代码级别的细微优化，但别小看这些，当它们组合起来的时候就能提高App的整体性能。这类的优化不同于算法与数据结构优化所能达到的显著效果，但我们应该把它作为自己的编码习惯从而写出高效的代码。</p>
<p>写出高效代码的两个基本原则：</p>
<ul>
<li>不要做不必要的事情</li>
<li>不要分配不必要的内存</li>
</ul>
<p>优化一个App时最棘手的问题在于它可能运行于不同的硬件设备上，不同的虚拟机版本、不同的处理器从而导致不同的运行速度；设备有无JIT也将导致不同的性能。为了保证在不同的设备上都有较好的性能，我们就需要从代码层面进行优化，确保代码可以高效地执行。</p>
<h3 id="u907F_u514D_u521B_u5EFA_u4E0D_u5FC5_u8981_u7684_u5BF9_u8C61"><a href="#u907F_u514D_u521B_u5EFA_u4E0D_u5FC5_u8981_u7684_u5BF9_u8C61" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h3><p>对象创建是有开销的，我们需要尽可能避免创建过多临时性的对象，一旦为App创建了过多的对象，那就意味着频繁地垃圾回收。频繁地垃圾回收会对用户体验造成不良影响，虽然Android 2.3之后，垃圾回收不再是“Stop-The-World”，可以并发执行了，但我们仍需要避免不必要的对象创建。以下示例可作为参考：</p>
<ul>
<li>如果一个方法返回String结果并且该结果将会被附加到一个StringBuffer上，则可以修改方法的实现直接处理附加操作，从而避免创建一个临时对象。</li>
<li>如果从一个输入中提取字符串，尽可能返回原始数据的一个子串而不是原始数据的拷贝。你将创建一个新的String对象，但可以与原始数据共享char[]。</li>
</ul>
<p>一种比较激进的方法是将多维数组分割成多个平行的一维数组：</p>
<ul>
<li>int数组比Integer数组更高效，也可以推广到两个平行的int数组比二维数组（int, int）更加高效，对于任何其他原始类型的组合也一样。</li>
<li>如果想实现类似（Foo,Bar）的元组对象，尽量使用两个平行的数组：Foo[]与Bar[]。当然如果我们是在实现对外的API，则需要对此做一个折中，牺牲一点速度，从而实现一个好的API设计。但对于我们内部代码来说，应该尽可能地高效。</li>
</ul>
<p>总的来说，尽量避免不必要的对象创建，创建的对象越少，意味着垃圾回收的频率也越低，这将直接影响到用户的体验。</p>
<h3 id="u4F18_u5148_u4F7F_u7528Static_u65B9_u6CD5"><a href="#u4F18_u5148_u4F7F_u7528Static_u65B9_u6CD5" class="headerlink" title="优先使用Static方法"></a>优先使用Static方法</h3><p>如果不需要访问一个对象的属性，可以将方法声明为static，这样做可以使该方法的调用速度提高15%-20%。这是一种好的做法，从而可以通知方法签名调用该方法并不会改变对象的属性状态。</p>
<h3 id="u4F7F_u7528static_u548Cfinal_u6765_u4FEE_u9970_u5E38_u91CF"><a href="#u4F7F_u7528static_u548Cfinal_u6765_u4FEE_u9970_u5E38_u91CF" class="headerlink" title="使用static和final来修饰常量"></a>使用static和final来修饰常量</h3><p>来看类中的如下声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> intVal = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">static</span> String strVal = <span class="string">"Hello, world!"</span>;</span><br></pre></td></tr></table></figure>
<p>当该类第一次被使用时，编译器会生成一个叫做<clinit>的类初始化方法，该方法会将42存储到intVal中并为strVal返回一个类文件字符串常量表中的一个引用。当这些变量被调用的时候，它们通过字段查找的方式被访问。</clinit></p>
<p>我们可以使用final关键字来优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> intVal = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String strVal = <span class="string">"Hello, world!"</span>;</span><br></pre></td></tr></table></figure>
<p>这样一来该类不再需要<clinit>方法，因为上述常量将会使用静态字段初始化。调用intVal时将会直接使用整型值42，访问strVal时将会使用开销更小的字符串常量而不是字段查找。</clinit></p>
<blockquote>
<p>注意：这个优化只针对原始类型及String常量。</p>
</blockquote>
<h3 id="u907F_u514D_u5185_u90E8_u7684Getters/Setters"><a href="#u907F_u514D_u5185_u90E8_u7684Getters/Setters" class="headerlink" title="避免内部的Getters/Setters"></a>避免内部的Getters/Setters</h3><p>在C++这样的语言中，经常使用getters（如i=getCount()）来代替直接的字段访问（如i=mCount），这个特性同样被用于C#、Java等面向对象的语言中。</p>
<p>然而在Android中，这样使用并不是一个好习惯。方法调用比字段查找的开销更大，虽然从面向对象编程的角度来看应该使用getters与setters，但在一个类的内部，应该尽可能直接访问字段。</p>
<p>在没有JIT的情况下，直接对字段进行访问比调用getter方法大概要快3倍；有JIT的情况下，直接对字段进行访问比getter大概要快7倍。</p>
<h3 id="u4F7F_u7528_u589E_u5F3A_u7684for_u5FAA_u73AF_u8BED_u6CD5"><a href="#u4F7F_u7528_u589E_u5F3A_u7684for_u5FAA_u73AF_u8BED_u6CD5" class="headerlink" title="使用增强的for循环语法"></a>使用增强的for循环语法</h3><p>增强的for循环如for-each，可以用于实现了Iterable接口的集合、数组。以下示例是几种遍历数组的方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mSplat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo[] mArray = ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mArray.length; ++i) &#123;</span><br><span class="line">        sum += mArray[i].mSplat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    Foo[] localArray = mArray;</span><br><span class="line">    <span class="keyword">int</span> len = localArray.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        sum += localArray[i].mSplat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">two</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Foo a : mArray) &#123;</span><br><span class="line">        sum += a.mSplat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法zero()是最慢的，因为每一次循环时都要获取数组长度，这个开销JIT无法优化。</p>
<p>方法one()比zero()快，它把所有变量都存储为局部变量，避免了查找，优化了获取数组长度的性能开销。</p>
<p>方法two()使用了增强的for循环语法，在无JIT时是最快的；在有JIT的情况下，它跟方法one()的性能大概类似。</p>
<h3 id="u5BF9_u4E8E_u79C1_u6709_u5185_u90E8_u7C7B_uFF0C_u4F7F_u7528_u5305_u8BBF_u95EE_u6743_u9650_u4EE3_u66FF_u79C1_u6709_u8BBF_u95EE_u6743_u9650"><a href="#u5BF9_u4E8E_u79C1_u6709_u5185_u90E8_u7C7B_uFF0C_u4F7F_u7528_u5305_u8BBF_u95EE_u6743_u9650_u4EE3_u66FF_u79C1_u6709_u8BBF_u95EE_u6743_u9650" class="headerlink" title="对于私有内部类，使用包访问权限代替私有访问权限"></a>对于私有内部类，使用包访问权限代替私有访问权限</h3><p>看下面这个类的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">stuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Foo.<span class="keyword">this</span>.doStuff(Foo.<span class="keyword">this</span>.mValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        mValue = <span class="number">27</span>;</span><br><span class="line">        in.stuff();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStuff</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Value is "</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，Foo类中定义了一个内部类Inner，这个内部类直接访问了外部类的私有方法及私有成员字段。这是合法的，最终代码会输出“Value is 27”。</p>
<p>但是从虚拟机角度来看，从内部类Inner直接访问外部类Foo的私有方法及成员是不合法的，因为它们是两个不同的类。为了使得它们可以直接访问，编译器生成了一些合成方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">int</span> Foo.access$<span class="number">100</span>(Foo foo) &#123;</span><br><span class="line">    <span class="keyword">return</span> foo.mValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">void</span> Foo.access$<span class="number">200</span>(Foo foo, <span class="keyword">int</span> value) &#123;</span><br><span class="line">    foo.doStuff(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当Inner需要访问外部类的私有方法及成员变量时就会调用上述静态方法。这意味着需要通过合成的访问器方法来访问变量，因为会比直接访问要慢，这也可以作为一个示例，说明了一些不可见的性能损耗。</p>
<p>为了避免上述情况的性能开销，可以将被内部类访问方法及变量声明为包访问权限而不是私有访问权限。但这就意味着可以被同包的其他类直接访问，因此最好不要出现在公有API中。</p>
<h3 id="u907F_u514D_u4F7F_u7528_u6D6E_u70B9_u578B"><a href="#u907F_u514D_u4F7F_u7528_u6D6E_u70B9_u578B" class="headerlink" title="避免使用浮点型"></a>避免使用浮点型</h3><p>众所周知，在Android设备上浮点型比整型大概慢2倍。</p>
<p>从速度方面来看，float与double在现代硬件设备上几乎没有什么区别。从空间开销角度来看，double是float的2倍。对于台式机来说，假如空间不是问题，那么应该优先选择double。</p>
<p>对于整型来说，一些处理器有硬件乘法而缺少硬件除法支持，这种情况下，整型除法以及求模运算需要在软件层面处理，比如设计一个哈希表或进行大量的数学运算。</p>
<h3 id="u4E86_u89E3_u5E76_u4F7F_u7528Library"><a href="#u4E86_u89E3_u5E76_u4F7F_u7528Library" class="headerlink" title="了解并使用Library"></a>了解并使用Library</h3><p>In addition to all the usual reasons to prefer library code over rolling your own, bear in mind that the system is at liberty to replace calls to library methods with hand-coded assembler, which may be better than the best code the JIT can produce for the equivalent Java. The typical example here is <code>String.indexOf()</code> and related APIs, which Dalvik replaces with an inlined intrinsic. Similarly, the <code>System.arraycopy()</code> method is about 9x faster than a hand-coded loop on a Nexus One with the JIT.</p>
<h3 id="u8C28_u614E_u4F7F_u7528Native_u65B9_u6CD5"><a href="#u8C28_u614E_u4F7F_u7528Native_u65B9_u6CD5" class="headerlink" title="谨慎使用Native方法"></a>谨慎使用Native方法</h3><p>使用Android NDK写Native代码来实现App功能不一定比使用Java高效。例如，Java与Native的交互需要开销，并且JIT无法对此进行优化。一旦为Native资源分配内存（如在Native heap中），就意味着很难安排收集这些资源，并且需要为不同的CPU架构来编译不同的版本，甚至需要为相同的架构编译多个版本：如为G1的ARM处理器编译的Native代码并不能在Nexus One上充分发挥性能，而为Nexus One的ARM编译的代码则无法在G1的ARM上运行。</p>
<p>当我们想将已有的Native代码库用到Android的时候，我们才应该使用Native代码，而并非为了提升Java代码模块的速度使用Native代码。</p>
<p>如果需要使用Native代码，需要了解<a href="https://developer.android.google.cn/training/articles/perf-jni.html" target="_blank" rel="external">JNI</a>的相关知识。</p>
<h3 id="u6027_u80FD_u795E_u8BDD"><a href="#u6027_u80FD_u795E_u8BDD" class="headerlink" title="性能神话"></a>性能神话</h3><p>在没有JIT的情况下，通过明确类型的对象来调用方法比接口调用要快一些，如HashMap对象的方法调用快于Map接口，两者的效率大概相差6%左右，如果有JIT，则两者效率几乎是相同的。</p>
<p>在没有JIT的情况下，缓存字段的访问比重复访问某个字段快20%；有JIT时，字段访问开销跟本地访问相同，所以除非你觉得会让代码更易阅读，否则这不需要优化。</p>
<h3 id="u6301_u7EED_u8861_u91CF"><a href="#u6301_u7EED_u8861_u91CF" class="headerlink" title="持续衡量"></a>持续衡量</h3><p>在进行优化之前，最好先确认你需要解决的问题，务必确保能够精确衡量到目前的性能状态，否则即使优化之后，你也无法衡量优化所带来的性能提升。</p>
<p>你可能会使用<a href="https://developer.android.google.cn/studio/profile/traceview.html" target="_blank" rel="external">Traceview</a>来进行分析，但是需要意识到，使用Traceview时是禁用JIT的，因此可能会导致当你觉得性能不佳，但使用JIT后，性能又会显著提升的情况。当你根据Traceview的建议修改之后，务必要确保在没有Traceview的情况下，优化后的代码比以前的速度更快。</p>
<p>参考文献<a href="https://developer.android.google.cn/training/articles/perf-tips.html" target="_blank" rel="external">Performance Tips</a></p>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://aspook.com">AN</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://aspook.com/2017/01/19/Android高性能编码最佳实践/">http://aspook.com/2017/01/19/Android高性能编码最佳实践/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/高性能编码/">高性能编码</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2017/01/19/App内存占用优化/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">App内存占用优化</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2016/12/19/Android布局性能优化指南/">
        <span class="next-text nav-default">Android布局性能优化指南</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">AN</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  



    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>

<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="请不要灰心，你也会有人妒忌"><title>Java类加载器及Android类加载器基础 | ASPOOK</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java类加载器及Android类加载器基础</h1><a id="logo" href="/.">ASPOOK</a><p class="description">Serendipity</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java类加载器及Android类加载器基础</h1><div class="post-meta">Mar 7, 2017<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2017/03/07/Java类加载器及Android类加载器基础/" href="/2017/03/07/Java类加载器及Android类加载器基础/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><h3 id="u5F15_u5B50"><a href="#u5F15_u5B50" class="headerlink" title="引子"></a>引子</h3><p>Android插件化与热更新技术日渐成熟，当你研究这些技术时会发现类加载器在其中占据重要地位。Java语言天生就有灵活性、动态性，支持运行期间动态组装程序，而这一切的基础就是类加载器。</p>
<h3 id="Java_u4E2D_u7684_u7C7B_u52A0_u8F7D_u5668"><a href="#Java_u4E2D_u7684_u7C7B_u52A0_u8F7D_u5668" class="headerlink" title="Java中的类加载器"></a>Java中的类加载器</h3><h4 id="Java_u7075_u6D3B_u6027_u548C_u52A8_u6001_u6027_u7684_u539F_u56E0"><a href="#Java_u7075_u6D3B_u6027_u548C_u52A8_u6001_u6027_u7684_u539F_u56E0" class="headerlink" title="Java灵活性和动态性的原因"></a>Java灵活性和动态性的原因</h4><p>Java源代码被编译器编译成字节码，即从.java文件编译为.class文件，而.class文件就是通过类加载器加载到虚拟机内存中的。</p>
<p>虚拟机的类加载（Class Loading）过程分为加载、链接（验证、准备、解析）、初始化、使用、卸载等过程。这里仅考虑加载这个阶段，在此阶段虚拟机的工作有以下几点：</p>
<ol>
<li>通过一个类的全限定名来获取该类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p>注意看第1条，虚拟机规范只是说来获取一个类的二进制字节流，但并没有说从哪里获取，怎样获取，这也就意味着Class文件可以来自磁盘、ZIP文件、JAR文件、数据库、甚至来自网络或者在程序运行时动态生成。上述各种来源的Class文件都是由类加载器（Class Loader）来加载的，也正因为如此，Java才拥有高度的灵活性和动态性。</p>
<h4 id="Java_u4E2D_u7684_u51E0_u79CD_u7C7B_u52A0_u8F7D_u5668"><a href="#Java_u4E2D_u7684_u51E0_u79CD_u7C7B_u52A0_u8F7D_u5668" class="headerlink" title="Java中的几种类加载器"></a>Java中的几种类加载器</h4><p>Java中的类加载器至少有三种：</p>
<ul>
<li>启动类加载器——该加载器一般由C或C++实现（如HotSpot用C++实现，其实也有虚拟机是用Java实现的），它是作为虚拟机不可分割的一部分而存在。该加载器负责加载jre/lib中的系统类，如通常从rt.jar中进行加载。启动类加载器由于属于虚拟机的一部分，因此无法被Java程序直接引用，所以例如String.class.getClassLoader()将会返回null。</li>
<li>扩展类加载器——该加载器由Java语言实现，继承自java.lang.ClassLoader，独立于虚拟机外部，负责加载jre/lib/ext目录下的文件，如果对扩展类加载器调用getParent()也会返回null。</li>
<li>系统类加载器（或叫应用类加载器）——该加载器由Java语言实现，继承自java.lang.ClassLoader，独立于虚拟机外部，负责加载应用程序类。如果应用程序中没有自定义的类加载器，那么此加载器就是默认的类加载器。</li>
</ul>
<p>此外，用户还可以继承ClassLoader类来自定义类加载器，这样就可以在向虚拟机传递字节码之前进行需求定制了。</p>
<p>注意：对于任意一个Java类，它在虚拟机里的唯一性是由其类本身及其类加载器共同决定的。如果两个类来自同一个Class文件，在同一个虚拟机中，但是被不同的ClassLoader所加载，那么这两个类在虚拟机中也是不相等的。</p>
<h4 id="u7C7B_u52A0_u8F7D_u5668_u7684_u53CC_u4EB2_u59D4_u6D3E_u6A21_u578B"><a href="#u7C7B_u52A0_u8F7D_u5668_u7684_u53CC_u4EB2_u59D4_u6D3E_u6A21_u578B" class="headerlink" title="类加载器的双亲委派模型"></a>类加载器的双亲委派模型</h4><p>先来看下Java中的类加载器层次关系：</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/image/java_classloader.jpg" alt=""></p>
<p>上述层次关系称为类加载器的双亲委派模型，它是在JDK 1.2中引入的，其实它并非强制性的约束，而是推荐我们使用的一种类加载机制，可以看到除了顶部的启动类加载器之外，其他加载器都有一个父类加载器。</p>
<p>双亲委派模型的工作流程：当一个类收到加载类的请求时，它自己先不进行加载，而是把该请求委派为父类加载器去完成，父类加载器也是如此，直到将加载类的需求传给顶层的启动类加载器；只有当父类加载器无法完成加载时（在自己的搜索范围中没有找到该类），子加载器才尝试自己去完成类加载，如果加载不了，则会抛出ClassNotFoundException异常。</p>
<p>有一点需要注意：如果扩展类加载器收到请求去加载一个类，它会先委托启动类加载器去加载，如果启动类加载器加载不了，则尝试自己加载。如果扩展类加载器也无法加载，则直接抛出ClassNotFoundException异常而结束，并不会再交给下一层的应用类加载器去加载。</p>
<p>说明了双亲委派模型的原理后，再来看下其源码实现，代码逻辑很简单，也证实了上述讲到的双亲委派模型的工作流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 首先判断该类是否已经被加载过，如果已加载过就直接返回</span></span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没有被加载，就委托给父加载器处理或者给启动类加载器处理</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果存在父类加载器，就委派给父类加载器加载  </span></span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果不存在父类加载器，就检查是否由启动类加载器加载  </span></span><br><span class="line">                <span class="comment">// 通过调用native方法 findBootstrapClass0(String name)  </span></span><br><span class="line">                c = findBootstrapClass0(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 如果父加载器和启动类加载器都不能完成加载任务，自身才尝试去加载</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u53CC_u4EB2_u59D4_u6D3E_u6A21_u578B_u7684_u610F_u4E49"><a href="#u53CC_u4EB2_u59D4_u6D3E_u6A21_u578B_u7684_u610F_u4E49" class="headerlink" title="双亲委派模型的意义"></a>双亲委派模型的意义</h4><p>使用双亲委派模型来组织各种类加载器，使之遵循了一定的优先级层次，从而能保证Java运行环境的稳定与条理性。例如java.lang.Object类是所有类的基类，并且根据双亲委派模型它是由启动类加载器加载的，如果我们也自定义了一个java.lang.Object类（只是假如，其实虚拟机会对java.lang开头的自定义类抛异常）并放在应用程序的ClassPath中去加载，那么应用中就会出现多个Object类，从而会导致Java类型体系混乱而无法正常运行。</p>
<p>另一个好处是避免类的二次加载。从上述loadClass源码中可知，先判断该类是否被加载过，如果已被加载过则直接返回该类。当一个类加载器委托父类加载时也是执行此逻辑，从而保证某些类只被加载一次。</p>
<h4 id="u81EA_u5B9A_u4E49_u7C7B_u52A0_u8F7D_u5668"><a href="#u81EA_u5B9A_u4E49_u7C7B_u52A0_u8F7D_u5668" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><p>由于自定义类加载器通常继承ClassLoader，来看下ClassLoader的几个主要方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载指定完整名称的二进制字节流，不建议子类加载器重写，否则可能会破坏双亲委派模型</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载指定完整名称的二进制字节流，不建议子类加载器重写，否则可能会破坏双亲委派模型</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被loadClass方法调用去加载指定名称类，官方建议子类加载器重写该方法</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法将二进制字节流转换为Class,一般在findClass方法中读取到对应字节码后调用，由于是final方法，故不可继承，其功能具体由虚拟机实现，Java层不需要关心</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len) <span class="keyword">throws</span> ClassFormatError&#123; … &#125;</span><br></pre></td></tr></table></figure>
<p>上述几个方法的说明可参考注释。</p>
<p>为了遵循双亲委派模型，当自定义类加载器时，官方建议我们仅仅重写findClass()方法，而不要重写loadClass()方法，否则就有可能破坏双亲委派模型。当然前面也说了，双亲委派模型并非强制约束，如有特别需要，也可以自行确定类的加载规则。一个典型的自定义类加载器如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 获取类的字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ……</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可知类加载器的各个方法的执行顺序为：loadClass—&gt;findClass—&gt;defineClass。</p>
<h3 id="Android_u4E2D_u7684_u7C7B_u52A0_u8F7D_u5668"><a href="#Android_u4E2D_u7684_u7C7B_u52A0_u8F7D_u5668" class="headerlink" title="Android中的类加载器"></a>Android中的类加载器</h3><p>Android应用通常是使用Java来开发的，也是运行在虚拟机Dalvik或ART上。虽然Android的虚拟机跟标准的Java虚拟机是不同的，但是类的加载机制都是类似的，即理论上Android也可以像Java程序一样，灵活地动态加载，如今大量的Android插件化、热更新框架都利用了此技术。</p>
<h4 id="Android_u4E2D_u7684_u51E0_u79CD_u7C7B_u52A0_u8F7D_u5668"><a href="#Android_u4E2D_u7684_u51E0_u79CD_u7C7B_u52A0_u8F7D_u5668" class="headerlink" title="Android中的几种类加载器"></a>Android中的几种类加载器</h4><p>在一个Android工程的Application中加入几行日志来打印下，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aspook.androidnotes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">        ClassLoader loader = getClassLoader();</span><br><span class="line">        <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.d(<span class="string">"ABC"</span>, <span class="string">"classLoader :"</span> + loader);</span><br><span class="line">            <span class="keyword">while</span> (loader.getParent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                loader = loader.getParent();</span><br><span class="line">                Log.d(<span class="string">"ABC"</span>, <span class="string">"classLoader :"</span> + loader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Android Studio中启动App后，依次输出3条Log如下：</p>
<blockquote>
<p>classLoader :dalvik.system.PathClassLoader[DexPathList[[zip file “/data/app/com.aspook.androidnotes-2/base.apk”],nativeLibraryDirectories=[/data/app/com.aspook.androidnotes-2/lib/arm64, /vendor/lib64, /system/lib64]]]<br>classLoader :com.android.tools.fd.runtime.IncrementalClassLoader@3faf711<br>classLoader :java.lang.BootClassLoader@d913983</p>
</blockquote>
<p>这里出现了3种ClassLoader，分别是：dalvik.system.PathClassLoader、com.android.tools.fd.runtime.IncrementalClassLoader、java.lang.BootClassLoader。第二个类加载器是用于Instant Run的，如果关闭Android Studio的Instant Run功能，再运行App则只会输出两种ClassLoader。</p>
<p>通过查看dalvik.system包下的源码，发现还有一种ClassLoader叫做DexClassLoader，稍后会介绍其用途。</p>
<h5 id="PathClassLoader"><a href="#PathClassLoader" class="headerlink" title="PathClassLoader"></a>PathClassLoader</h5><p>其官方说明如下：</p>
<blockquote>
<p>Provides a simple <code>ClassLoader</code> implementation that operates on a list of files and directories in the local file system, but does not attempt to load classes from the network. Android uses this class for its system class loader and for its application class loader(s).</p>
</blockquote>
<p>PathClassLoader是ClassLoader的简单实现且只能加载本地的列表文件或目录，在Android中也就是已安装好的APK，它不能加载来自网络的类。Android中的系统类加载器与应用类加载器都是PathClassLoader。</p>
<p>先来看其源码（7.0）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dalvik.system;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dalvik.system.BaseDexClassLoader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述源码可知其仅仅提供了两个构造方法，其中各参数的具体含义如下：</p>
<p>dexPath：包含dex文件的JAR/ZIP/APK文件的路径</p>
<p>librarySearchPath：native library文件的路径</p>
<p>parent：父类加载器</p>
<p>再来看BaseDexClassLoader的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dalvik.system;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> URL <span class="title">findResource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Enumeration&lt;URL&gt; <span class="title">findResources</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Package <span class="title">getPackage</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BaseDexClassLoader构造方法中有一个新的参数为optimizedDirectory，它表示优化后的dex文件要写入的路径，此处可以为null。</p>
<p>BaseDexClassLoader继承自java.lang.ClassLoader，它跟纯Java环境下的java.lang.ClassLoader还是有些不同的，虽然双亲委派的加载机制类似。</p>
<p>结合最初的Log输出可知，PathClassLoader只能加载”/data/app/com.aspook.androidnotes-2/base.apk”中的类，也就是已安装到手机中的APK，因此PathClassLoader作为默认的应用类加载器。</p>
<h5 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h5><p>其官方说明如下：</p>
<blockquote>
<p>A class loader that loads classes from <code>.jar</code> and <code>.apk</code> files containing a <code>classes.dex</code> entry. This can be used to execute code not installed as part of an application.</p>
</blockquote>
<p>DexClassLoader可以从包含dex文件的JAR或APK中来加载类，而这些代码源允许不必是安装应用的一部分，因此可用于动态加载。</p>
<p>先来看下DexClassLoader的源码（7.0）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dalvik.system;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dalvik.system.BaseDexClassLoader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它同样继承自BaseDexClassLoader，是java.lang.ClassLoader的子类，因此DexClassLoader与PathClassLoader都默认遵循双亲委派模型。</p>
<p>DexClassLoader构造方法中的参数，我们前文都已经提及，注意的一点是optimizedDirectory参数在这里不能为null。</p>
<p>与PathClassLoader不同，DexClassLoader则打破了PathClassLoader的局限，它可以加载已安装应用之外的APK、JAR或ZIP中的dex文件，通常建议使用如下路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File dexOutputDir = context.getCodeCacheDir();</span><br></pre></td></tr></table></figure>
<p>不建议使用外部存储，因为外部存储没有提供足够的访问权限控制，容易引发代码注入攻击。</p>
<p>因此，Android中实现动态插件通常是自定义继承自DexClassLoader的类加载器；如果插件为已安装的APK，则可以使用PathClassLoader。</p>
<h5 id="BootClassLoader"><a href="#BootClassLoader" class="headerlink" title="BootClassLoader"></a>BootClassLoader</h5><p>BootClassLoader直接继承自java.lang.ClassLoader，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BootClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BootClassLoader instance;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@FindBugsSuppressWarnings</span>(<span class="string">"DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> BootClassLoader <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> BootClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BootClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> Class.classForName(name, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> URL <span class="title">findResource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> VMClassLoader.getResource(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Enumeration&lt;URL&gt; <span class="title">findResources</span><span class="params">(String resName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.enumeration(VMClassLoader.getResources(resName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Package <span class="title">getPackage</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; !name.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                Package pack = <span class="keyword">super</span>.getPackage(name);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pack == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pack = definePackage(name, <span class="string">"Unknown"</span>, <span class="string">"0.0"</span>, <span class="string">"Unknown"</span>, <span class="string">"Unknown"</span>, <span class="string">"0.0"</span>,</span><br><span class="line">                            <span class="string">"Unknown"</span>, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> pack;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> URL <span class="title">getResource</span><span class="params">(String resName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findResource(resName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String className, <span class="keyword">boolean</span> resolve)</span><br><span class="line">           <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = findClass(className);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;URL&gt; <span class="title">getResources</span><span class="params">(String resName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findResources(resName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常在自定义类加载器时，都需要在构造方法中传入一个父加载器，而BootClassLoader的构造方法如下，没有传入parent，而是传入一个null：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BootClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此调用BootClassLoader的getParent方法时返回值为null。</p>
<p>BootClassLoader用来加载系统框架级别的类，例如Context.class.getClassLoader()与ListView.class.getClassLoader()的返回值类型均为BootClassLoader。</p>
<h5 id="u7CFB_u7EDF_u7C7B_u52A0_u8F7D_u5668"><a href="#u7CFB_u7EDF_u7C7B_u52A0_u8F7D_u5668" class="headerlink" title="系统类加载器"></a>系统类加载器</h5><p>当调用<code>ClassLoader.getSystemClassLoader()</code>这句代码时，会输出如下结果：</p>
<blockquote>
<p>dalvik.system.PathClassLoader[DexPathList[[directory “.”],nativeLibraryDirectories=[/vendor/lib64, /system/lib64]]]</p>
</blockquote>
<p>发现系统类加载器也是dalvik.system.PathClassLoader，与最初应用的类加载器（也是dalvik.system.PathClassLoader）不同的是DexPathList的路径不同。</p>
<p>跟踪一下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SystemClassLoader.loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ClassLoader loader = ClassLoader.createSystemClassLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Encapsulates the set of parallel capable loader types.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ClassLoader <span class="title">createSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String classPath = System.getProperty(<span class="string">"java.class.path"</span>, <span class="string">"."</span>);</span><br><span class="line">    String librarySearchPath = System.getProperty(<span class="string">"java.library.path"</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String[] paths = classPath.split(":");</span></span><br><span class="line">    <span class="comment">// URL[] urls = new URL[paths.length];</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; paths.length; i++) &#123;</span></span><br><span class="line">    <span class="comment">// try &#123;</span></span><br><span class="line">    <span class="comment">// urls[i] = new URL("file://" + paths[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// catch (Exception ex) &#123;</span></span><br><span class="line">    <span class="comment">// ex.printStackTrace();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// return new java.net.URLClassLoader(urls, null);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO Make this a java.net.URLClassLoader once we have those?</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而System.getProperty(“java.class.path”)返回值为“.”，似乎可以解释系统类加载器的DexPathList的路径了。</p>
<h4 id="Android_u4E2D_u7C7B_u52A0_u8F7D_u5668_u7684_u5C42_u6B21_u7ED3_u6784"><a href="#Android_u4E2D_u7C7B_u52A0_u8F7D_u5668_u7684_u5C42_u6B21_u7ED3_u6784" class="headerlink" title="Android中类加载器的层次结构"></a>Android中类加载器的层次结构</h4><p>与Java中类加载器的层次结构类似，具体如下图：</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/image/android_classloader.jpg" alt=""></p>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>本文简单介绍了类加载器的基本概念，罗列了Java及Android中常用的类加载器，并对各种类加载器的特点及功能做了说明，另外对类加载器的双亲委派机制做了详细讲解，对于Android插件化及热更新技术则不在本文的讨论之内，后续会继续分享。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://aspook.com/2017/03/07/Java类加载器及Android类加载器基础/" data-id="cj9jpl4zx004ym6xie42965tm" class="article-share-link">分享到</a><div class="tags"><a href="/tags/类加载器/">类加载器</a></div><div class="post-nav"><a href="/2017/03/16/RemoteViews原理分析及应用/" class="pre">RemoteViews原理分析及应用</a><a href="/2017/02/25/一种Android应用架构设计分享/" class="next">一种Android应用架构设计分享</a></div><div id="disqus_thread"><script>var disqus_shortname = 'aspook';
var disqus_identifier = '2017/03/07/Java类加载器及Android类加载器基础/';
var disqus_title = 'Java类加载器及Android类加载器基础';
var disqus_url = 'http://aspook.com/2017/03/07/Java类加载器及Android类加载器基础/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//aspook.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://aspook.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithms/">Algorithms</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/GIS/">GIS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈/">杂谈</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/通信/" style="font-size: 15px;">通信</a> <a href="/tags/APK瘦身/" style="font-size: 15px;">APK瘦身</a> <a href="/tags/微信支付/" style="font-size: 15px;">微信支付</a> <a href="/tags/微信wap支付/" style="font-size: 15px;">微信wap支付</a> <a href="/tags/微信网页支付/" style="font-size: 15px;">微信网页支付</a> <a href="/tags/诗词/" style="font-size: 15px;">诗词</a> <a href="/tags/历史/" style="font-size: 15px;">历史</a> <a href="/tags/Web地图/" style="font-size: 15px;">Web地图</a> <a href="/tags/矢量渲染/" style="font-size: 15px;">矢量渲染</a> <a href="/tags/切片地图/" style="font-size: 15px;">切片地图</a> <a href="/tags/栅格地图/" style="font-size: 15px;">栅格地图</a> <a href="/tags/Java泛型/" style="font-size: 15px;">Java泛型</a> <a href="/tags/clone/" style="font-size: 15px;">clone</a> <a href="/tags/对象克隆/" style="font-size: 15px;">对象克隆</a> <a href="/tags/Android线程/" style="font-size: 15px;">Android线程</a> <a href="/tags/线程通信/" style="font-size: 15px;">线程通信</a> <a href="/tags/AsyncTask/" style="font-size: 15px;">AsyncTask</a> <a href="/tags/工具类/" style="font-size: 15px;">工具类</a> <a href="/tags/公有构造函数/" style="font-size: 15px;">公有构造函数</a> <a href="/tags/诗歌/" style="font-size: 15px;">诗歌</a> <a href="/tags/65536/" style="font-size: 15px;">65536</a> <a href="/tags/64K-method/" style="font-size: 15px;">64K method</a> <a href="/tags/App安全/" style="font-size: 15px;">App安全</a> <a href="/tags/gradle/" style="font-size: 15px;">gradle</a> <a href="/tags/build加速/" style="font-size: 15px;">build加速</a> <a href="/tags/Intent/" style="font-size: 15px;">Intent</a> <a href="/tags/垃圾收集算法/" style="font-size: 15px;">垃圾收集算法</a> <a href="/tags/在南下的火车上/" style="font-size: 15px;">在南下的火车上</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/第三方框架/" style="font-size: 15px;">第三方框架</a> <a href="/tags/Android适配/" style="font-size: 15px;">Android适配</a> <a href="/tags/Context/" style="font-size: 15px;">Context</a> <a href="/tags/二叉树/" style="font-size: 15px;">二叉树</a> <a href="/tags/二叉树遍历/" style="font-size: 15px;">二叉树遍历</a> <a href="/tags/深度优先遍历/" style="font-size: 15px;">深度优先遍历</a> <a href="/tags/广度优先遍历/" style="font-size: 15px;">广度优先遍历</a> <a href="/tags/非递归实现/" style="font-size: 15px;">非递归实现</a> <a href="/tags/移动架构/" style="font-size: 15px;">移动架构</a> <a href="/tags/Android架构设计/" style="font-size: 15px;">Android架构设计</a> <a href="/tags/分包策略/" style="font-size: 15px;">分包策略</a> <a href="/tags/so文件/" style="font-size: 15px;">so文件</a> <a href="/tags/PIC/" style="font-size: 15px;">PIC</a> <a href="/tags/text-relocation/" style="font-size: 15px;">text relocation</a> <a href="/tags/AndroidManifest/" style="font-size: 15px;">AndroidManifest</a> <a href="/tags/activity-alias/" style="font-size: 15px;">activity-alias</a> <a href="/tags/瓦片地图/" style="font-size: 15px;">瓦片地图</a> <a href="/tags/远程视图/" style="font-size: 15px;">远程视图</a> <a href="/tags/AppWidget/" style="font-size: 15px;">AppWidget</a> <a href="/tags/Messenger/" style="font-size: 15px;">Messenger</a> <a href="/tags/进程间通信/" style="font-size: 15px;">进程间通信</a> <a href="/tags/如何看待与学习新技术/" style="font-size: 15px;">如何看待与学习新技术</a> <a href="/tags/本地广播/" style="font-size: 15px;">本地广播</a> <a href="/tags/LRU/" style="font-size: 15px;">LRU</a> <a href="/tags/类加载器/" style="font-size: 15px;">类加载器</a> <a href="/tags/对象创建/" style="font-size: 15px;">对象创建</a> <a href="/tags/内存分配/" style="font-size: 15px;">内存分配</a> <a href="/tags/访问定位/" style="font-size: 15px;">访问定位</a> <a href="/tags/Java内存模型/" style="font-size: 15px;">Java内存模型</a> <a href="/tags/线程/" style="font-size: 15px;">线程</a> <a href="/tags/JVM内存模型/" style="font-size: 15px;">JVM内存模型</a> <a href="/tags/Java内存分配/" style="font-size: 15px;">Java内存分配</a> <a href="/tags/Hybrid框架通信/" style="font-size: 15px;">Hybrid框架通信</a> <a href="/tags/Bundle/" style="font-size: 15px;">Bundle</a> <a href="/tags/源码解析/" style="font-size: 15px;">源码解析</a> <a href="/tags/内存优化/" style="font-size: 15px;">内存优化</a> <a href="/tags/高性能编码/" style="font-size: 15px;">高性能编码</a> <a href="/tags/AIDL/" style="font-size: 15px;">AIDL</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Android消息机制源码解析/" style="font-size: 15px;">Android消息机制源码解析</a> <a href="/tags/MessageQueue/" style="font-size: 15px;">MessageQueue</a> <a href="/tags/Handler/" style="font-size: 15px;">Handler</a> <a href="/tags/Looper/" style="font-size: 15px;">Looper</a> <a href="/tags/Message/" style="font-size: 15px;">Message</a> <a href="/tags/Android架构组件/" style="font-size: 15px;">Android架构组件</a> <a href="/tags/Android文件存储/" style="font-size: 15px;">Android文件存储</a> <a href="/tags/内部存储/" style="font-size: 15px;">内部存储</a> <a href="/tags/外部存储/" style="font-size: 15px;">外部存储</a> <a href="/tags/微信分享/" style="font-size: 15px;">微信分享</a> <a href="/tags/分享闭环/" style="font-size: 15px;">分享闭环</a> <a href="/tags/开发经验/" style="font-size: 15px;">开发经验</a> <a href="/tags/Android书籍推荐/" style="font-size: 15px;">Android书籍推荐</a> <a href="/tags/App生命周期/" style="font-size: 15px;">App生命周期</a> <a href="/tags/Android架构/" style="font-size: 15px;">Android架构</a> <a href="/tags/快捷方式/" style="font-size: 15px;">快捷方式</a> <a href="/tags/shortcut/" style="font-size: 15px;">shortcut</a> <a href="/tags/Broadcast/" style="font-size: 15px;">Broadcast</a> <a href="/tags/Android广播/" style="font-size: 15px;">Android广播</a> <a href="/tags/Android布局性能优化/" style="font-size: 15px;">Android布局性能优化</a> <a href="/tags/Android图片缓存/" style="font-size: 15px;">Android图片缓存</a> <a href="/tags/全面屏适配/" style="font-size: 15px;">全面屏适配</a> <a href="/tags/Window/" style="font-size: 15px;">Window</a> <a href="/tags/Android-Studio/" style="font-size: 15px;">Android Studio</a> <a href="/tags/Instant-Run/" style="font-size: 15px;">Instant Run</a> <a href="/tags/Instrumentation/" style="font-size: 15px;">Instrumentation</a> <a href="/tags/activity启动流程/" style="font-size: 15px;">activity启动流程</a> <a href="/tags/choreographer/" style="font-size: 15px;">choreographer</a> <a href="/tags/丢帧/" style="font-size: 15px;">丢帧</a> <a href="/tags/帧率/" style="font-size: 15px;">帧率</a> <a href="/tags/卡顿监控/" style="font-size: 15px;">卡顿监控</a> <a href="/tags/性能监控/" style="font-size: 15px;">性能监控</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/11/01/Android-Choreographer/">Android Choreographer</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/12/LocalBroadcastManager原理分析及应用/">LocalBroadcastManager原理分析及应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/15/Java对象创建、内存分配、访问定位概述/">Java对象创建、内存分配、访问定位概述</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/08/Hybrid框架之交互通信篇/">Hybrid框架之交互通信篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/06/Android应用快捷方式/">Android应用快捷方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/15/Android架构组件/">Android架构组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/10/业内移动App架构参考/">业内移动App架构参考</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/08/Android全面屏适配/">Android全面屏适配</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/07/Android应用架构/">Android应用架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/13/一种Android分包策略推荐/">一种Android分包策略推荐</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//aspook.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.csdn.net/ahence" title="aspook" target="_blank">aspook</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">ASPOOK.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
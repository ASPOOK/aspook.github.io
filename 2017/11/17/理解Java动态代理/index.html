<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="请不要灰心，你也会有人妒忌"><title>理解Java动态代理 | ASPOOK</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">理解Java动态代理</h1><a id="logo" href="/.">ASPOOK</a><p class="description">Serendipity</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">理解Java动态代理</h1><div class="post-meta">Nov 17, 2017<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2017/11/17/理解Java动态代理/" href="/2017/11/17/理解Java动态代理/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><h3 id="u6982_u5FF5_u7406_u89E3"><a href="#u6982_u5FF5_u7406_u89E3" class="headerlink" title="概念理解"></a>概念理解</h3><p>动态代理类就是在运行时创建的实现了一系列特定接口的类。</p>
<p>为了更好行文，还需要先明确三个概念：</p>
<ol>
<li>代理类——在本文中指动态代理类</li>
<li>代理接口——在本文中指动态代理类实现的接口</li>
<li>代理实例——在本文中指动态代理类的一个实例</li>
</ol>
<p>动态代理的一些特性：</p>
<ol>
<li>代理类是<code>public</code>或<code>final</code>的，不能是<code>abstract</code></li>
<li>代理类均继承自<code>java.lang.reflect.Proxy</code>类</li>
<li>代理类在创建时按顺序实现了所指定的接口</li>
<li>代理类的名称前缀为<code>$Proxy</code></li>
<li>代理类有一个<code>public</code>构造函数，参数为实现了<code>InvocationHandler</code>的对象</li>
<li>每个代理实例都有一个指定的调用处理器<code>InvocationHandler</code>，<code>InvocationHandler</code>作为其构造函数的参数传入</li>
<li>代理实例的方法调用会触发<code>InvocationHandler</code>接口的<code>invoke</code>方法</li>
</ol>
<h3 id="u6E90_u7801_u7B80_u6790"><a href="#u6E90_u7801_u7B80_u6790" class="headerlink" title="源码简析"></a>源码简析</h3><h4 id="Proxy_u7C7B_u6982_u89C8"><a href="#Proxy_u7C7B_u6982_u89C8" class="headerlink" title="Proxy类概览"></a>Proxy类概览</h4><p><code>Proxy</code>类位于<code>java.lang.reflect</code>包中，本文以Android SDK中的<code>Proxy</code>类来分析，与Java SDK中的<code>Proxy</code>可能稍有不同。</p>
<p><code>Proxy</code>提供了一些静态方法用来生成动态代理类及其实例，同时<code>Proxy</code>类是这些动态代理类的父类。</p>
<p><code>Proxy</code>的主要变量如下，具体请看注释说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 代理类名称前缀 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 代理类构造函数的参数类型*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Class[] constructorParams =</span><br><span class="line">    &#123; InvocationHandler.class &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 类加载器与对应的代理类缓存映射 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;ClassLoader, Map&lt;List&lt;String&gt;, Object&gt;&gt; loaderToCache</span><br><span class="line">    = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 标记某个特定的代理类正在生成 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object pendingGenerationMarker = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** next number to use for generation of unique proxy class names */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> nextUniqueNumber = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object nextUniqueNumberLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 所有代理类的存储集合，在isProxyClass方法中会用到 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Void&gt; proxyClasses =</span><br><span class="line">    Collections.synchronizedMap(<span class="keyword">new</span> WeakHashMap&lt;Class&lt;?&gt;, Void&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 代理类实例的调用处理器</span><br><span class="line"> * <span class="doctag">@serial</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">protected</span> InvocationHandler h;</span><br></pre></td></tr></table></figure>
<p>检查某个特定类是否为动态代理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> proxyClasses.containsKey(cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到用到了上面定义的<code>proxyClasses</code>。</p>
<p>获取代理实例的调用处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InvocationHandler <span class="title">getInvocationHandler</span><span class="params">(Object proxy)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Verify that the object is actually a proxy instance.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!(proxy <span class="keyword">instanceof</span> Proxy)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"not a proxy instance"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((Proxy) proxy).h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Proxy</code>类本身还有一个<code>invoke</code>方法：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">static</span> <span class="type">Object</span> invoke(<span class="type">Proxy</span> proxy, <span class="type">Method</span> <span class="keyword">method</span>, <span class="type">Object</span>[] args) throws <span class="type">Throwable</span> &#123;</span><br><span class="line">    <span class="type">InvocationHandler</span> h = proxy.h;</span><br><span class="line">    <span class="keyword">return</span> h.invoke(proxy, <span class="keyword">method</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他<code>Proxy</code>提供的方法在“动态代理的使用流程分析”一节细说。</p>
<h4 id="InvocationHandler_u63A5_u53E3"><a href="#InvocationHandler_u63A5_u53E3" class="headerlink" title="InvocationHandler接口"></a>InvocationHandler接口</h4><p>接下来看一下上面多次提到的<code>InvocationHandler</code>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * &#123;<span class="doctag">@code</span> InvocationHandler&#125; is the interface implemented by</span><br><span class="line"> * the &lt;i&gt;invocation handler&lt;/i&gt; of a proxy instance.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Each proxy instance has an associated invocation handler.</span><br><span class="line"> * When a method is invoked on a proxy instance, the method</span><br><span class="line"> * invocation is encoded and dispatched to the &#123;<span class="doctag">@code</span> invoke&#125;</span><br><span class="line"> * method of its invocation handler.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Processes a method invocation on a proxy instance and returns</span><br><span class="line">     * the result.  This method will be invoked on an invocation handler</span><br><span class="line">     * when a method is invoked on a proxy instance that it is</span><br><span class="line">     * associated with.</span><br><span class="line">     */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释写的非常清楚，每个代理实例都有一个<code>InvocationHandler</code>对象，实例方法调用时会触发该接口的<code>invoke</code>方法，并返回结果。<code>invoke</code>方法的三个参数分别为代理实例、方法实例（此处的方法实质是代理接口中所定义的方法）、方法参数。</p>
<p>通常我们会自定义一个类实现<code>InvocationHandler</code>接口，如上文示例中的<code>MyInvocationHandler</code>。</p>
<h4 id="u52A8_u6001_u4EE3_u7406_u7684_u4F7F_u7528_u6D41_u7A0B_u5206_u6790"><a href="#u52A8_u6001_u4EE3_u7406_u7684_u4F7F_u7528_u6D41_u7A0B_u5206_u6790" class="headerlink" title="动态代理的使用流程分析"></a>动态代理的使用流程分析</h4><p>官方文档给出的生成动态代理类的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.为Foo接口生成动态代理类的步骤</span></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(...);</span><br><span class="line">Class proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(), <span class="keyword">new</span> Class[] &#123; Foo.class &#125;);</span><br><span class="line">Foo f = (Foo) proxyClass.getConstructor(<span class="keyword">new</span> Class[] &#123; InvocationHandler.class &#125;).newInstance(<span class="keyword">new</span> Object[] &#123; handler &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.更简单的一种调用方式，实际上是对上面几步的整合</span></span><br><span class="line">Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(), <span class="keyword">new</span> Class[] &#123; Foo.class &#125;, handler);</span><br></pre></td></tr></table></figure>
<p>根据上述两种使用方式，我们来跟踪一下源码。</p>
<p>先看<code>getProxyClass</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader,</span><br><span class="line">                                     Class&lt;?&gt;... interfaces)</span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getProxyClass0(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法获取一个代理类，参数传入一个类加载器和一个接口数组，最终调到<code>getProxyClass0(ClassLoader loader,                                       Class&lt;?&gt;... interfaces)</code>，稍后再来看这个方法的具体实现。</p>
<p>上面得到代理类之后通过<code>getConstructor</code>得到其构造方法，上面说过代理类有一个<code>public</code>构造函数，参数为实现了<code>InvocationHandler</code>的对象，得到构造函数后，然后调用<code>newInstance</code>得到一个代理实例，并将其转为对应的接口对象。</p>
<p>再看第2种简单的实现方式，<code>Proxy.newProxyInstance</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span><br><span class="line">                                      Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                      InvocationHandler h)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 先检验调用处理器</span></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * 获取代理类，也是通过调用getProxyClass0</span><br><span class="line">     */</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, interfaces);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Invoke its constructor with the designated invocation handler.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取构造函数</span></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">return</span> newInstance(cons, h);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>newInstance(cons, h)</code>的实现为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Constructor&lt;?&gt; cons, InvocationHandler h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 最终还是走Constructor的newInstance方法</span></span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[] &#123;h&#125; );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        Throwable t = e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两种方式本质都是一样的，只不过第2种方式对用户使用来说更加简单。</p>
<p>上述两种方式的流程很清楚，接下来看最关键的地方，即动态代理类的生成过程，主要是<code>getProxyClass0</code>的实现，其源码较长，具体看注释吧，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="comment">// 校验接口数组的长度</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; proxyClass = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* collect interface names to use as key for proxy class cache */</span></span><br><span class="line">    <span class="comment">// 用于存储代理类实现的所有接口的名称</span></span><br><span class="line">    String[] interfaceNames = <span class="keyword">new</span> String[interfaces.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for detecting duplicates</span></span><br><span class="line">    <span class="comment">// 存储不重复的接口类对象</span></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; interfaceSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历所有接口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * Verify that the class loader resolves the name of this</span><br><span class="line">         * interface to the same Class object.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="comment">// 接口名</span></span><br><span class="line">        String interfaceName = interfaces[i].getName();</span><br><span class="line">        Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过接口名及类加载器得到一个接口类对象</span></span><br><span class="line">            interfaceClass = Class.forName(interfaceName, <span class="keyword">false</span>, loader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校验</span></span><br><span class="line">        <span class="keyword">if</span> (interfaceClass != interfaces[i]) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                interfaces[i] + <span class="string">" is not visible from class loader"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * Verify that the Class object actually represents an</span><br><span class="line">         * interface.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="comment">// 校验得到的类是否为接口类型</span></span><br><span class="line">        <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * Verify that this interface is not a duplicate.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="comment">// 校验接口是否重复，不重复的话加入集合</span></span><br><span class="line">        <span class="keyword">if</span> (interfaceSet.contains(interfaceClass)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">"repeated interface: "</span> + interfaceClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        interfaceSet.add(interfaceClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储接口名称到数组</span></span><br><span class="line">        interfaceNames[i] = interfaceName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Using string representations of the proxy interfaces as</span><br><span class="line">     * keys in the proxy class cache (instead of their Class</span><br><span class="line">     * objects) is sufficient because we require the proxy</span><br><span class="line">     * interfaces to be resolvable by name through the supplied</span><br><span class="line">     * class loader, and it has the advantage that using a string</span><br><span class="line">     * representation of a class makes for an implicit weak</span><br><span class="line">     * reference to the class.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">// 上面已经有英文注释了，简单解释一下：使用字符串作(代理接口的名称)作为代理类缓存的key是足够的，因为我们使用类加载器加载时也是使用名称，使用字符串的另一个优势是它对类是隐式的弱引用。</span></span><br><span class="line">    List&lt;String&gt; key = Arrays.asList(interfaceNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Find or create the proxy class cache for the class loader.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">// 为类加载器查找或创建代理类缓存</span></span><br><span class="line">    Map&lt;List&lt;String&gt;, Object&gt; cache;</span><br><span class="line">    <span class="keyword">synchronized</span> (loaderToCache) &#123;</span><br><span class="line">        cache = loaderToCache.get(loader);</span><br><span class="line">        <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            loaderToCache.put(loader, cache);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * This mapping will remain valid for the duration of this</span><br><span class="line">         * method, without further synchronization, because the mapping</span><br><span class="line">         * will only be removed if the class loader becomes unreachable.</span><br><span class="line">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Look up the list of interfaces in the proxy class cache using</span><br><span class="line">     * the key.  This lookup will result in one of three possible</span><br><span class="line">     * kinds of values:</span><br><span class="line">     *     null, if there is currently no proxy class for the list of</span><br><span class="line">     *         interfaces in the class loader,</span><br><span class="line">     *     the pendingGenerationMarker object, if a proxy class for the</span><br><span class="line">     *         list of interfaces is currently being generated,</span><br><span class="line">     *     or a weak reference to a Class object, if a proxy class for</span><br><span class="line">     *         the list of interfaces has already been generated.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">// 3种查找结果：(1)null(2)pendingGenerationMarker对象(3)一个类对象的弱引用</span></span><br><span class="line">    <span class="keyword">synchronized</span> (cache) &#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * Note that we need not worry about reaping the cache for</span><br><span class="line">         * entries with cleared weak references because if a proxy class</span><br><span class="line">         * has been garbage collected, its class loader will have been</span><br><span class="line">         * garbage collected as well, so the entire cache will be reaped</span><br><span class="line">         * from the loaderToCache map.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="comment">// 如果一个代理类被GC了，它对应的类加载器也会被GC</span></span><br><span class="line">        do &#123;</span><br><span class="line">            Object value = cache.get(key);</span><br><span class="line">            <span class="comment">// 结果1：返回弱引用，从中得到代理类</span></span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Reference) &#123;</span><br><span class="line">                proxyClass = (Class&lt;?&gt;) ((Reference) value).get();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (proxyClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// proxy class already generated: return it</span></span><br><span class="line">                <span class="comment">// 代理类已经生成，并返回</span></span><br><span class="line">                <span class="keyword">return</span> proxyClass;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value == pendingGenerationMarker) &#123;</span><br><span class="line">                <span class="comment">// 结果2：返回pendingGenerationMarker，表示代理类正在生成</span></span><br><span class="line">                <span class="comment">// proxy class being generated: wait for it</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cache.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">/*</span><br><span class="line">                     * The class generation that we are waiting for should</span><br><span class="line">                     * take a small, bounded time, so we can safely ignore</span><br><span class="line">                     * thread interrupts here.</span><br><span class="line">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 结果3：返回null，表示目前还没生成代理类，先在缓存中存储一个标记</span></span><br><span class="line">                <span class="comment">/*</span><br><span class="line">                 * No proxy class for this list of interfaces has been</span><br><span class="line">                 * generated or is being generated, so we will go and</span><br><span class="line">                 * generate it now.  Mark it as pending generation.</span><br><span class="line">                 */</span></span><br><span class="line">                cache.put(key, pendingGenerationMarker);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 代理类的包名</span></span><br><span class="line">        String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// package to define proxy class in</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * Record the package of a non-public proxy interface so that the</span><br><span class="line">         * proxy class will be defined in the same package.  Verify that</span><br><span class="line">         * all non-public proxy interfaces are in the same package.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="comment">// 如果为非公有接口，则代理类与代理接口在同一个包内</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> flags = interfaces[i].getModifiers();</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                String name = interfaces[i].getName();</span><br><span class="line">                <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">                <span class="comment">// 举个列子，如果name=com.abc.Testinterface,则pkg=com.abc.</span></span><br><span class="line">                String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    proxyPkg = pkg;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// if no non-public proxy interfaces, use the default package.</span></span><br><span class="line">            <span class="comment">// 默认包名为com.sun.proxy</span></span><br><span class="line">            proxyPkg = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Android-changed: Generate the proxy directly instead of calling</span></span><br><span class="line">            <span class="comment">// through to ProxyGenerator.</span></span><br><span class="line">            <span class="comment">// 请注意上面注释，Android中有变动，直接调用Native方法生成代理类而不是通过ProxyGenerator</span></span><br><span class="line">            <span class="comment">// 下面方法通过递归获取接口中的所有方法</span></span><br><span class="line">            List&lt;Method&gt; methods = getMethods(interfaces);</span><br><span class="line">            <span class="comment">// 根据前面及类型排序</span></span><br><span class="line">            Collections.sort(methods, ORDER_BY_SIGNATURE_AND_SUBTYPE);</span><br><span class="line">            <span class="comment">// 对方法返回类型进行校验，Throws if any two methods in &#123;@code methods&#125; have the same name and parameters but incompatible return types.</span></span><br><span class="line">            validateReturnTypes(methods);</span><br><span class="line">            <span class="comment">// Remove methods that have the same name, parameters and return type. This computes the exceptions of each method; this is the intersection of the exceptions of equivalent methods.</span></span><br><span class="line">            List&lt;Class&lt;?&gt;[]&gt; exceptions = deduplicateAndGetExceptions(methods);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 转成方法数组</span></span><br><span class="line">            Method[] methodsArray = methods.toArray(<span class="keyword">new</span> Method[methods.size()]);</span><br><span class="line">            Class&lt;?&gt;[][] exceptionsArray = exceptions.toArray(<span class="keyword">new</span> Class&lt;?&gt;[exceptions.size()][]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span><br><span class="line">             * Choose a name for the proxy class to generate.</span><br><span class="line">             */</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> num;</span><br><span class="line">            <span class="keyword">synchronized</span> (nextUniqueNumberLock) &#123;</span><br><span class="line">                num = nextUniqueNumber++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 生成的动态代理类名，如com.sun.proxy.$Proxy0，com.sun.proxy.$Proxy1，com.sun.proxy.$Proxy2</span></span><br><span class="line">            String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// generateProxy为Native方法</span></span><br><span class="line">            proxyClass = generateProxy(proxyName, interfaces, loader, methodsArray,</span><br><span class="line">                    exceptionsArray);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// add to set of all generated proxy classes, for isProxyClass</span></span><br><span class="line">        proxyClasses.put(proxyClass, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * We must clean up the "pending generation" state of the proxy</span><br><span class="line">         * class cache entry somehow.  If a proxy class was successfully</span><br><span class="line">         * generated, store it in the cache (with a weak reference);</span><br><span class="line">         * otherwise, remove the reserved entry.  In all cases, notify</span><br><span class="line">         * all waiters on reserved entries in this cache.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="comment">// 代理类生成之后，清除之前Cache中的标记状态，并将其以弱引用的方式保存</span></span><br><span class="line">        <span class="keyword">synchronized</span> (cache) &#123;</span><br><span class="line">            <span class="keyword">if</span> (proxyClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cache.put(key, <span class="keyword">new</span> WeakReference&lt;Class&lt;?&gt;&gt;(proxyClass));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cache.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 唤醒前面cache.wait()</span></span><br><span class="line">            cache.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回动态代理类</span></span><br><span class="line">    <span class="keyword">return</span> proxyClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u52A8_u6001_u4EE3_u7406_u793A_u4F8B"><a href="#u52A8_u6001_u4EE3_u7406_u793A_u4F8B" class="headerlink" title="动态代理示例"></a>动态代理示例</h3><h4 id="u793A_u4F8B1"><a href="#u793A_u4F8B1" class="headerlink" title="示例1"></a>示例1</h4><p>先定义一个代理接口，描述如何”上网冲浪“：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aspook.dynamicproxy2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SurfInternet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">surf</span><span class="params">(String content)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再定义一个委托类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Normal</span> <span class="keyword">implements</span> <span class="title">SurfInternet</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surf</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"上网： "</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个自定义的<code>InvocationHandler</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VPNInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SurfInternet base;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VPNInvocationHandler</span><span class="params">(SurfInternet obj)</span> </span>&#123;</span><br><span class="line">        base = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"invoke start"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 会调用委托类的对应方法，从而实现代理</span></span><br><span class="line">        method.invoke(base, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"invoke end"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 被代理类，或叫做委托类</span></span><br><span class="line">        Normal normal = <span class="keyword">new</span> Normal();</span><br><span class="line">        InvocationHandler h = <span class="keyword">new</span> VPNInvocationHandler(normal);</span><br><span class="line">        SurfInternet vpn = (SurfInternet) Proxy.newProxyInstance(normal.getClass().getClassLoader(),</span><br><span class="line">                normal.getClass().getInterfaces(),</span><br><span class="line">                h);</span><br><span class="line"></span><br><span class="line">        vpn.surf(<span class="string">"VPN方式，可以访问Google了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>invoke start<br>上网： VPN方式，可以访问Google了<br>invoke end</p>
</blockquote>
<p>注意第2行的输出，实质上是被代理类的功能，代理类一般用于不想将被代理类暴露出去，而是转用代理类来实现被代理类的功能，即所谓的代理。在上面的例子有一个被代理类<code>Normal</code>，与静态代理模式相比（本质上是代理类持有一个被代理类的实例，代理类与被代理类均实现相同接口），动态代理在运行时才会生成。</p>
<h4 id="u793A_u4F8B2"><a href="#u793A_u4F8B2" class="headerlink" title="示例2"></a>示例2</h4><p>先定义一个代理接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aspook.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String content)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意此接口为<code>public</code>，位于<code>com.aspook.dynamicproxy</code>包下，按上文分析，生成的动态代理类应该位于默认包中，包名为<code>com.sun.proxy</code>，稍后验证。</p>
<p>再来实现一个逻辑类<code>ProxyClassTest</code>，具体请看注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InvocationHandler h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个InvocationHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareInvocationHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        h = <span class="keyword">new</span> MyInvocationHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有一个代理接口示例</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;service&#125;, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里有两个代理接口，GoodService代表另一个接口，源码未给出</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(HelloService.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;HelloService.class, GoodService.class&#125;, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理实例方法调用触发invoke回调后可执行的个人逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doLogic</span><span class="params">(String firstArg)</span> </span>&#123;</span><br><span class="line">        System.out.println(firstArg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// InvocationHandler的实现类，当然也可以用匿名内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"invoke"</span>);</span><br><span class="line">            System.out.println(<span class="string">"proxy: "</span> + proxy.getClass());</span><br><span class="line">            System.out.println(<span class="string">"method: "</span> + method.getName());</span><br><span class="line">            System.out.println(<span class="string">"args length: "</span> + args.length);</span><br><span class="line">            <span class="comment">// 由于只是示例，仅供说明，因此下面两行未做越界校验</span></span><br><span class="line">            System.out.println(<span class="string">"args : "</span> + args[<span class="number">0</span>].toString());</span><br><span class="line">            doLogic(args[<span class="number">0</span>].toString());</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 注意返回值要跟接口方法返回值相对应</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后看下调用类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProxyClassTest test = <span class="keyword">new</span> ProxyClassTest();</span><br><span class="line">        test.prepareInvocationHandler();</span><br><span class="line">        HelloService service = test.create();</span><br><span class="line">        service.sayHello(<span class="string">"hahaha"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终输入结果如下：</p>
<blockquote>
<p>invoke<br>proxy: class com.sun.proxy.$Proxy0<br>method: sayHello<br>args length: 1<br>args : hahaha<br>custom logic: hahaha</p>
</blockquote>
<p>由输出结果可以看到代理全路径名称为<code>com.sun.proxy.$Proxy0</code>，跟前文中的理论一致，同时可以得到方法名和方法参数，并可执行自定义逻辑。</p>
<p>此示例并没有实现被代理类，多个接口的响应均统一在<code>invoke</code>中处理，然后实现具体逻辑，而不必像静态代理那样单独实现每一个接口。<a href="https://github.com/square/retrofit" target="_blank" rel="external">Retrofit</a>也是利用了此原理。</p>
<p><strong>注意事项</strong>：</p>
<ol>
<li><p>如果代理接口有多个，如下面代码有<code>HelloService</code>和<code>GoodService</code>两个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(HelloService.class.getClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> Class[]&#123;HelloService.class, GoodService.class&#125;, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要有一个接口为非<code>public</code>的，则生成的动态代理类就跟接口同包，如<code>com.aspook.dynamicproxy.$Proxy0</code>。</p>
</li>
<li><p>如果多个接口返回类型不同，可以在<code>invoke</code>中根据方法的返回类型来<code>return</code>不同的值。</p>
</li>
<li><p>如果跨包引用一个代理接口，则该接口必然为<code>public</code>的，如果只有这一个接口则动态代理类位于默认包中；如果还有其他同包的代理接口，只要有一个为非<code>public</code>的，则生成的动态代理类就跟非<code>public</code>的接口同包，如果无论跨包同包所有接口均为public，则生成的动态代理类在默认包中。</p>
</li>
<li><p>由于动态代理类本身已经继承了<code>Proxy</code>，根据Java单继承的限制，因此只能实现多个接口了。</p>
</li>
</ol>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://aspook.com/2017/11/17/理解Java动态代理/" data-id="cja3ajcqf001dh5xio9c2a1mx" class="article-share-link">分享到</a><div class="tags"><a href="/tags/动态代理/">动态代理</a></div><div class="post-nav"><a href="/2017/11/10/Javac编译过程笔记/" class="next">Javac编译过程笔记</a></div><div id="disqus_thread"><script>var disqus_shortname = 'aspook';
var disqus_identifier = '2017/11/17/理解Java动态代理/';
var disqus_title = '理解Java动态代理';
var disqus_url = 'http://aspook.com/2017/11/17/理解Java动态代理/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//aspook.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://aspook.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithms/">Algorithms</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/GIS/">GIS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈/">杂谈</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/通信/" style="font-size: 15px;">通信</a> <a href="/tags/APK瘦身/" style="font-size: 15px;">APK瘦身</a> <a href="/tags/微信支付/" style="font-size: 15px;">微信支付</a> <a href="/tags/微信wap支付/" style="font-size: 15px;">微信wap支付</a> <a href="/tags/微信网页支付/" style="font-size: 15px;">微信网页支付</a> <a href="/tags/诗词/" style="font-size: 15px;">诗词</a> <a href="/tags/历史/" style="font-size: 15px;">历史</a> <a href="/tags/Web地图/" style="font-size: 15px;">Web地图</a> <a href="/tags/矢量渲染/" style="font-size: 15px;">矢量渲染</a> <a href="/tags/切片地图/" style="font-size: 15px;">切片地图</a> <a href="/tags/栅格地图/" style="font-size: 15px;">栅格地图</a> <a href="/tags/Java泛型/" style="font-size: 15px;">Java泛型</a> <a href="/tags/clone/" style="font-size: 15px;">clone</a> <a href="/tags/对象克隆/" style="font-size: 15px;">对象克隆</a> <a href="/tags/动态代理/" style="font-size: 15px;">动态代理</a> <a href="/tags/Android线程/" style="font-size: 15px;">Android线程</a> <a href="/tags/线程通信/" style="font-size: 15px;">线程通信</a> <a href="/tags/AsyncTask/" style="font-size: 15px;">AsyncTask</a> <a href="/tags/工具类/" style="font-size: 15px;">工具类</a> <a href="/tags/公有构造函数/" style="font-size: 15px;">公有构造函数</a> <a href="/tags/诗歌/" style="font-size: 15px;">诗歌</a> <a href="/tags/65536/" style="font-size: 15px;">65536</a> <a href="/tags/64K-method/" style="font-size: 15px;">64K method</a> <a href="/tags/App安全/" style="font-size: 15px;">App安全</a> <a href="/tags/gradle/" style="font-size: 15px;">gradle</a> <a href="/tags/build加速/" style="font-size: 15px;">build加速</a> <a href="/tags/Intent/" style="font-size: 15px;">Intent</a> <a href="/tags/垃圾收集算法/" style="font-size: 15px;">垃圾收集算法</a> <a href="/tags/在南下的火车上/" style="font-size: 15px;">在南下的火车上</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/第三方框架/" style="font-size: 15px;">第三方框架</a> <a href="/tags/Android适配/" style="font-size: 15px;">Android适配</a> <a href="/tags/Context/" style="font-size: 15px;">Context</a> <a href="/tags/二叉树/" style="font-size: 15px;">二叉树</a> <a href="/tags/二叉树遍历/" style="font-size: 15px;">二叉树遍历</a> <a href="/tags/深度优先遍历/" style="font-size: 15px;">深度优先遍历</a> <a href="/tags/广度优先遍历/" style="font-size: 15px;">广度优先遍历</a> <a href="/tags/非递归实现/" style="font-size: 15px;">非递归实现</a> <a href="/tags/移动架构/" style="font-size: 15px;">移动架构</a> <a href="/tags/Android架构设计/" style="font-size: 15px;">Android架构设计</a> <a href="/tags/分包策略/" style="font-size: 15px;">分包策略</a> <a href="/tags/so文件/" style="font-size: 15px;">so文件</a> <a href="/tags/PIC/" style="font-size: 15px;">PIC</a> <a href="/tags/text-relocation/" style="font-size: 15px;">text relocation</a> <a href="/tags/AndroidManifest/" style="font-size: 15px;">AndroidManifest</a> <a href="/tags/activity-alias/" style="font-size: 15px;">activity-alias</a> <a href="/tags/瓦片地图/" style="font-size: 15px;">瓦片地图</a> <a href="/tags/远程视图/" style="font-size: 15px;">远程视图</a> <a href="/tags/AppWidget/" style="font-size: 15px;">AppWidget</a> <a href="/tags/Messenger/" style="font-size: 15px;">Messenger</a> <a href="/tags/进程间通信/" style="font-size: 15px;">进程间通信</a> <a href="/tags/如何看待与学习新技术/" style="font-size: 15px;">如何看待与学习新技术</a> <a href="/tags/本地广播/" style="font-size: 15px;">本地广播</a> <a href="/tags/LRU/" style="font-size: 15px;">LRU</a> <a href="/tags/类加载器/" style="font-size: 15px;">类加载器</a> <a href="/tags/对象创建/" style="font-size: 15px;">对象创建</a> <a href="/tags/内存分配/" style="font-size: 15px;">内存分配</a> <a href="/tags/访问定位/" style="font-size: 15px;">访问定位</a> <a href="/tags/Java内存模型/" style="font-size: 15px;">Java内存模型</a> <a href="/tags/线程/" style="font-size: 15px;">线程</a> <a href="/tags/JVM内存模型/" style="font-size: 15px;">JVM内存模型</a> <a href="/tags/Java内存分配/" style="font-size: 15px;">Java内存分配</a> <a href="/tags/Javac/" style="font-size: 15px;">Javac</a> <a href="/tags/编译过程/" style="font-size: 15px;">编译过程</a> <a href="/tags/Hybrid框架通信/" style="font-size: 15px;">Hybrid框架通信</a> <a href="/tags/Bundle/" style="font-size: 15px;">Bundle</a> <a href="/tags/源码解析/" style="font-size: 15px;">源码解析</a> <a href="/tags/内存优化/" style="font-size: 15px;">内存优化</a> <a href="/tags/高性能编码/" style="font-size: 15px;">高性能编码</a> <a href="/tags/AIDL/" style="font-size: 15px;">AIDL</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Android消息机制源码解析/" style="font-size: 15px;">Android消息机制源码解析</a> <a href="/tags/MessageQueue/" style="font-size: 15px;">MessageQueue</a> <a href="/tags/Handler/" style="font-size: 15px;">Handler</a> <a href="/tags/Looper/" style="font-size: 15px;">Looper</a> <a href="/tags/Message/" style="font-size: 15px;">Message</a> <a href="/tags/Android架构组件/" style="font-size: 15px;">Android架构组件</a> <a href="/tags/Android文件存储/" style="font-size: 15px;">Android文件存储</a> <a href="/tags/内部存储/" style="font-size: 15px;">内部存储</a> <a href="/tags/外部存储/" style="font-size: 15px;">外部存储</a> <a href="/tags/微信分享/" style="font-size: 15px;">微信分享</a> <a href="/tags/分享闭环/" style="font-size: 15px;">分享闭环</a> <a href="/tags/开发经验/" style="font-size: 15px;">开发经验</a> <a href="/tags/Android书籍推荐/" style="font-size: 15px;">Android书籍推荐</a> <a href="/tags/App生命周期/" style="font-size: 15px;">App生命周期</a> <a href="/tags/Android架构/" style="font-size: 15px;">Android架构</a> <a href="/tags/快捷方式/" style="font-size: 15px;">快捷方式</a> <a href="/tags/shortcut/" style="font-size: 15px;">shortcut</a> <a href="/tags/Broadcast/" style="font-size: 15px;">Broadcast</a> <a href="/tags/Android广播/" style="font-size: 15px;">Android广播</a> <a href="/tags/Android布局性能优化/" style="font-size: 15px;">Android布局性能优化</a> <a href="/tags/Android图片缓存/" style="font-size: 15px;">Android图片缓存</a> <a href="/tags/全面屏适配/" style="font-size: 15px;">全面屏适配</a> <a href="/tags/Window/" style="font-size: 15px;">Window</a> <a href="/tags/Android-Studio/" style="font-size: 15px;">Android Studio</a> <a href="/tags/Instant-Run/" style="font-size: 15px;">Instant Run</a> <a href="/tags/Instrumentation/" style="font-size: 15px;">Instrumentation</a> <a href="/tags/activity启动流程/" style="font-size: 15px;">activity启动流程</a> <a href="/tags/choreographer/" style="font-size: 15px;">choreographer</a> <a href="/tags/丢帧/" style="font-size: 15px;">丢帧</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/11/17/理解Java动态代理/">理解Java动态代理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/10/Javac编译过程笔记/">Javac编译过程笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/01/Android-Choreographer/">Android Choreographer</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/12/LocalBroadcastManager原理分析及应用/">LocalBroadcastManager原理分析及应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/15/Java对象创建、内存分配、访问定位概述/">Java对象创建、内存分配、访问定位概述</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/08/Hybrid框架之交互通信篇/">Hybrid框架之交互通信篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/06/Android应用快捷方式/">Android应用快捷方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/15/Android架构组件/">Android架构组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/10/业内移动App架构参考/">业内移动App架构参考</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/08/Android全面屏适配/">Android全面屏适配</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//aspook.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.csdn.net/ahence" title="aspook" target="_blank">aspook</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">ASPOOK.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="请不要灰心，你也会有人妒忌"><title>Android架构组件 | ASPOOK</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android架构组件</h1><a id="logo" href="/.">ASPOOK</a><p class="description">Serendipity</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android架构组件</h1><div class="post-meta">Aug 15, 2017<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2017/08/15/Android架构组件/" href="/2017/08/15/Android架构组件/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>这篇架构指南面向有一定Android开发基础并想了解高质量、高稳定性App最佳实践及推荐架构的开发者。</p>
<blockquote>
<p>注意：这篇指南假设读者熟悉Android Framework，如果你是Android开发新手，建议先去学习<a href="https://developer.android.google.cn/training/index.html" target="_blank" rel="external">入门系列课程</a>，这些课程也是作为学习本指南的基础。</p>
</blockquote>
<h3 id="App_u5F00_u53D1_u8005_u9762_u4E34_u7684_u5E38_u89C1_u95EE_u9898"><a href="#App_u5F00_u53D1_u8005_u9762_u4E34_u7684_u5E38_u89C1_u95EE_u9898" class="headerlink" title="App开发者面临的常见问题"></a>App开发者面临的常见问题</h3><p>移动开发不同于传统的桌面程序开发，桌面程序一般都有唯一的快捷方式入口，并且常作为单进程存在；而Android App则拥有更加复杂的结构，一个典型的Android应用通常由多个应用组件构成，包括不同数量的Activity、Fragment、Service、Content Provider、Broadcast Receiver等。</p>
<p>大部分的组件都会在AndroidManifest中声明，这个配置文件被Android操作系统用来决定如何将App集成到该设备整体的用户体验中去。前文已提到，一个桌面应用程序一般作为独立进程存在，而一个App则需要更加灵活，因为用户在移动设备上，需要经常随意地在App间进行切换，以便完成不同的任务及流程。</p>
<p>举个例子，如果想要在一个社交App上分享一张图片，思考下会是怎样的流程？首先社交App可能会使用Intent方式通过Android系统来启动一个拍照App，此时用户虽然离开了社交App，但其体验是无缝衔接的。同样的，拍照App也可能启动其他应用，如文件选择器或其他。最终用户返回社交App然后分享图片。当然，用户操作可能在上述过程中的任何时刻被电话打断，当通话结束后，再继续进行上述图片分享流程。</p>
<p>在Android中，类似上述App间切换非常频繁，因此我们的App需要正确处理上述流程。需要牢记的是移动设备的资源是有限的，所以在任何时候，操作系统都可能杀死一些App来为一些新的App腾出资源。</p>
<p>所有这些都说明我们的App组件可能被无规则地启动，也可能随时被用户或系统销毁，其生命周期并不由我们控制，因此我们不应该在App组件中存储任何数据而且组件之间也不应该互相依赖。</p>
<h3 id="u901A_u7528_u7684_u67B6_u6784_u539F_u5219"><a href="#u901A_u7528_u7684_u67B6_u6784_u539F_u5219" class="headerlink" title="通用的架构原则"></a>通用的架构原则</h3><p>如果不在App组件中存储数据及状态，那应该怎样架构App呢？</p>
<p>第一，在App开发中，最需要的事情是职责分离（ <a href="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank" rel="external">separation of concerns</a>）。大家通常犯的一个错误是把所有代码都写到Activity或Fragment中，实际上任何跟UI处理或系统交互无关的代码都不应该写到Activity或Fragment中。尽可能保持Activity和Fragment的简洁（职责单一化）可以避免许多生命周期相关的问题。不要忘记你并不能控制这些类，它们就像粘合剂，体现了App和操作系统之间的联系，Android系统可能根据用户操作或其他原因如低内存而随时销毁它们。我们应该最小化对App组件的依赖从而提供一个稳定的用户体验。</p>
<p>第二，另一个重要原则是数据模型驱动UI，最好是可持久化的数据模型。持久化数据有两个好处：</p>
<ol>
<li>当系统为了释放资源而销毁掉App时用户不会丢失数据</li>
<li>当网络状况差或无网络时App依然可以工作</li>
</ol>
<p>Model（数据模型）也可以看做是一种处理App数据的组件，它们独立于视图和其他App组件，因此Model不存在其他组件生命周期相关的问题。保证UI代码简单、不掺杂业务逻辑可以方便管理，数据模型具有管理数据的职责，基于数据模型的应用程序将使它们具有可测性和应用程序一致性。</p>
<h3 id="u63A8_u8350_u7684App_u67B6_u6784"><a href="#u63A8_u8350_u7684App_u67B6_u6784" class="headerlink" title="推荐的App架构"></a>推荐的App架构</h3><p>在这一节，将会通过一个示例来描述如何使用架构组件（<a href="https://developer.android.google.cn/topic/libraries/architecture/index.html" target="_blank" rel="external">Architecture Components</a> ）架构App。</p>
<blockquote>
<p>注意：并不存在一个适用于任何场景的完美架构，也就是说，这里推荐的架构对于大部分开发案例来说只是一个好的开端。如果你已经有了一个不错的Android App架构，你可以继续使用而不用改变。</p>
</blockquote>
<p>假设我们正在开发一个展示用户信息的界面，用户信息将通过REST API从后台请求数据。</p>
<h4 id="u6784_u5EFA_u7528_u6237_u754C_u9762UI"><a href="#u6784_u5EFA_u7528_u6237_u754C_u9762UI" class="headerlink" title="构建用户界面UI"></a>构建用户界面UI</h4><p>用户界面用一个Fragment实现，如<code>UserProfileFragment.java</code> ，其对应的布局文件为<code>user_profile_layout.xml</code>。</p>
<p>为了驱动UI，数据模型需要维护两个数据元素：</p>
<ol>
<li>User ID——用户的标识符，通常使用Fragment参数将此信息传给Fragment。如果Android系统销毁了App进程，User ID可以被保存下来因此当用户下一次启动应用时User ID是可用的</li>
<li>User object——一个POJO对象，用于维护User数据</li>
</ol>
<p>接下来将基于<code>ViewModel</code>来创建一个<code>UserProfileViewModel</code>类来维护上述信息。</p>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/viewmodel.html" target="_blank" rel="external">ViewModel</a>为特定的UI组件（Fragment或Activity）提供数据并处理与业务逻辑的交互，如调用其他组件加载数据。ViewModel与View解耦且不受配置变化的影响，如方向旋转时重建Activity不会影响ViewModel。</p>
<p>现在我们有3个文件：</p>
<ul>
<li><code>user_profile.xml</code>：UI布局文件</li>
<li><code>UserProfileViewModel.java</code>：为UI提供数据的类</li>
<li><code>UserProfileFragment.java</code>：UI Controller用来展示ViewModel中的数据并响应用户交互</li>
</ul>
<p>下面就是初步的实现（为了简单起见，忽略了布局文件）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProfileViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProfileFragment</span> <span class="keyword">extends</span> <span class="title">LifecycleFragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String UID_KEY = <span class="string">"uid"</span>;</span><br><span class="line">    <span class="keyword">private</span> UserProfileViewModel viewModel;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        String userId = getArguments().getString(UID_KEY);</span><br><span class="line">        viewModel = ViewModelProviders.of(<span class="keyword">this</span>).get(UserProfileViewModel.class);</span><br><span class="line">        viewModel.init(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater,</span><br><span class="line">                @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inflater.inflate(R.layout.user_profile, container, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：上面的例子继承了<a href="https://developer.android.google.cn/reference/android/arch/lifecycle/LifecycleFragment.html" target="_blank" rel="external">LifecycleFragment</a>而不是Fragment。当架构组件中的lifecycle API稳定之后，Android Support Library中的Fragment类将实现<a href="https://developer.android.google.cn/reference/android/arch/lifecycle/LifecycleOwner.html" target="_blank" rel="external">LifecycleOwner</a>。</p>
</blockquote>
<p>现在我们有了3个代码模块，应该怎样将它们串联起来呢？毕竟我们需要当ViewModel的user字段改变后能够通知UI，此时LiveData就派上用场了。</p>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/livedata.html" target="_blank" rel="external">LiveData</a>是一个可观察的数据容器，它不需要显式地创建依赖路径就可以被App中的组件观察。LiveData可以根据App组件（Activity、Fragment、Service）的生命周期做正确的事情，从而能够有效阻止App中对象的内存泄露。</p>
<blockquote>
<p>注意：如果你正在使用<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a>或<a href="https://github.com/google/agera" target="_blank" rel="external">Agera</a>或其他方案，你可以继续使用它们替代LiveData，但是必须确保正确处理生命周期逻辑：当组件stopped时应该暂停数据流；当组件destroyed时也应该销毁数据流。也可以添加<code>android.arch.lifecycle:reactivestreams</code>来配合reactive streams library（如RxJava2）使用LiveData。</p>
</blockquote>
<p>现在我们将<code>UserProfileViewModel</code>中的User字段用<code>LiveData&lt;User&gt;</code>来替代，因此当数据变化时Fragment会被通知。最妙的是LiveData是生命周期可感知的，而且会自在不需要的时候自动清除引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProfileViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> LiveData&lt;User&gt; user;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;User&gt; <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来修改UserProfileFragment来观察数据并更新UI。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">    viewModel.getUser().observe(<span class="keyword">this</span>, user -&gt; &#123;</span><br><span class="line">      <span class="comment">// update UI</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当用户数据发生变化时，<code>onChanged</code>回调将会触发，从而导致UI刷新。</p>
<p>如果你熟悉使用被观察者回调模式的其他库，你应该意识到我们不需要重写Fragment的<code>onStop()</code>方法来停止观察数据。对于LiveData这是不必要的，因为它本身是生命周期可感知的，这意味着如果Fragment不在激活状态时（执行了<code>onStart()</code> 但没有执行<code>onStop()</code>），LiveData不会触发回调，同时，LiveData会在Fragment执行了<code>onDestroy()</code>时自动移除观察者。</p>
<p>我们也不需要做任何事情去处理配置改变（如用户旋转屏幕），当配置变化时，ViewModel将会自动恢复，所以当新的Fragment创建后，它会收到相同的ViewModel对象实例并且立即收到当前数据的回调。ViewModel比View的生命周期长，这就是为什么ViewModel不应该直接引用View。更多资料请看<a href="https://developer.android.google.cn/topic/libraries/architecture/viewmodel.html#the_lifecycle_of_a_viewmodel" target="_blank" rel="external">The lifecycle of a ViewModel</a>。</p>
<h4 id="u83B7_u53D6_u6570_u636E"><a href="#u83B7_u53D6_u6570_u636E" class="headerlink" title="获取数据"></a>获取数据</h4><p>现在我们已经将ViewModel和Fragment联系起来，那么ViewModel是如何获取用户数据的呢？在这个示例中，假设后台提供了一个REST API，我们使用<a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit</a>来访问后台接口，当然也可以选择其他库来达到相同目的。</p>
<p>下面是跟后台交互的Retrofit的 <code>Webservice</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Webservice</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * <span class="doctag">@GET</span> declares an HTTP GET request</span><br><span class="line">     * <span class="doctag">@Path</span>("user") annotation on the userId parameter marks it as a</span><br><span class="line">     * replacement for the &#123;user&#125; placeholder in the <span class="doctag">@GET</span> path</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@GET</span>(<span class="string">"/users/&#123;user&#125;"</span>)</span><br><span class="line">    <span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">(@Path(<span class="string">"user"</span>)</span> String userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种简单的实现是ViewModel直接调用<code>Webservice</code>获取数据然后将结果赋值给User对象，虽然这是行得通的，但随着App业务逻辑的增长将变得难以维护。ViewModel承担了太多的职责，这违背了前文提到的职责分离的原则，另外ViewModel绑定了Activity和Fragment的生命周期，当生命周期结束后，ViewModel会丢失所有数据，也是一种不好的用户体验。因此，我们的ViewModel将把数据请求的工作代理给一个新的模块，叫做<strong>Repository</strong>。</p>
<p><strong>Repository</strong>的职责是处理数据操作，为其他模块提供简洁的API。<strong>Repository</strong>知道从哪里获取数据，当数据更新时知道调用什么接口，可以把它想象成不同数据源（持久化的Model、Webservice、Cache等）之间的中介。</p>
<p>下面展示了<code>UserRepository</code>类通过<code>Webservice</code>类获取用户数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Webservice webservice;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;User&gt; <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// This is not an optimal implementation, we'll fix it below</span></span><br><span class="line">        <span class="keyword">final</span> MutableLiveData&lt;User&gt; data = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line">        webservice.getUser(userId).enqueue(<span class="keyword">new</span> Callback&lt;User&gt;() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;User&gt; call, Response&lt;User&gt; response)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// error case is left out for brevity</span></span><br><span class="line">                data.setValue(response.body());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然<strong>Repository</strong>模块看起来是非必需的，但它的作用很重要，它抽象了所有的数据源。现在ViewModel并不知道数据是通过Webservice获取的，这意味着如果有必要，我们可以将具体实现换成其他方式。</p>
<p>注意：为了简单，这里省略了网络异常处理逻辑。对于错误处理及loading状态的处理可以参考 原文附录：<a href="https://developer.android.google.cn/topic/libraries/architecture/guide.html#addendum" target="_blank" rel="external">Addendum: exposing network status</a>。</p>
<h5 id="u7BA1_u7406_u7EC4_u4EF6_u4E4B_u95F4_u7684_u4F9D_u8D56_uFF1A"><a href="#u7BA1_u7406_u7EC4_u4EF6_u4E4B_u95F4_u7684_u4F9D_u8D56_uFF1A" class="headerlink" title="管理组件之间的依赖："></a>管理组件之间的依赖：</h5><p>上面的UserRepository类需要一个Webservice的实例才能工作，虽然创建Webservice实例很简单，但需要创建对Webservice的依赖，这显然会使代码冗余和复杂化（e.g. 每一个需要Webservice实例的类都需要对它的依赖）。另外，UserRepository可能并非唯一需要Webservice的类，如果每一个类都创建一个Webservice，则会造成资源冗余。</p>
<p>有两种方式可以解决这个问题：</p>
<ul>
<li>依赖注入（<a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="external">Dependency Injection</a>）：依赖注入允许一个类定义其依赖而不用事先构造它们，在运行时，另一个类可以提供这些依赖。在Android开发中推荐使用Google的<a href="https://google.github.io/dagger/" target="_blank" rel="external">Dagger 2</a> 进行依赖注入。Dagger 2会自动遍历依赖树来构建出依赖对象并能在编译时对依赖提供验证。</li>
<li>服务定位器（<a href="https://en.wikipedia.org/wiki/Service_locator_pattern" target="_blank" rel="external">Service Locator</a>）：服务定位器提供了一个注册表，从中可以获取依赖。服务定位器的实现比依赖注入相对简单一些，因此如果你对DI不熟悉，可以使用这种方式。</li>
</ul>
<p>上述方法可以清晰地管理依赖而不会产生冗余代码，同时不会增加复杂度。</p>
<p>在这个示例中，我们使用Dagger 2来管理依赖。</p>
<h4 id="u5173_u8054ViewModel_u548CRepository"><a href="#u5173_u8054ViewModel_u548CRepository" class="headerlink" title="关联ViewModel和Repository"></a>关联ViewModel和Repository</h4><p>现在来修改<code>UserProfileViewModel</code>类，让其使用Repository：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProfileViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LiveData&lt;User&gt; user;</span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepo;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Inject</span> <span class="comment">// UserRepository parameter is provided by Dagger 2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserProfileViewModel</span><span class="params">(UserRepository userRepo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userRepo = userRepo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.user != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// ViewModel is created per Fragment so</span></span><br><span class="line">            <span class="comment">// we know the userId won't change</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        user = userRepo.getUser(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;User&gt; <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u7F13_u5B58_u6570_u636E"><a href="#u7F13_u5B58_u6570_u636E" class="headerlink" title="缓存数据"></a>缓存数据</h4><p>上文实现的Repository对Webservice调用的抽象非常好，但由于它只是依赖于单一的数据源，因此并不是很实用。</p>
<p>上文中实现的<code>UserRepository</code>存在的问题是当获取到数据之后，并没有做任何的持久化工作，如果用户离开了<code>UserProfileFragment</code>然后再次回来，App将会重新获取数据，这很糟糕，主要表现在：</p>
<ol>
<li>浪费了流量</li>
<li>强制用户重新等待请求完成</li>
</ol>
<p>为了解决上述问题，我们来添加一个新的数据源用来在内存中缓存User数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Singleton</span>  <span class="comment">// informs Dagger that this class should be constructed once</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Webservice webservice;</span><br><span class="line">    <span class="comment">// simple in memory cache, details omitted for brevity</span></span><br><span class="line">    <span class="keyword">private</span> UserCache userCache;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;User&gt; <span class="title">getUser</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        LiveData&lt;User&gt; cached = userCache.get(userId);</span><br><span class="line">        <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cached;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> MutableLiveData&lt;User&gt; data = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line">        userCache.put(userId, data);</span><br><span class="line">        <span class="comment">// this is still suboptimal but better than before.</span></span><br><span class="line">        <span class="comment">// a complete implementation must also handle the error cases.</span></span><br><span class="line">        webservice.getUser(userId).enqueue(<span class="keyword">new</span> Callback&lt;User&gt;() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;User&gt; call, Response&lt;User&gt; response)</span> </span>&#123;</span><br><span class="line">                data.setValue(response.body());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6301_u4E45_u5316_u6570_u636E"><a href="#u6301_u4E45_u5316_u6570_u636E" class="headerlink" title="持久化数据"></a>持久化数据</h4><p>在当前的实现中，如果用户旋转了屏幕或者离开再次回来，UI将会立即显示数据因为Repository会从内存缓存中获取数据。但是如果用户离开App几个小时之后再次回来，如果Android系统销毁了应用进程，将会发生什么呢？</p>
<p>在这种情况下，将会重新通过网络获取数据，这不仅是一个糟糕的用户体验而且还浪费了流量。解决方案是缓存网络请求的结果。</p>
<p>合理的缓存方法是使用一个持久化的模型，于是<strong>Room</strong>登场了。</p>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/room.html" target="_blank" rel="external">Room</a>是一个提供本地数据存储的对象关系映射库。在编译时，它可以校验每个查询，因此无效的SQL查询将导致编译错误而不是在运行时报错。Room抽象了底层原生的SQL表查询操作，同时允许观察数据库数据（包括集合和关联查询）的变化，并通过LiveData暴露出来。此外，Room还显式地定义了线程约束来处理常见问题，比如在主线程上访问数据。</p>
<blockquote>
<p>注意：如果你熟悉其他的SQLite ORM持久化解决方案或不同的库如 <a href="https://realm.io/products/realm-mobile-database/" target="_blank" rel="external">Realm</a>，你并不需要将其替换为Room，除非Room的一些特性更适合你的应用场景。</p>
</blockquote>
<p>为了使用Room，需要使用@Entity注解来标记User类，此注解会将User作为一张表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="annotation">@PrimaryKey</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String lastName;</span><br><span class="line">  <span class="comment">// getters and setters for fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，通过继承 <a href="https://developer.android.google.cn/reference/android/arch/persistence/room/RoomDatabase.html" target="_blank" rel="external"><code>RoomDatabase</code></a>为App创建一个数据库类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Database</span>(entities = &#123;User.class&#125;, version = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabase</span> <span class="keyword">extends</span> <span class="title">RoomDatabase</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>MyDatabase</code>是一个抽象类，Room自动为其提供实现。可以阅读 <a href="https://developer.android.google.cn/topic/libraries/architecture/room.html" target="_blank" rel="external">Room</a>文档以了解更多。</p>
<p>接下来需要提供一个方法将User数据插入到数据库，因此我们创建了一个<a href="https://en.wikipedia.org/wiki/Data_access_object" target="_blank" rel="external">DAO（data access object）</a>对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Insert</span>(onConflict = REPLACE)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="annotation">@Query</span>(<span class="string">"SELECT * FROM user WHERE id = :userId"</span>)</span><br><span class="line">    <span class="function">LiveData&lt;User&gt; <span class="title">load</span><span class="params">(String userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，从数据库类中引用DAO：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Database</span>(entities = &#123;User.class&#125;, version = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabase</span> <span class="keyword">extends</span> <span class="title">RoomDatabase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> UserDao <span class="title">userDao</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到load方法返回<code>LiveData&lt;User&gt;</code>。Room知道数据库何时被修改且当数据变化时会自动通知所有处于激活状态的观察者。因为使用了LiveData，在至少有一个处于激活状态的观察者时才会更新数据，这将更加高效。</p>
<blockquote>
<p>注意：Room还处于alpha 1版本，Room checks invalidations based on table modifications which means it may dispatch false positive notifications。</p>
</blockquote>
<p>接下来为<code>UserRepository</code>集成Room数据源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Webservice webservice;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserRepository</span><span class="params">(Webservice webservice, UserDao userDao, Executor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.webservice = webservice;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;User&gt; <span class="title">getUser</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        refreshUser(userId);</span><br><span class="line">        <span class="comment">// return a LiveData directly from the database.</span></span><br><span class="line">        <span class="keyword">return</span> userDao.load(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshUser</span><span class="params">(<span class="keyword">final</span> String userId)</span> </span>&#123;</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// running in a background thread</span></span><br><span class="line">            <span class="comment">// check if user was fetched recently</span></span><br><span class="line">            <span class="keyword">boolean</span> userExists = userDao.hasUser(FRESH_TIMEOUT);</span><br><span class="line">            <span class="keyword">if</span> (!userExists) &#123;</span><br><span class="line">                <span class="comment">// refresh the data</span></span><br><span class="line">                Response response = webservice.getUser(userId).execute();</span><br><span class="line">                <span class="comment">// TODO check for error etc.</span></span><br><span class="line">                <span class="comment">// Update the database.The LiveData will automatically refresh so</span></span><br><span class="line">                <span class="comment">// we don't need to do anything else here besides updating the database</span></span><br><span class="line">                userDao.save(response.body());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，即使修改了<code>UserRepository</code>中的数据源，<code>UserProfileViewModel</code>和<code>UserProfileFragment</code>也不需要修改，这就是抽象提供的灵活性。对于测试来说也很有用，因为你可以使用模拟的<code>UserPrository</code>来测试<code>UserProfileViewModel</code>。</p>
<p>现在我们的代码完成了，如果用户几天后再次返回页面，由于做了数据持久化，因此仍然可以立即看到用户数据。同时，如果数据变陈旧了，Repository将会在后台更新数据。当然，根据你的应用场景，也可以选择不显示太陈旧的持久化数据。</p>
<p>在一些需求中，如下拉刷新，将当前的网络操作进度显示给用户很重要。将UI操作与实际数据分开是一种很好的做法，因为它可能出于各种原因进行更新（例如，如果获取好友列表，相同User的获取将导致 <code>LiveData&lt;User&gt;</code> 的更新）。</p>
<p>对于这个案例有两种解决方案：</p>
<ul>
<li>修改getUser，使返回的LiveData中包含网络操作状态。示例实现可参考原文附录一节： <a href="https://developer.android.google.cn/topic/libraries/architecture/guide.html#addendum" target="_blank" rel="external">Addendum: exposing network status</a>。</li>
<li>在Repository类中提供另一个公有方法，用于返回用户的刷新状态。如果你希望在用户显式操作（如下拉刷新）下展示UI中的网络状态，则此方法更好一些。</li>
</ul>
<h5 id="u5355_u4E00_u6570_u636E_u6E90"><a href="#u5355_u4E00_u6570_u636E_u6E90" class="headerlink" title="单一数据源"></a>单一数据源</h5><p>不同的REST API返回相同数据的情况很常见，例如，另一个后台接口返回了好友列表数据，那么相同的User对象将来自两个不同粒度的API。如果<code>UserRepository</code>按照Webservice的请求返回响应结果，UI层则可能出现潜在的数据不一致问题，因为服务端的不同数据接口可能改变。这就是为什么在<code>UserRepository</code>的实现中将Webservice的callback返回的数据直接存到数据库，然后数据库数据的改变则触发LiveData的回调。</p>
<p>在上述模型中，数据库作为单一数据源，App通过Repository来访问数据。无论是否使用磁盘缓存，我们建议Repository需要为App指定一个单一数据源。</p>
<h4 id="u6D4B_u8BD5"><a href="#u6D4B_u8BD5" class="headerlink" title="测试"></a>测试</h4><p>上文提到了职责分离的一大好处是可测性，来看一下怎么对每一个代码模块进行测试。</p>
<ul>
<li><p>User Interface &amp; Interactions：这里需要使用<a href="https://developer.android.google.cn/training/testing/unit-testing/instrumented-unit-tests.html" target="_blank" rel="external">Android UI Instrumentation test</a>，测试UI代码最好的方法是使用<a href="https://developer.android.google.cn/training/testing/ui-testing/espresso-testing.html" target="_blank" rel="external">Espresso</a>。你可以创建一个Fragment并给他提供一个模拟的ViewModel，因为Fragment只与ViewModel交互，所以模拟ViewModel可以非常高效地测试UI。</p>
</li>
<li><p>ViewModel：ViewModel可以使用 <a href="https://developer.android.google.cn/training/testing/unit-testing/local-unit-tests.html" target="_blank" rel="external">JUnit test</a>测试，只需要mock UserRepository即可。</p>
</li>
<li><p>UserRepository：对于UserRepository也可以使用JUnit test，需要mock Webservice和DAO，需要测试它是否正确调用了web服务、是否将结果数据保存到数据库、如果数据被缓存了是否还会进行不必要的请求。因为Webservice和UserDAO都是接口，可以mock它们或实现这些接口以模拟更复杂的测试场景。</p>
</li>
<li><p>UserDao：对于UserDao，推荐的方法是instrumentation测试，因为instrumentation测试不需要任何UI，运行速度很快。对于每一个测试，可以创建一个内存数据库，以确保测试没有任何副作用（如更改磁盘上的数据库文件）。</p>
<p>Room允许指定数据库实现，因此可以通过提供一个<a href="https://developer.android.google.cn/reference/android/arch/persistence/db/SupportSQLiteOpenHelper.html" target="_blank" rel="external"><code>SupportSQLiteOpenHelper</code></a>实现来测试。这种方法并不推荐，因为运行在设备上的SQLite版本可能跟主机上的SQLite版本不一致。</p>
</li>
<li><p>Webservice：保持测试模块之间的独立非常重要，Webservice测试应该避免进行网络调用，有许多类库可以帮我们实现。例如，<a href="https://github.com/square/okhttp/tree/master/mockwebserver" target="_blank" rel="external">MockWebServer</a> 是一个不错的库，可用来为测试需求创建一个模拟的本地服务器。</p>
</li>
<li><p>Testing Artifacts：Android架构组件提供了一个库来控制后台线程。在<code>android.arch.core:core-testing</code> 中，有两条单元测试规则：</p>
<ul>
<li>InstantTaskExecutorRule：这条规则可用来强制架构组件在调用线程立即执行后台操作</li>
<li>CountingTaskExecutorRule：This rule can be used in instrumentation tests to wait for background operations of the Architecture Components or connect it to Espresso as an idling resource。</li>
</ul>
</li>
</ul>
<h4 id="u6700_u7EC8_u7684_u67B6_u6784"><a href="#u6700_u7EC8_u7684_u67B6_u6784" class="headerlink" title="最终的架构"></a>最终的架构</h4><p>下图展示了建议架构中的所有模块以及它们之间的交互：</p>
<p><img src="http://7xq0xd.com1.z0.glb.clouddn.com/image/imgac_architecture.png" alt="这里写图片描述"></p>
<h3 id="u6307_u5BFC_u539F_u5219"><a href="#u6307_u5BFC_u539F_u5219" class="headerlink" title="指导原则"></a>指导原则</h3><p>编程是一个创造性的领域，构建Android应用也不例外。解决问题的方法有很多，下面推荐的一些原则并非强制性的，根据我们的经验，如果遵循下列原则将会使你的应用变得稳定、可测试、可维护。</p>
<ul>
<li>AndroidManifest中定义的入口——如Activity，services，broadcast receiver等不能作为数据源，它们仅应该用来协调与其相关的数据子集，因为App组件生命周期很短，且依赖于用户的交互操作及系统的运行状况，可能随时被销毁。</li>
<li>严格明确App各模块的职责范围，如不要让从网络加载数据的代码分布在多个类或包中。简单来讲， 不要将不相关的职责放到同一个类中。</li>
<li>各个模块尽可能暴露最少的接口，以降低耦合。不要为了方便就将一个模块的内部实现暴露出来，短期来看可能会节省一些时间，但随着代码的迭代增长，将会花费更多的时间来维护。</li>
<li>定义模块之间的交互逻辑时，需要考虑到如何使每个模块可独立测试。例如，一个良好定义的从网络获取数据的API可以使本地数据库持久化模块的测试变得容易。相反，如果将这两个模块的逻辑混合到一起，甚至将网络请求代码分布到各个地方，将导致测试非常困难，甚至无法测试。</li>
<li>App的核心是如何做到使它脱颖而出，不要重复造轮子，也不要一次又一次地在模板代码上浪费时间。如何使App做到独一无二才是值得花费精力的地方，其他的重复工作就让Android架构组件和其他推荐库来做吧。</li>
<li>尽可能为你的App持久化更多的新鲜数据，这样应用在离线状态下也是可用的，因为虽然你的网络状况可能非常好，但用户却不一定。</li>
<li>Repository应该指定单一数据源，无论何时当App需要访问一些数据，都应该从单一数据源获取，具体在前文“单一数据源”一节已经讲过。</li>
</ul>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/guide.html" target="_blank" rel="external">原文地址</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://aspook.com/2017/08/15/Android架构组件/" data-id="cj9jpl51d0070m6xis0e4s8pi" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Android架构组件/">Android架构组件</a></div><div class="post-nav"><a href="/2017/09/06/Android应用快捷方式/" class="pre">Android应用快捷方式</a><a href="/2017/08/10/业内移动App架构参考/" class="next">业内移动App架构参考</a></div><div id="disqus_thread"><script>var disqus_shortname = 'aspook';
var disqus_identifier = '2017/08/15/Android架构组件/';
var disqus_title = 'Android架构组件';
var disqus_url = 'http://aspook.com/2017/08/15/Android架构组件/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//aspook.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://aspook.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithms/">Algorithms</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/GIS/">GIS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈/">杂谈</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/通信/" style="font-size: 15px;">通信</a> <a href="/tags/APK瘦身/" style="font-size: 15px;">APK瘦身</a> <a href="/tags/微信支付/" style="font-size: 15px;">微信支付</a> <a href="/tags/微信wap支付/" style="font-size: 15px;">微信wap支付</a> <a href="/tags/微信网页支付/" style="font-size: 15px;">微信网页支付</a> <a href="/tags/诗词/" style="font-size: 15px;">诗词</a> <a href="/tags/历史/" style="font-size: 15px;">历史</a> <a href="/tags/Web地图/" style="font-size: 15px;">Web地图</a> <a href="/tags/矢量渲染/" style="font-size: 15px;">矢量渲染</a> <a href="/tags/切片地图/" style="font-size: 15px;">切片地图</a> <a href="/tags/栅格地图/" style="font-size: 15px;">栅格地图</a> <a href="/tags/Java泛型/" style="font-size: 15px;">Java泛型</a> <a href="/tags/clone/" style="font-size: 15px;">clone</a> <a href="/tags/对象克隆/" style="font-size: 15px;">对象克隆</a> <a href="/tags/Android线程/" style="font-size: 15px;">Android线程</a> <a href="/tags/线程通信/" style="font-size: 15px;">线程通信</a> <a href="/tags/AsyncTask/" style="font-size: 15px;">AsyncTask</a> <a href="/tags/工具类/" style="font-size: 15px;">工具类</a> <a href="/tags/公有构造函数/" style="font-size: 15px;">公有构造函数</a> <a href="/tags/诗歌/" style="font-size: 15px;">诗歌</a> <a href="/tags/65536/" style="font-size: 15px;">65536</a> <a href="/tags/64K-method/" style="font-size: 15px;">64K method</a> <a href="/tags/App安全/" style="font-size: 15px;">App安全</a> <a href="/tags/gradle/" style="font-size: 15px;">gradle</a> <a href="/tags/build加速/" style="font-size: 15px;">build加速</a> <a href="/tags/Intent/" style="font-size: 15px;">Intent</a> <a href="/tags/垃圾收集算法/" style="font-size: 15px;">垃圾收集算法</a> <a href="/tags/在南下的火车上/" style="font-size: 15px;">在南下的火车上</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/第三方框架/" style="font-size: 15px;">第三方框架</a> <a href="/tags/Android适配/" style="font-size: 15px;">Android适配</a> <a href="/tags/Context/" style="font-size: 15px;">Context</a> <a href="/tags/二叉树/" style="font-size: 15px;">二叉树</a> <a href="/tags/二叉树遍历/" style="font-size: 15px;">二叉树遍历</a> <a href="/tags/深度优先遍历/" style="font-size: 15px;">深度优先遍历</a> <a href="/tags/广度优先遍历/" style="font-size: 15px;">广度优先遍历</a> <a href="/tags/非递归实现/" style="font-size: 15px;">非递归实现</a> <a href="/tags/移动架构/" style="font-size: 15px;">移动架构</a> <a href="/tags/Android架构设计/" style="font-size: 15px;">Android架构设计</a> <a href="/tags/分包策略/" style="font-size: 15px;">分包策略</a> <a href="/tags/so文件/" style="font-size: 15px;">so文件</a> <a href="/tags/PIC/" style="font-size: 15px;">PIC</a> <a href="/tags/text-relocation/" style="font-size: 15px;">text relocation</a> <a href="/tags/AndroidManifest/" style="font-size: 15px;">AndroidManifest</a> <a href="/tags/activity-alias/" style="font-size: 15px;">activity-alias</a> <a href="/tags/瓦片地图/" style="font-size: 15px;">瓦片地图</a> <a href="/tags/远程视图/" style="font-size: 15px;">远程视图</a> <a href="/tags/AppWidget/" style="font-size: 15px;">AppWidget</a> <a href="/tags/Messenger/" style="font-size: 15px;">Messenger</a> <a href="/tags/进程间通信/" style="font-size: 15px;">进程间通信</a> <a href="/tags/如何看待与学习新技术/" style="font-size: 15px;">如何看待与学习新技术</a> <a href="/tags/本地广播/" style="font-size: 15px;">本地广播</a> <a href="/tags/LRU/" style="font-size: 15px;">LRU</a> <a href="/tags/类加载器/" style="font-size: 15px;">类加载器</a> <a href="/tags/对象创建/" style="font-size: 15px;">对象创建</a> <a href="/tags/内存分配/" style="font-size: 15px;">内存分配</a> <a href="/tags/访问定位/" style="font-size: 15px;">访问定位</a> <a href="/tags/Java内存模型/" style="font-size: 15px;">Java内存模型</a> <a href="/tags/线程/" style="font-size: 15px;">线程</a> <a href="/tags/JVM内存模型/" style="font-size: 15px;">JVM内存模型</a> <a href="/tags/Java内存分配/" style="font-size: 15px;">Java内存分配</a> <a href="/tags/Hybrid框架通信/" style="font-size: 15px;">Hybrid框架通信</a> <a href="/tags/Bundle/" style="font-size: 15px;">Bundle</a> <a href="/tags/源码解析/" style="font-size: 15px;">源码解析</a> <a href="/tags/内存优化/" style="font-size: 15px;">内存优化</a> <a href="/tags/高性能编码/" style="font-size: 15px;">高性能编码</a> <a href="/tags/AIDL/" style="font-size: 15px;">AIDL</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Android消息机制源码解析/" style="font-size: 15px;">Android消息机制源码解析</a> <a href="/tags/MessageQueue/" style="font-size: 15px;">MessageQueue</a> <a href="/tags/Handler/" style="font-size: 15px;">Handler</a> <a href="/tags/Looper/" style="font-size: 15px;">Looper</a> <a href="/tags/Message/" style="font-size: 15px;">Message</a> <a href="/tags/Android架构组件/" style="font-size: 15px;">Android架构组件</a> <a href="/tags/Android文件存储/" style="font-size: 15px;">Android文件存储</a> <a href="/tags/内部存储/" style="font-size: 15px;">内部存储</a> <a href="/tags/外部存储/" style="font-size: 15px;">外部存储</a> <a href="/tags/微信分享/" style="font-size: 15px;">微信分享</a> <a href="/tags/分享闭环/" style="font-size: 15px;">分享闭环</a> <a href="/tags/开发经验/" style="font-size: 15px;">开发经验</a> <a href="/tags/Android书籍推荐/" style="font-size: 15px;">Android书籍推荐</a> <a href="/tags/App生命周期/" style="font-size: 15px;">App生命周期</a> <a href="/tags/Android架构/" style="font-size: 15px;">Android架构</a> <a href="/tags/快捷方式/" style="font-size: 15px;">快捷方式</a> <a href="/tags/shortcut/" style="font-size: 15px;">shortcut</a> <a href="/tags/Broadcast/" style="font-size: 15px;">Broadcast</a> <a href="/tags/Android广播/" style="font-size: 15px;">Android广播</a> <a href="/tags/Android布局性能优化/" style="font-size: 15px;">Android布局性能优化</a> <a href="/tags/Android图片缓存/" style="font-size: 15px;">Android图片缓存</a> <a href="/tags/全面屏适配/" style="font-size: 15px;">全面屏适配</a> <a href="/tags/Window/" style="font-size: 15px;">Window</a> <a href="/tags/Android-Studio/" style="font-size: 15px;">Android Studio</a> <a href="/tags/Instant-Run/" style="font-size: 15px;">Instant Run</a> <a href="/tags/Instrumentation/" style="font-size: 15px;">Instrumentation</a> <a href="/tags/activity启动流程/" style="font-size: 15px;">activity启动流程</a> <a href="/tags/choreographer/" style="font-size: 15px;">choreographer</a> <a href="/tags/丢帧/" style="font-size: 15px;">丢帧</a> <a href="/tags/帧率/" style="font-size: 15px;">帧率</a> <a href="/tags/卡顿监控/" style="font-size: 15px;">卡顿监控</a> <a href="/tags/性能监控/" style="font-size: 15px;">性能监控</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/11/01/Android-Choreographer/">Android Choreographer</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/12/LocalBroadcastManager原理分析及应用/">LocalBroadcastManager原理分析及应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/15/Java对象创建、内存分配、访问定位概述/">Java对象创建、内存分配、访问定位概述</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/08/Hybrid框架之交互通信篇/">Hybrid框架之交互通信篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/06/Android应用快捷方式/">Android应用快捷方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/15/Android架构组件/">Android架构组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/10/业内移动App架构参考/">业内移动App架构参考</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/08/Android全面屏适配/">Android全面屏适配</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/07/Android应用架构/">Android应用架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/13/一种Android分包策略推荐/">一种Android分包策略推荐</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//aspook.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.csdn.net/ahence" title="aspook" target="_blank">aspook</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">ASPOOK.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>